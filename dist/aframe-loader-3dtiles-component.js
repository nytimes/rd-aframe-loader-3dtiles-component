/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("THREE"));
	else if(typeof define === 'function' && define.amd)
		define(["THREE"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("THREE")) : factory(root["THREE"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, (__WEBPACK_EXTERNAL_MODULE_three__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/three-loader-3dtiles */ \"./lib/three-loader-3dtiles.js\");\n/* harmony import */ var _textarea__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./textarea */ \"./textarea.js\");\n/* harmony import */ var _textarea__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_textarea__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\nconst POINT_CLOUD_COLORING = {\n  white: _lib_three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.White,\n  intensity: _lib_three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.Intensity,\n  classification: _lib_three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.Classification,\n  elevation: _lib_three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.Elevation,\n  rgb: _lib_three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.RGB\n};\n/**\n * 3D Tiles component for A-Frame.\n */\n\nAFRAME.registerComponent('loader-3dtiles', {\n  schema: {\n    url: {\n      type: 'string'\n    },\n    cameraEl: {\n      type: 'selector'\n    },\n    maximumSSE: {\n      type: 'int',\n      default: 16\n    },\n    maximumMem: {\n      type: 'int',\n      default: 32\n    },\n    distanceScale: {\n      type: 'number',\n      default: 1.0\n    },\n    pointcloudColoring: {\n      type: 'string',\n      default: 'white'\n    },\n    pointcloudElevationRange: {\n      type: 'array',\n      default: ['0', '400']\n    },\n    wireframe: {\n      type: 'boolean',\n      default: false\n    },\n    showStats: {\n      type: 'boolean',\n      default: false\n    },\n    cesiumIONToken: {\n      type: 'string'\n    },\n    googleApiKey: {\n      type: 'string'\n    },\n    lat: {\n      type: 'number'\n    },\n    long: {\n      type: 'number'\n    },\n    height: {\n      type: 'number',\n      default: 0\n    },\n    copyrightEl: {\n      type: 'selector'\n    }\n  },\n  init: async function () {\n    const sceneEl = this.el.sceneEl;\n    const data = this.data;\n    this.camera = data.cameraEl?.object3D.children[0] ?? document.querySelector('a-scene').camera;\n\n    if (!this.camera) {\n      throw new Error('3D Tiles: Please add an active camera or specify the target camera via the cameraEl property');\n    }\n\n    this.viewport = {\n      width: sceneEl.clientWidth,\n      height: sceneEl.clientHeight,\n      devicePixelRatio: window.devicePixelRatio\n    };\n    const {\n      model,\n      runtime\n    } = await this._initTileset();\n    this.el.setObject3D('tileset', model);\n    this.runtime = runtime;\n    this.originalCamera = this.camera;\n    sceneEl.addEventListener('camera-set-active', e => {\n      // TODO: For some reason after closing the inspector this event is fired with an empty camera,\n      // so revert to the original camera used.\n      //\n      // TODO: Does not provide the right Inspector perspective camera\n      this.camera = e.detail.cameraEl.object3D.children[0] ?? this.originalCamera;\n    });\n    this.el.addEventListener('cameraChange', e => {\n      this.camera = e.detail;\n\n      if (this.camera.type === 'OrthographicCamera') {\n        if (this.camera.rotation.x < -1) {\n          // Plan View mode\n          // raise the camera to increase the field of view and update a larger area of tiles\n          this.camera.position.y = 100;\n        } else {\n          // Cross Section mode\n          this.camera.position.y = 10; // default value for ortho camera in Editor\n        }\n      }\n\n      this.runtime.setViewport(this.viewport);\n    });\n    sceneEl.addEventListener('enter-vr', e => {\n      this.originalCamera = this.camera;\n\n      try {\n        this.camera = sceneEl.renderer.xr.getCamera(this.camera); // FOV Code from https://github.com/mrdoob/three.js/issues/21869\n\n        sceneEl.renderer.xr.getSession().requestAnimationFrame((time, frame) => {\n          const ref = sceneEl.renderer.xr.getReferenceSpace();\n          const pose = frame.getViewerPose(ref);\n\n          if (pose) {\n            const fovi = pose.views[0].projectionMatrix[5];\n            this.camera.fov = Math.atan2(1, fovi) * 2 * 180 / Math.PI;\n          }\n        });\n      } catch (e) {\n        console.warn('Could not get VR camera');\n      }\n    });\n    sceneEl.addEventListener('exit-vr', e => {\n      this.camera = this.originalCamera;\n    });\n\n    if (data.showStats) {\n      this.stats = this._initStats();\n    }\n\n    if (THREE.Cache.enabled) {\n      console.warn('3D Tiles loader cannot work with THREE.Cache, disabling.');\n      THREE.Cache.enabled = false;\n    }\n\n    await this._nextFrame();\n    this.runtime = runtime;\n    this.runtime.setElevationRange(data.pointcloudElevationRange.map(n => Number(n)));\n    window.addEventListener('resize', this.onWindowResize.bind(this));\n\n    if (AFRAME.INSPECTOR && AFRAME.INSPECTOR.opened) {\n      // set active inspector camera\n      this.camera = AFRAME.INSPECTOR.camera; // emit play event to start load tiles in aframe-inspector\n\n      this.play();\n    }\n  },\n  onWindowResize: function () {\n    const sceneEl = this.el.sceneEl;\n    this.camera.aspect = sceneEl.clientWidth / sceneEl.clientHeight;\n    this.camera.updateProjectionMatrix();\n    this.viewport = {\n      width: sceneEl.clientWidth,\n      height: sceneEl.clientHeight,\n      devicePixelRatio: window.devicePixelRatio\n    };\n    this.runtime.setViewport(this.viewport);\n  },\n  update: async function (oldData) {\n    if (oldData.url !== this.data.url) {\n      if (this.runtime) {\n        this.runtime.dispose();\n        this.runtime = null;\n      }\n\n      const {\n        model,\n        runtime\n      } = await this._initTileset();\n      this.el.setObject3D('tileset', model);\n      await this._nextFrame();\n      this.runtime = runtime;\n    } else if (this.runtime) {\n      this.runtime.setPointCloudColoring(this._resolvePointcloudColoring(this.data.pointCloudColoring));\n      this.runtime.setWireframe(this.data.wireframe);\n      this.runtime.setViewDistanceScale(this.data.distanceScale);\n      this.runtime.setElevationRange(this.data.pointcloudElevationRange.map(n => Number(n)));\n    }\n\n    if (this.data.showStats && !this.stats) {\n      this.stats = this._initStats();\n    }\n\n    if (!this.data.showStats && this.stats) {\n      this.el.sceneEl.removeChild(this.stats);\n      this.stats = null;\n    } // set parameters for google 3dtiles API\n\n\n    if (this.data.lat && this.data.long || this.data.height) {\n      this.runtime.orientToGeocoord({\n        lat: Number(this.data.lat),\n        long: Number(this.data.long),\n        height: Number(this.data.height)\n      });\n    }\n  },\n  tick: function (t, dt) {\n    if (this.runtime) {\n      this.runtime.update(dt, this.camera);\n\n      if (this.stats) {\n        const worldPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        this.camera.getWorldPosition(worldPos);\n        const stats = this.runtime.getStats();\n        this.stats.setAttribute('textarea', 'text', Object.values(stats.stats).map(s => `${s.name}: ${s.count}`).join('\\n'));\n        const newPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        newPos.copy(worldPos);\n        newPos.z -= 2;\n        this.stats.setAttribute('position', newPos);\n      }\n\n      if (this.data.copyrightEl) {\n        this.data.copyrightEl.innerHTML = this.runtime.getDataAttributions() ?? '';\n      }\n    }\n  },\n  remove: function () {\n    if (this.runtime) {\n      this.runtime.dispose();\n    }\n  },\n\n  _resolvePointcloudColoring() {\n    const pointCloudColoring = POINT_CLOUD_COLORING[this.data.pointcloudColoring];\n\n    if (!pointCloudColoring) {\n      console.warn('Invalid value for point cloud coloring');\n      return _lib_three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.White;\n    } else {\n      return pointCloudColoring;\n    }\n  },\n\n  _initTileset: async function () {\n    const pointCloudColoring = this._resolvePointcloudColoring(this.data.pointcloudColoring);\n\n    return _lib_three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.Loader3DTiles.load({\n      url: this.data.url,\n      renderer: this.el.sceneEl.renderer,\n      options: {\n        googleApiKey: this.data.googleApiKey,\n        cesiumIONToken: this.data.cesiumIONToken,\n        dracoDecoderPath: 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/draco',\n        basisTranscoderPath: 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/basis',\n        maximumScreenSpaceError: this.data.maximumSSE,\n        maximumMemoryUsage: this.data.maximumMem,\n        memoryCacheOverflow: 128,\n        pointCloudColoring: pointCloudColoring,\n        viewDistanceScale: this.data.distanceScale,\n        wireframe: this.data.wireframe,\n        updateTransforms: true\n      },\n      viewport: this.viewport\n    });\n  },\n  _initStats: function () {\n    const stats = document.createElement('a-entity');\n    this.el.sceneEl.appendChild(stats);\n    stats.setAttribute('position', '-0.5 0 -1');\n    stats.setAttribute('textarea', {\n      cols: 30,\n      rows: 15,\n      text: '',\n      color: 'white',\n      disabledBackgroundColor: '#0c1e2c',\n      disabled: true\n    });\n    return stats;\n  },\n  _nextFrame: async function () {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        resolve();\n      }, 0);\n    });\n  }\n});\n\n//# sourceURL=webpack://aframe-loader-3dtiles-component/./index.js?");

/***/ }),

/***/ "./lib/three-loader-3dtiles.js":
/*!*************************************!*\
  !*** ./lib/three-loader-3dtiles.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Loader3DTiles\": () => (/* binding */ t1),\n/* harmony export */   \"PointCloudColoring\": () => (/* binding */ Hc),\n/* harmony export */   \"Shading\": () => (/* binding */ jn)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three/examples/jsm/loaders/KTX2Loader.js */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\nvar jc = Object.defineProperty;\n\nvar kc = (e, t, n) => t in e ? jc(e, t, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: n\n}) : e[t] = n;\n\nvar p = (e, t, n) => (kc(e, typeof t != \"symbol\" ? t + \"\" : t, n), n);\n\n\n\n\n\n\nasync function Ke(e, t, n, s) {\n  return s._parse(e, t, n, s);\n}\n\nfunction z(e, t) {\n  if (!e) throw new Error(t || \"loader assertion failed.\");\n}\n\nconst kn = !!(typeof process != \"object\" || String(process) !== \"[object process]\" || process.browser),\n      Wr = typeof process < \"u\" && process.version && /v([0-9]*)/.exec(process.version);\nWr && parseFloat(Wr[1]);\n\nfunction hu(e, t) {\n  return Xo(e || {}, t);\n}\n\nfunction Xo(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  if (n > 3) return t;\n  const s = { ...e\n  };\n\n  for (const [r, i] of Object.entries(t)) i && typeof i == \"object\" && !Array.isArray(i) ? s[r] = Xo(s[r] || {}, t[r], n + 1) : s[r] = t[r];\n\n  return s;\n}\n\nconst fu = \"latest\";\n\nfunction du() {\n  var e;\n  return (e = globalThis._loadersgl_) !== null && e !== void 0 && e.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = \"4.1.1\"), globalThis._loadersgl_.version;\n}\n\nconst Qo = du();\n\nfunction Jt(e, t) {\n  if (!e) throw new Error(t || \"loaders.gl assertion failed.\");\n}\n\nconst bt = typeof process != \"object\" || String(process) !== \"[object process]\" || process.browser,\n      fr = typeof importScripts == \"function\",\n      mu = typeof window < \"u\" && typeof window.orientation < \"u\",\n      Xr = typeof process < \"u\" && process.version && /v([0-9]*)/.exec(process.version);\nXr && parseFloat(Xr[1]);\n\nclass gu {\n  constructor(t, n) {\n    this.name = void 0, this.workerThread = void 0, this.isRunning = !0, this.result = void 0, this._resolve = () => {}, this._reject = () => {}, this.name = t, this.workerThread = n, this.result = new Promise((s, r) => {\n      this._resolve = s, this._reject = r;\n    });\n  }\n\n  postMessage(t, n) {\n    this.workerThread.postMessage({\n      source: \"loaders.gl\",\n      type: t,\n      payload: n\n    });\n  }\n\n  done(t) {\n    Jt(this.isRunning), this.isRunning = !1, this._resolve(t);\n  }\n\n  error(t) {\n    Jt(this.isRunning), this.isRunning = !1, this._reject(t);\n  }\n\n}\n\nclass is {\n  terminate() {}\n\n}\n\nconst os = /* @__PURE__ */new Map();\n\nfunction Au(e) {\n  Jt(e.source && !e.url || !e.source && e.url);\n  let t = os.get(e.source || e.url);\n  return t || (e.url && (t = pu(e.url), os.set(e.url, t)), e.source && (t = qo(e.source), os.set(e.source, t))), Jt(t), t;\n}\n\nfunction pu(e) {\n  if (!e.startsWith(\"http\")) return e;\n  const t = yu(e);\n  return qo(t);\n}\n\nfunction qo(e) {\n  const t = new Blob([e], {\n    type: \"application/javascript\"\n  });\n  return URL.createObjectURL(t);\n}\n\nfunction yu(e) {\n  return `try {\n  importScripts('${e}');\n} catch (error) {\n  console.error(error);\n  throw error;\n}`;\n}\n\nfunction Yo(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0,\n      n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = n || /* @__PURE__ */new Set();\n\n  if (e) {\n    if (Qr(e)) s.add(e);else if (Qr(e.buffer)) s.add(e.buffer);else if (!ArrayBuffer.isView(e)) {\n      if (t && typeof e == \"object\") for (const r in e) Yo(e[r], t, s);\n    }\n  }\n\n  return n === void 0 ? Array.from(s) : [];\n}\n\nfunction Qr(e) {\n  return e ? e instanceof ArrayBuffer || typeof MessagePort < \"u\" && e instanceof MessagePort || typeof ImageBitmap < \"u\" && e instanceof ImageBitmap || typeof OffscreenCanvas < \"u\" && e instanceof OffscreenCanvas : !1;\n}\n\nconst as = () => {};\n\nclass Vs {\n  static isSupported() {\n    return typeof Worker < \"u\" && bt || typeof is < \"u\" && !bt;\n  }\n\n  constructor(t) {\n    this.name = void 0, this.source = void 0, this.url = void 0, this.terminated = !1, this.worker = void 0, this.onMessage = void 0, this.onError = void 0, this._loadableURL = \"\";\n    const {\n      name: n,\n      source: s,\n      url: r\n    } = t;\n    Jt(s || r), this.name = n, this.source = s, this.url = r, this.onMessage = as, this.onError = i => console.log(i), this.worker = bt ? this._createBrowserWorker() : this._createNodeWorker();\n  }\n\n  destroy() {\n    this.onMessage = as, this.onError = as, this.worker.terminate(), this.terminated = !0;\n  }\n\n  get isRunning() {\n    return !!this.onMessage;\n  }\n\n  postMessage(t, n) {\n    n = n || Yo(t), this.worker.postMessage(t, n);\n  }\n\n  _getErrorFromErrorEvent(t) {\n    let n = \"Failed to load \";\n    return n += `worker ${this.name} from ${this.url}. `, t.message && (n += `${t.message} in `), t.lineno && (n += `:${t.lineno}:${t.colno}`), new Error(n);\n  }\n\n  _createBrowserWorker() {\n    this._loadableURL = Au({\n      source: this.source,\n      url: this.url\n    });\n    const t = new Worker(this._loadableURL, {\n      name: this.name\n    });\n    return t.onmessage = n => {\n      n.data ? this.onMessage(n.data) : this.onError(new Error(\"No data received\"));\n    }, t.onerror = n => {\n      this.onError(this._getErrorFromErrorEvent(n)), this.terminated = !0;\n    }, t.onmessageerror = n => console.error(n), t;\n  }\n\n  _createNodeWorker() {\n    let t;\n\n    if (this.url) {\n      const s = this.url.includes(\":/\") || this.url.startsWith(\"/\") ? this.url : `./${this.url}`;\n      t = new is(s, {\n        eval: !1\n      });\n    } else if (this.source) t = new is(this.source, {\n      eval: !0\n    });else throw new Error(\"no worker\");\n\n    return t.on(\"message\", n => {\n      this.onMessage(n);\n    }), t.on(\"error\", n => {\n      this.onError(n);\n    }), t.on(\"exit\", n => {}), t;\n  }\n\n}\n\nclass Bu {\n  static isSupported() {\n    return Vs.isSupported();\n  }\n\n  constructor(t) {\n    this.name = \"unnamed\", this.source = void 0, this.url = void 0, this.maxConcurrency = 1, this.maxMobileConcurrency = 1, this.onDebug = () => {}, this.reuseWorkers = !0, this.props = {}, this.jobQueue = [], this.idleQueue = [], this.count = 0, this.isDestroyed = !1, this.source = t.source, this.url = t.url, this.setProps(t);\n  }\n\n  destroy() {\n    this.idleQueue.forEach(t => t.destroy()), this.isDestroyed = !0;\n  }\n\n  setProps(t) {\n    this.props = { ...this.props,\n      ...t\n    }, t.name !== void 0 && (this.name = t.name), t.maxConcurrency !== void 0 && (this.maxConcurrency = t.maxConcurrency), t.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = t.maxMobileConcurrency), t.reuseWorkers !== void 0 && (this.reuseWorkers = t.reuseWorkers), t.onDebug !== void 0 && (this.onDebug = t.onDebug);\n  }\n\n  async startJob(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (i, o, a) => i.done(a),\n        s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (i, o) => i.error(o);\n    const r = new Promise(i => (this.jobQueue.push({\n      name: t,\n      onMessage: n,\n      onError: s,\n      onStart: i\n    }), this));\n    return this._startQueuedJob(), await r;\n  }\n\n  async _startQueuedJob() {\n    if (!this.jobQueue.length) return;\n\n    const t = this._getAvailableWorker();\n\n    if (!t) return;\n    const n = this.jobQueue.shift();\n\n    if (n) {\n      this.onDebug({\n        message: \"Starting job\",\n        name: n.name,\n        workerThread: t,\n        backlog: this.jobQueue.length\n      });\n      const s = new gu(n.name, t);\n      t.onMessage = r => n.onMessage(s, r.type, r.payload), t.onError = r => n.onError(s, r), n.onStart(s);\n\n      try {\n        await s.result;\n      } catch (r) {\n        console.error(`Worker exception: ${r}`);\n      } finally {\n        this.returnWorkerToQueue(t);\n      }\n    }\n  }\n\n  returnWorkerToQueue(t) {\n    !bt || this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency() ? (t.destroy(), this.count--) : this.idleQueue.push(t), this.isDestroyed || this._startQueuedJob();\n  }\n\n  _getAvailableWorker() {\n    if (this.idleQueue.length > 0) return this.idleQueue.shift() || null;\n\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const t = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new Vs({\n        name: t,\n        source: this.source,\n        url: this.url\n      });\n    }\n\n    return null;\n  }\n\n  _getMaxConcurrency() {\n    return mu ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n\n}\n\nconst Cu = {\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  reuseWorkers: !0,\n  onDebug: () => {}\n};\n\nclass Nt {\n  static isSupported() {\n    return Vs.isSupported();\n  }\n\n  static getWorkerFarm() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    return Nt._workerFarm = Nt._workerFarm || new Nt({}), Nt._workerFarm.setProps(t), Nt._workerFarm;\n  }\n\n  constructor(t) {\n    this.props = void 0, this.workerPools = /* @__PURE__ */new Map(), this.props = { ...Cu\n    }, this.setProps(t), this.workerPools = /* @__PURE__ */new Map();\n  }\n\n  destroy() {\n    for (const t of this.workerPools.values()) t.destroy();\n\n    this.workerPools = /* @__PURE__ */new Map();\n  }\n\n  setProps(t) {\n    this.props = { ...this.props,\n      ...t\n    };\n\n    for (const n of this.workerPools.values()) n.setProps(this._getWorkerPoolProps());\n  }\n\n  getWorkerPool(t) {\n    const {\n      name: n,\n      source: s,\n      url: r\n    } = t;\n    let i = this.workerPools.get(n);\n    return i || (i = new Bu({\n      name: n,\n      source: s,\n      url: r\n    }), i.setProps(this._getWorkerPoolProps()), this.workerPools.set(n, i)), i;\n  }\n\n  _getWorkerPoolProps() {\n    return {\n      maxConcurrency: this.props.maxConcurrency,\n      maxMobileConcurrency: this.props.maxMobileConcurrency,\n      reuseWorkers: this.props.reuseWorkers,\n      onDebug: this.props.onDebug\n    };\n  }\n\n}\n\nNt._workerFarm = void 0;\n\nfunction Eu(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  const n = t[e.id] || {},\n        s = bt ? `${e.id}-worker.js` : `${e.id}-worker-node.js`;\n  let r = n.workerUrl;\n\n  if (!r && e.id === \"compression\" && (r = t.workerUrl), t._workerType === \"test\" && (bt ? r = `modules/${e.module}/dist/${s}` : r = `modules/${e.module}/src/workers/${e.id}-worker-node.ts`), !r) {\n    let i = e.version;\n    i === \"latest\" && (i = fu);\n    const o = i ? `@${i}` : \"\";\n    r = `https://unpkg.com/@loaders.gl/${e.module}${o}/dist/${s}`;\n  }\n\n  return Jt(r), r;\n}\n\nfunction Tu(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Qo;\n  Jt(e, \"no worker provided\");\n  const n = e.version;\n  return !(!t || !n);\n}\n\nconst bu = {},\n      _u = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  default: bu\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      cs = {};\n\nasync function Zt(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,\n      n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},\n      s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n  return t && (e = wu(e, t, n, s)), cs[e] = cs[e] || Ru(e), await cs[e];\n}\n\nfunction wu(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},\n      s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n  if (!n.useLocalLibraries && e.startsWith(\"http\")) return e;\n  s = s || e;\n  const r = n.modules || {};\n  return r[s] ? r[s] : bt ? n.CDN ? (Jt(n.CDN.startsWith(\"http\")), `${n.CDN}/${t}@${Qo}/dist/libs/${s}`) : fr ? `../src/libs/${s}` : `modules/${t}/src/libs/${s}` : `modules/${t}/dist/libs/${s}`;\n}\n\nasync function Ru(e) {\n  if (e.endsWith(\"wasm\")) return await Su(e);\n  if (!bt) try {\n    return _u && void 0;\n  } catch (n) {\n    return console.error(n), null;\n  }\n  if (fr) return importScripts(e);\n  const t = await Iu(e);\n  return Mu(t, e);\n}\n\nfunction Mu(e, t) {\n  if (!bt) return;\n  if (fr) return eval.call(globalThis, e), null;\n  const n = document.createElement(\"script\");\n  n.id = t;\n\n  try {\n    n.appendChild(document.createTextNode(e));\n  } catch {\n    n.text = e;\n  }\n\n  return document.body.appendChild(n), null;\n}\n\nasync function Su(e) {\n  return await (await fetch(e)).arrayBuffer();\n}\n\nasync function Iu(e) {\n  return await (await fetch(e)).text();\n}\n\nfunction xu(e, t) {\n  return !Nt.isSupported() || !bt && !(t != null && t._nodeWorkers) ? !1 : e.worker && (t == null ? void 0 : t.worker);\n}\n\nasync function vu(e, t, n, s, r) {\n  const i = e.id,\n        o = Eu(e, n),\n        c = Nt.getWorkerFarm(n).getWorkerPool({\n    name: i,\n    url: o\n  });\n  n = JSON.parse(JSON.stringify(n)), s = JSON.parse(JSON.stringify(s || {}));\n  const u = await c.startJob(\"process-on-worker\", Ou.bind(null, r));\n  return u.postMessage(\"process\", {\n    input: t,\n    options: n,\n    context: s\n  }), await (await u.result).result;\n}\n\nasync function Ou(e, t, n, s) {\n  switch (n) {\n    case \"done\":\n      t.done(s);\n      break;\n\n    case \"error\":\n      t.error(new Error(s.error));\n      break;\n\n    case \"process\":\n      const {\n        id: r,\n        input: i,\n        options: o\n      } = s;\n\n      try {\n        const a = await e(i, o);\n        t.postMessage(\"done\", {\n          id: r,\n          result: a\n        });\n      } catch (a) {\n        const c = a instanceof Error ? a.message : \"unknown error\";\n        t.postMessage(\"error\", {\n          id: r,\n          error: c\n        });\n      }\n\n      break;\n\n    default:\n      console.warn(`parse-with-worker unknown message ${n}`);\n  }\n}\n\nfunction Fu(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;\n  return typeof e == \"string\" ? e.slice(0, t) : ArrayBuffer.isView(e) ? qr(e.buffer, e.byteOffset, t) : e instanceof ArrayBuffer ? qr(e, 0, t) : \"\";\n}\n\nfunction qr(e, t, n) {\n  if (e.byteLength <= t + n) return \"\";\n  const s = new DataView(e);\n  let r = \"\";\n\n  for (let i = 0; i < n; i++) r += String.fromCharCode(s.getUint8(t + i));\n\n  return r;\n}\n\nfunction Du(e) {\n  try {\n    return JSON.parse(e);\n  } catch {\n    throw new Error(`Failed to parse JSON from data starting with \"${Fu(e)}\"`);\n  }\n}\n\nfunction Lu(e, t, n) {\n  if (n = n || e.byteLength, e.byteLength < n || t.byteLength < n) return !1;\n  const s = new Uint8Array(e),\n        r = new Uint8Array(t);\n\n  for (let i = 0; i < s.length; ++i) if (s[i] !== r[i]) return !1;\n\n  return !0;\n}\n\nfunction Pu() {\n  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];\n\n  return Gu(t);\n}\n\nfunction Gu(e) {\n  const t = e.map(i => i instanceof ArrayBuffer ? new Uint8Array(i) : i),\n        n = t.reduce((i, o) => i + o.byteLength, 0),\n        s = new Uint8Array(n);\n  let r = 0;\n\n  for (const i of t) s.set(i, r), r += i.byteLength;\n\n  return s.buffer;\n}\n\nfunction dr(e, t, n) {\n  const s = n !== void 0 ? new Uint8Array(e).subarray(t, t + n) : new Uint8Array(e).subarray(t);\n  return new Uint8Array(s).buffer;\n}\n\nfunction ze(e, t) {\n  return z(e >= 0), z(t > 0), e + (t - 1) & ~(t - 1);\n}\n\nfunction Nu(e, t, n) {\n  let s;\n  if (e instanceof ArrayBuffer) s = new Uint8Array(e);else {\n    const r = e.byteOffset,\n          i = e.byteLength;\n    s = new Uint8Array(e.buffer || e.arrayBuffer, r, i);\n  }\n  return t.set(s, n), n + ze(s.byteLength, 4);\n}\n\nasync function Uu(e) {\n  const t = [];\n\n  for await (const n of e) t.push(n);\n\n  return Pu(...t);\n}\n\nfunction Yr() {\n  let e;\n  if (typeof window < \"u\" && window.performance) e = window.performance.now();else if (typeof process < \"u\" && process.hrtime) {\n    const t = process.hrtime();\n    e = t[0] * 1e3 + t[1] / 1e6;\n  } else e = Date.now();\n  return e;\n}\n\nclass $r {\n  constructor(t, n) {\n    this.name = void 0, this.type = void 0, this.sampleSize = 1, this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this.name = t, this.type = n, this.reset();\n  }\n\n  reset() {\n    return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this;\n  }\n\n  setSampleSize(t) {\n    return this.sampleSize = t, this;\n  }\n\n  incrementCount() {\n    return this.addCount(1), this;\n  }\n\n  decrementCount() {\n    return this.subtractCount(1), this;\n  }\n\n  addCount(t) {\n    return this._count += t, this._samples++, this._checkSampling(), this;\n  }\n\n  subtractCount(t) {\n    return this._count -= t, this._samples++, this._checkSampling(), this;\n  }\n\n  addTime(t) {\n    return this._time += t, this.lastTiming = t, this._samples++, this._checkSampling(), this;\n  }\n\n  timeStart() {\n    return this._startTime = Yr(), this._timerPending = !0, this;\n  }\n\n  timeEnd() {\n    return this._timerPending ? (this.addTime(Yr() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this;\n  }\n\n  getSampleAverageCount() {\n    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;\n  }\n\n  getSampleAverageTime() {\n    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;\n  }\n\n  getSampleHz() {\n    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;\n  }\n\n  getAverageCount() {\n    return this.samples > 0 ? this.count / this.samples : 0;\n  }\n\n  getAverageTime() {\n    return this.samples > 0 ? this.time / this.samples : 0;\n  }\n\n  getHz() {\n    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;\n  }\n\n  _checkSampling() {\n    this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);\n  }\n\n}\n\nclass $o {\n  constructor(t) {\n    this.id = void 0, this.stats = {}, this.id = t.id, this.stats = {}, this._initializeStats(t.stats), Object.seal(this);\n  }\n\n  get(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"count\";\n    return this._getOrCreate({\n      name: t,\n      type: n\n    });\n  }\n\n  get size() {\n    return Object.keys(this.stats).length;\n  }\n\n  reset() {\n    for (const t of Object.values(this.stats)) t.reset();\n\n    return this;\n  }\n\n  forEach(t) {\n    for (const n of Object.values(this.stats)) t(n);\n  }\n\n  getTable() {\n    const t = {};\n    return this.forEach(n => {\n      t[n.name] = {\n        time: n.time || 0,\n        count: n.count || 0,\n        average: n.getAverageTime() || 0,\n        hz: n.getHz() || 0\n      };\n    }), t;\n  }\n\n  _initializeStats() {\n    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach(n => this._getOrCreate(n));\n  }\n\n  _getOrCreate(t) {\n    const {\n      name: n,\n      type: s\n    } = t;\n    let r = this.stats[n];\n    return r || (t instanceof $r ? r = t : r = new $r(n, s), this.stats[n] = r), r;\n  }\n\n}\n\nlet Hu = \"\";\nconst Zr = {};\n\nfunction Ju(e) {\n  for (const t in Zr) if (e.startsWith(t)) {\n    const n = Zr[t];\n    e = e.replace(t, n);\n  }\n\n  return !e.startsWith(\"http://\") && !e.startsWith(\"https://\") && (e = `${Hu}${e}`), e;\n}\n\nfunction Vu(e) {\n  return e && typeof e == \"object\" && e.isBuffer;\n}\n\nfunction Zo(e) {\n  if (Vu(e)) return e;\n  if (e instanceof ArrayBuffer) return e;\n  if (ArrayBuffer.isView(e)) return e.byteOffset === 0 && e.byteLength === e.buffer.byteLength ? e.buffer : e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);\n\n  if (typeof e == \"string\") {\n    const t = e;\n    return new TextEncoder().encode(t).buffer;\n  }\n\n  if (e && typeof e == \"object\" && e._toArrayBuffer) return e._toArrayBuffer();\n  throw new Error(\"toArrayBuffer\");\n}\n\nfunction ju() {\n  var e;\n  if (typeof process < \"u\" && typeof process.cwd < \"u\") return process.cwd();\n  const t = (e = window.location) === null || e === void 0 ? void 0 : e.pathname;\n  return (t == null ? void 0 : t.slice(0, t.lastIndexOf(\"/\") + 1)) || \"\";\n}\n\nfunction ta(e) {\n  const t = e ? e.lastIndexOf(\"/\") : -1;\n  return t >= 0 ? e.substr(t + 1) : \"\";\n}\n\nfunction ea(e) {\n  const t = e ? e.lastIndexOf(\"/\") : -1;\n  return t >= 0 ? e.substr(0, t) : \"\";\n}\n\nfunction ku() {\n  const e = [];\n\n  for (let r = 0; r < arguments.length; r++) e[r] = r < 0 || arguments.length <= r ? void 0 : arguments[r];\n\n  let t = \"\",\n      n = !1,\n      s;\n\n  for (let r = e.length - 1; r >= -1 && !n; r--) {\n    let i;\n    r >= 0 ? i = e[r] : (s === void 0 && (s = ju()), i = s), i.length !== 0 && (t = `${i}/${t}`, n = i.charCodeAt(0) === Ie);\n  }\n\n  return t = Ku(t, !n), n ? `/${t}` : t.length > 0 ? t : \".\";\n}\n\nconst Ie = 47,\n      us = 46;\n\nfunction Ku(e, t) {\n  let n = \"\",\n      s = -1,\n      r = 0,\n      i,\n      o = !1;\n\n  for (let a = 0; a <= e.length; ++a) {\n    if (a < e.length) i = e.charCodeAt(a);else {\n      if (i === Ie) break;\n      i = Ie;\n    }\n\n    if (i === Ie) {\n      if (!(s === a - 1 || r === 1)) if (s !== a - 1 && r === 2) {\n        if (n.length < 2 || !o || n.charCodeAt(n.length - 1) !== us || n.charCodeAt(n.length - 2) !== us) {\n          if (n.length > 2) {\n            const c = n.length - 1;\n            let u = c;\n\n            for (; u >= 0 && n.charCodeAt(u) !== Ie; --u);\n\n            if (u !== c) {\n              n = u === -1 ? \"\" : n.slice(0, u), s = a, r = 0, o = !1;\n              continue;\n            }\n          } else if (n.length === 2 || n.length === 1) {\n            n = \"\", s = a, r = 0, o = !1;\n            continue;\n          }\n        }\n\n        t && (n.length > 0 ? n += \"/..\" : n = \"..\", o = !0);\n      } else {\n        const c = e.slice(s + 1, a);\n        n.length > 0 ? n += `/${c}` : n = c, o = !1;\n      }\n      s = a, r = 0;\n    } else i === us && r !== -1 ? ++r : r = -1;\n  }\n\n  return n;\n}\n\nconst zu = e => typeof e == \"boolean\",\n      ve = e => typeof e == \"function\",\n      We = e => e !== null && typeof e == \"object\",\n      ti = e => We(e) && e.constructor === {}.constructor,\n      Wu = e => !!e && typeof e[Symbol.iterator] == \"function\",\n      Xu = e => e && typeof e[Symbol.asyncIterator] == \"function\",\n      se = e => typeof Response < \"u\" && e instanceof Response || e && e.arrayBuffer && e.text && e.json,\n      re = e => typeof Blob < \"u\" && e instanceof Blob,\n      Qu = e => e && typeof e == \"object\" && e.isBuffer,\n      qu = e => typeof ReadableStream < \"u\" && e instanceof ReadableStream || We(e) && ve(e.tee) && ve(e.cancel) && ve(e.getReader),\n      Yu = e => We(e) && ve(e.read) && ve(e.pipe) && zu(e.readable),\n      na = e => qu(e) || Yu(e),\n      $u = /^data:([-\\w.]+\\/[-\\w.+]+)(;|,)/,\n      Zu = /^([-\\w.]+\\/[-\\w.+]+)/;\n\nfunction tl(e) {\n  const t = Zu.exec(e);\n  return t ? t[1] : e;\n}\n\nfunction ei(e) {\n  const t = $u.exec(e);\n  return t ? t[1] : \"\";\n}\n\nconst sa = /\\?.*/;\n\nfunction el(e) {\n  const t = e.match(sa);\n  return t && t[0];\n}\n\nfunction mr(e) {\n  return e.replace(sa, \"\");\n}\n\nfunction Kn(e) {\n  return se(e) ? e.url : re(e) ? e.name || \"\" : typeof e == \"string\" ? e : \"\";\n}\n\nfunction gr(e) {\n  if (se(e)) {\n    const t = e,\n          n = t.headers.get(\"content-type\") || \"\",\n          s = mr(t.url);\n    return tl(n) || ei(s);\n  }\n\n  return re(e) ? e.type || \"\" : typeof e == \"string\" ? ei(e) : \"\";\n}\n\nfunction nl(e) {\n  return se(e) ? e.headers[\"content-length\"] || -1 : re(e) ? e.size : typeof e == \"string\" ? e.length : e instanceof ArrayBuffer || ArrayBuffer.isView(e) ? e.byteLength : -1;\n}\n\nasync function ra(e) {\n  if (se(e)) return e;\n  const t = {},\n        n = nl(e);\n  n >= 0 && (t[\"content-length\"] = String(n));\n  const s = Kn(e),\n        r = gr(e);\n  r && (t[\"content-type\"] = r);\n  const i = await il(e);\n  i && (t[\"x-first-bytes\"] = i), typeof e == \"string\" && (e = new TextEncoder().encode(e));\n  const o = new Response(e, {\n    headers: t\n  });\n  return Object.defineProperty(o, \"url\", {\n    value: s\n  }), o;\n}\n\nasync function sl(e) {\n  if (!e.ok) {\n    const t = await rl(e);\n    throw new Error(t);\n  }\n}\n\nasync function rl(e) {\n  let t = `Failed to fetch resource ${e.url} (${e.status}): `;\n\n  try {\n    const n = e.headers.get(\"Content-Type\");\n    let s = e.statusText;\n    n != null && n.includes(\"application/json\") && (s += ` ${await e.text()}`), t += s, t = t.length > 60 ? `${t.slice(0, 60)}...` : t;\n  } catch {}\n\n  return t;\n}\n\nasync function il(e) {\n  if (typeof e == \"string\") return `data:,${e.slice(0, 5)}`;\n\n  if (e instanceof Blob) {\n    const n = e.slice(0, 5);\n    return await new Promise(s => {\n      const r = new FileReader();\n      r.onload = i => {\n        var o;\n        return s(i == null || (o = i.target) === null || o === void 0 ? void 0 : o.result);\n      }, r.readAsDataURL(n);\n    });\n  }\n\n  if (e instanceof ArrayBuffer) {\n    const n = e.slice(0, 5);\n    return `data:base64,${ol(n)}`;\n  }\n\n  return null;\n}\n\nfunction ol(e) {\n  let t = \"\";\n  const n = new Uint8Array(e);\n\n  for (let s = 0; s < n.byteLength; s++) t += String.fromCharCode(n[s]);\n\n  return btoa(t);\n}\n\nfunction al(e) {\n  return !cl(e) && !ul(e);\n}\n\nfunction cl(e) {\n  return e.startsWith(\"http:\") || e.startsWith(\"https:\");\n}\n\nfunction ul(e) {\n  return e.startsWith(\"data:\");\n}\n\nasync function Ge(e, t) {\n  if (typeof e == \"string\") {\n    const r = Ju(e);\n\n    if (al(r)) {\n      var n;\n\n      if ((n = globalThis.loaders) !== null && n !== void 0 && n.fetchNode) {\n        var s;\n        return (s = globalThis.loaders) === null || s === void 0 ? void 0 : s.fetchNode(r, t);\n      }\n    }\n\n    return await fetch(r, t);\n  }\n\n  return await ra(e);\n}\n\nfunction ll(e) {\n  if (typeof window < \"u\" && typeof window.process == \"object\" && window.process.type === \"renderer\" || typeof process < \"u\" && typeof process.versions == \"object\" && process.versions.electron) return !0;\n  const t = typeof navigator == \"object\" && typeof navigator.userAgent == \"string\" && navigator.userAgent,\n        n = e || t;\n  return !!(n && n.indexOf(\"Electron\") >= 0);\n}\n\nfunction Xe() {\n  return !(typeof process == \"object\" && String(process) === \"[object process]\" && !process.browser) || ll();\n}\n\nconst Ze = globalThis.window || globalThis.self || globalThis.global,\n      Ee = globalThis.process || {},\n      ia = typeof __VERSION__ < \"u\" ? __VERSION__ : \"untranspiled source\";\nXe();\n\nfunction hl(e) {\n  try {\n    const t = window[e],\n          n = \"__storage_test__\";\n    return t.setItem(n, n), t.removeItem(n), t;\n  } catch {\n    return null;\n  }\n}\n\nclass fl {\n  constructor(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"sessionStorage\";\n    this.storage = void 0, this.id = void 0, this.config = void 0, this.storage = hl(s), this.id = t, this.config = n, this._loadConfiguration();\n  }\n\n  getConfiguration() {\n    return this.config;\n  }\n\n  setConfiguration(t) {\n    if (Object.assign(this.config, t), this.storage) {\n      const n = JSON.stringify(this.config);\n      this.storage.setItem(this.id, n);\n    }\n  }\n\n  _loadConfiguration() {\n    let t = {};\n\n    if (this.storage) {\n      const n = this.storage.getItem(this.id);\n      t = n ? JSON.parse(n) : {};\n    }\n\n    return Object.assign(this.config, t), this;\n  }\n\n}\n\nfunction dl(e) {\n  let t;\n  return e < 10 ? t = \"\".concat(e.toFixed(2), \"ms\") : e < 100 ? t = \"\".concat(e.toFixed(1), \"ms\") : e < 1e3 ? t = \"\".concat(e.toFixed(0), \"ms\") : t = \"\".concat((e / 1e3).toFixed(2), \"s\"), t;\n}\n\nfunction ml(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;\n  const n = Math.max(t - e.length, 0);\n  return \"\".concat(\" \".repeat(n)).concat(e);\n}\n\nfunction ls(e, t, n) {\n  let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;\n  const r = e.src.replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\");\n  e.width > s && (n = Math.min(n, s / e.width));\n  const i = e.width * n,\n        o = e.height * n,\n        a = [\"font-size:1px;\", \"padding:\".concat(Math.floor(o / 2), \"px \").concat(Math.floor(i / 2), \"px;\"), \"line-height:\".concat(o, \"px;\"), \"background:url(\".concat(r, \");\"), \"background-size:\".concat(i, \"px \").concat(o, \"px;\"), \"color:transparent;\"].join(\"\");\n  return [\"\".concat(t, \" %c+\"), a];\n}\n\nlet In;\n\n(function (e) {\n  e[e.BLACK = 30] = \"BLACK\", e[e.RED = 31] = \"RED\", e[e.GREEN = 32] = \"GREEN\", e[e.YELLOW = 33] = \"YELLOW\", e[e.BLUE = 34] = \"BLUE\", e[e.MAGENTA = 35] = \"MAGENTA\", e[e.CYAN = 36] = \"CYAN\", e[e.WHITE = 37] = \"WHITE\", e[e.BRIGHT_BLACK = 90] = \"BRIGHT_BLACK\", e[e.BRIGHT_RED = 91] = \"BRIGHT_RED\", e[e.BRIGHT_GREEN = 92] = \"BRIGHT_GREEN\", e[e.BRIGHT_YELLOW = 93] = \"BRIGHT_YELLOW\", e[e.BRIGHT_BLUE = 94] = \"BRIGHT_BLUE\", e[e.BRIGHT_MAGENTA = 95] = \"BRIGHT_MAGENTA\", e[e.BRIGHT_CYAN = 96] = \"BRIGHT_CYAN\", e[e.BRIGHT_WHITE = 97] = \"BRIGHT_WHITE\";\n})(In || (In = {}));\n\nconst gl = 10;\n\nfunction ni(e) {\n  return typeof e != \"string\" ? e : (e = e.toUpperCase(), In[e] || In.WHITE);\n}\n\nfunction Al(e, t, n) {\n  if (!Xe && typeof e == \"string\") {\n    if (t) {\n      const s = ni(t);\n      e = \"\\x1B[\".concat(s, \"m\").concat(e, \"\\x1B[39m\");\n    }\n\n    if (n) {\n      const s = ni(n);\n      e = \"\\x1B[\".concat(s + gl, \"m\").concat(e, \"\\x1B[49m\");\n    }\n  }\n\n  return e;\n}\n\nfunction pl(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [\"constructor\"];\n  const n = Object.getPrototypeOf(e),\n        s = Object.getOwnPropertyNames(n),\n        r = e;\n\n  for (const i of s) {\n    const o = r[i];\n    typeof o == \"function\" && (t.find(a => i === a) || (r[i] = o.bind(e)));\n  }\n}\n\nfunction xn(e, t) {\n  if (!e) throw new Error(t || \"Assertion failed\");\n}\n\nfunction ae() {\n  let e;\n\n  if (Xe() && Ze.performance) {\n    var t, n;\n    e = Ze == null || (t = Ze.performance) === null || t === void 0 || (n = t.now) === null || n === void 0 ? void 0 : n.call(t);\n  } else if (\"hrtime\" in Ee) {\n    var s;\n    const r = Ee == null || (s = Ee.hrtime) === null || s === void 0 ? void 0 : s.call(Ee);\n    e = r[0] * 1e3 + r[1] / 1e6;\n  } else e = Date.now();\n\n  return e;\n}\n\nconst ce = {\n  debug: Xe() && console.debug || console.log,\n  log: console.log,\n  info: console.info,\n  warn: console.warn,\n  error: console.error\n},\n      yl = {\n  enabled: !0,\n  level: 0\n};\n\nfunction Ct() {}\n\nconst si = {},\n      ri = {\n  once: !0\n};\n\nclass zn {\n  constructor() {\n    let {\n      id: t\n    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {\n      id: \"\"\n    };\n    this.id = void 0, this.VERSION = ia, this._startTs = ae(), this._deltaTs = ae(), this._storage = void 0, this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = t, this.userData = {}, this._storage = new fl(\"__probe-\".concat(this.id, \"__\"), yl), this.timeStamp(\"\".concat(this.id, \" started\")), pl(this), Object.seal(this);\n  }\n\n  set level(t) {\n    this.setLevel(t);\n  }\n\n  get level() {\n    return this.getLevel();\n  }\n\n  isEnabled() {\n    return this._storage.config.enabled;\n  }\n\n  getLevel() {\n    return this._storage.config.level;\n  }\n\n  getTotal() {\n    return Number((ae() - this._startTs).toPrecision(10));\n  }\n\n  getDelta() {\n    return Number((ae() - this._deltaTs).toPrecision(10));\n  }\n\n  set priority(t) {\n    this.level = t;\n  }\n\n  get priority() {\n    return this.level;\n  }\n\n  getPriority() {\n    return this.level;\n  }\n\n  enable() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;\n    return this._storage.setConfiguration({\n      enabled: t\n    }), this;\n  }\n\n  setLevel(t) {\n    return this._storage.setConfiguration({\n      level: t\n    }), this;\n  }\n\n  get(t) {\n    return this._storage.config[t];\n  }\n\n  set(t, n) {\n    this._storage.setConfiguration({\n      [t]: n\n    });\n  }\n\n  settings() {\n    console.table ? console.table(this._storage.config) : console.log(this._storage.config);\n  }\n\n  assert(t, n) {\n    xn(t, n);\n  }\n\n  warn(t) {\n    return this._getLogFunction(0, t, ce.warn, arguments, ri);\n  }\n\n  error(t) {\n    return this._getLogFunction(0, t, ce.error, arguments);\n  }\n\n  deprecated(t, n) {\n    return this.warn(\"`\".concat(t, \"` is deprecated and will be removed in a later version. Use `\").concat(n, \"` instead\"));\n  }\n\n  removed(t, n) {\n    return this.error(\"`\".concat(t, \"` has been removed. Use `\").concat(n, \"` instead\"));\n  }\n\n  probe(t, n) {\n    return this._getLogFunction(t, n, ce.log, arguments, {\n      time: !0,\n      once: !0\n    });\n  }\n\n  log(t, n) {\n    return this._getLogFunction(t, n, ce.debug, arguments);\n  }\n\n  info(t, n) {\n    return this._getLogFunction(t, n, console.info, arguments);\n  }\n\n  once(t, n) {\n    return this._getLogFunction(t, n, ce.debug || ce.info, arguments, ri);\n  }\n\n  table(t, n, s) {\n    return n ? this._getLogFunction(t, n, console.table || Ct, s && [s], {\n      tag: Tl(n)\n    }) : Ct;\n  }\n\n  image(t) {\n    let {\n      logLevel: n,\n      priority: s,\n      image: r,\n      message: i = \"\",\n      scale: o = 1\n    } = t;\n    return this._shouldLog(n || s) ? Xe() ? El({\n      image: r,\n      message: i,\n      scale: o\n    }) : Cl() : Ct;\n  }\n\n  time(t, n) {\n    return this._getLogFunction(t, n, console.time ? console.time : console.info);\n  }\n\n  timeEnd(t, n) {\n    return this._getLogFunction(t, n, console.timeEnd ? console.timeEnd : console.info);\n  }\n\n  timeStamp(t, n) {\n    return this._getLogFunction(t, n, console.timeStamp || Ct);\n  }\n\n  group(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {\n      collapsed: !1\n    };\n    const r = ii({\n      logLevel: t,\n      message: n,\n      opts: s\n    }),\n          {\n      collapsed: i\n    } = s;\n    return r.method = (i ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(r);\n  }\n\n  groupCollapsed(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return this.group(t, n, Object.assign({}, s, {\n      collapsed: !0\n    }));\n  }\n\n  groupEnd(t) {\n    return this._getLogFunction(t, \"\", console.groupEnd || Ct);\n  }\n\n  withGroup(t, n, s) {\n    this.group(t, n)();\n\n    try {\n      s();\n    } finally {\n      this.groupEnd(t)();\n    }\n  }\n\n  trace() {\n    console.trace && console.trace();\n  }\n\n  _shouldLog(t) {\n    return this.isEnabled() && this.getLevel() >= oa(t);\n  }\n\n  _getLogFunction(t, n, s, r, i) {\n    if (this._shouldLog(t)) {\n      i = ii({\n        logLevel: t,\n        message: n,\n        args: r,\n        opts: i\n      }), s = s || i.method, xn(s), i.total = this.getTotal(), i.delta = this.getDelta(), this._deltaTs = ae();\n      const o = i.tag || i.message;\n      if (i.once && o) if (!si[o]) si[o] = ae();else return Ct;\n      return n = Bl(this.id, i.message, i), s.bind(console, n, ...i.args);\n    }\n\n    return Ct;\n  }\n\n}\n\nzn.VERSION = ia;\n\nfunction oa(e) {\n  if (!e) return 0;\n  let t;\n\n  switch (typeof e) {\n    case \"number\":\n      t = e;\n      break;\n\n    case \"object\":\n      t = e.logLevel || e.priority || 0;\n      break;\n\n    default:\n      return 0;\n  }\n\n  return xn(Number.isFinite(t) && t >= 0), t;\n}\n\nfunction ii(e) {\n  const {\n    logLevel: t,\n    message: n\n  } = e;\n  e.logLevel = oa(t);\n  const s = e.args ? Array.from(e.args) : [];\n\n  for (; s.length && s.shift() !== n;);\n\n  switch (typeof t) {\n    case \"string\":\n    case \"function\":\n      n !== void 0 && s.unshift(n), e.message = t;\n      break;\n\n    case \"object\":\n      Object.assign(e, t);\n      break;\n  }\n\n  typeof e.message == \"function\" && (e.message = e.message());\n  const r = typeof e.message;\n  return xn(r === \"string\" || r === \"object\"), Object.assign(e, {\n    args: s\n  }, e.opts);\n}\n\nfunction Bl(e, t, n) {\n  if (typeof t == \"string\") {\n    const s = n.time ? ml(dl(n.total)) : \"\";\n    t = n.time ? \"\".concat(e, \": \").concat(s, \"  \").concat(t) : \"\".concat(e, \": \").concat(t), t = Al(t, n.color, n.background);\n  }\n\n  return t;\n}\n\nfunction Cl(e) {\n  return console.warn(\"removed\"), Ct;\n}\n\nfunction El(e) {\n  let {\n    image: t,\n    message: n = \"\",\n    scale: s = 1\n  } = e;\n\n  if (typeof t == \"string\") {\n    const i = new Image();\n    return i.onload = () => {\n      const o = ls(i, n, s);\n      console.log(...o);\n    }, i.src = t, Ct;\n  }\n\n  const r = t.nodeName || \"\";\n  if (r.toLowerCase() === \"img\") return console.log(...ls(t, n, s)), Ct;\n\n  if (r.toLowerCase() === \"canvas\") {\n    const i = new Image();\n    return i.onload = () => console.log(...ls(i, n, s)), i.src = t.toDataURL(), Ct;\n  }\n\n  return Ct;\n}\n\nfunction Tl(e) {\n  for (const t in e) for (const n in e[t]) return n || \"untitled\";\n\n  return \"empty\";\n}\n\nconst aa = new zn({\n  id: \"@probe.gl/log\"\n}),\n      oi = new zn({\n  id: \"loaders.gl\"\n});\n\nclass bl {\n  log() {\n    return () => {};\n  }\n\n  info() {\n    return () => {};\n  }\n\n  warn() {\n    return () => {};\n  }\n\n  error() {\n    return () => {};\n  }\n\n}\n\nclass _l {\n  constructor() {\n    this.console = void 0, this.console = console;\n  }\n\n  log() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++) n[s] = arguments[s];\n\n    return this.console.log.bind(this.console, ...n);\n  }\n\n  info() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++) n[s] = arguments[s];\n\n    return this.console.info.bind(this.console, ...n);\n  }\n\n  warn() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++) n[s] = arguments[s];\n\n    return this.console.warn.bind(this.console, ...n);\n  }\n\n  error() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++) n[s] = arguments[s];\n\n    return this.console.error.bind(this.console, ...n);\n  }\n\n}\n\nconst ca = {\n  fetch: null,\n  mimeType: void 0,\n  nothrow: !1,\n  log: new _l(),\n  useLocalLibraries: !1,\n  CDN: \"https://unpkg.com/@loaders.gl\",\n  worker: !0,\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  reuseWorkers: kn,\n  _nodeWorkers: !1,\n  _workerType: \"\",\n  limit: 0,\n  _limitMB: 0,\n  batchSize: \"auto\",\n  batchDebounceMs: 0,\n  metadata: !1,\n  transforms: []\n},\n      wl = {\n  throws: \"nothrow\",\n  dataType: \"(no longer used)\",\n  uri: \"baseUri\",\n  method: \"fetch.method\",\n  headers: \"fetch.headers\",\n  body: \"fetch.body\",\n  mode: \"fetch.mode\",\n  credentials: \"fetch.credentials\",\n  cache: \"fetch.cache\",\n  redirect: \"fetch.redirect\",\n  referrer: \"fetch.referrer\",\n  referrerPolicy: \"fetch.referrerPolicy\",\n  integrity: \"fetch.integrity\",\n  keepalive: \"fetch.keepalive\",\n  signal: \"fetch.signal\"\n};\n\nfunction ua() {\n  globalThis.loaders = globalThis.loaders || {};\n  const {\n    loaders: e\n  } = globalThis;\n  return e._state = e._state || {}, e._state;\n}\n\nfunction la() {\n  const e = ua();\n  return e.globalOptions = e.globalOptions || { ...ca\n  }, e.globalOptions;\n}\n\nfunction Rl(e, t, n, s) {\n  return n = n || [], n = Array.isArray(n) ? n : [n], Ml(e, n), Il(t, e, s);\n}\n\nfunction Ml(e, t) {\n  ai(e, null, ca, wl, t);\n\n  for (const n of t) {\n    const s = e && e[n.id] || {},\n          r = n.options && n.options[n.id] || {},\n          i = n.deprecatedOptions && n.deprecatedOptions[n.id] || {};\n    ai(s, n.id, r, i, t);\n  }\n}\n\nfunction ai(e, t, n, s, r) {\n  const i = t || \"Top level\",\n        o = t ? `${t}.` : \"\";\n\n  for (const a in e) {\n    const c = !t && We(e[a]),\n          u = a === \"baseUri\" && !t,\n          l = a === \"workerUrl\" && t;\n\n    if (!(a in n) && !u && !l) {\n      if (a in s) oi.warn(`${i} loader option '${o}${a}' no longer supported, use '${s[a]}'`)();else if (!c) {\n        const h = Sl(a, r);\n        oi.warn(`${i} loader option '${o}${a}' not recognized. ${h}`)();\n      }\n    }\n  }\n}\n\nfunction Sl(e, t) {\n  const n = e.toLowerCase();\n  let s = \"\";\n\n  for (const r of t) for (const i in r.options) {\n    if (e === i) return `Did you mean '${r.id}.${i}'?`;\n    const o = i.toLowerCase();\n    (n.startsWith(o) || o.startsWith(n)) && (s = s || `Did you mean '${r.id}.${i}'?`);\n  }\n\n  return s;\n}\n\nfunction Il(e, t, n) {\n  const r = { ...(e.options || {})\n  };\n  return xl(r, n), r.log === null && (r.log = new bl()), ci(r, la()), ci(r, t), r;\n}\n\nfunction ci(e, t) {\n  for (const n in t) if (n in t) {\n    const s = t[n];\n    ti(s) && ti(e[n]) ? e[n] = { ...e[n],\n      ...t[n]\n    } : e[n] = t[n];\n  }\n}\n\nfunction xl(e, t) {\n  t && !(\"baseUri\" in e) && (e.baseUri = t);\n}\n\nfunction Ar(e) {\n  var t;\n  return e ? (Array.isArray(e) && (e = e[0]), Array.isArray((t = e) === null || t === void 0 ? void 0 : t.extensions)) : !1;\n}\n\nfunction ha(e) {\n  var t, n;\n  z(e, \"null loader\"), z(Ar(e), \"invalid loader\");\n  let s;\n  return Array.isArray(e) && (s = e[1], e = e[0], e = { ...e,\n    options: { ...e.options,\n      ...s\n    }\n  }), ((t = e) !== null && t !== void 0 && t.parseTextSync || (n = e) !== null && n !== void 0 && n.parseText) && (e.text = !0), e.text || (e.binary = !0), e;\n}\n\nconst vl = () => {\n  const e = ua();\n  return e.loaderRegistry = e.loaderRegistry || [], e.loaderRegistry;\n};\n\nfunction Ol() {\n  return vl();\n}\n\nconst Fl = new zn({\n  id: \"loaders.gl\"\n}),\n      Dl = /\\.([^.]+)$/;\n\nasync function Ll(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],\n      n = arguments.length > 2 ? arguments[2] : void 0,\n      s = arguments.length > 3 ? arguments[3] : void 0;\n  if (!fa(e)) return null;\n  let r = ui(e, t, { ...n,\n    nothrow: !0\n  }, s);\n  if (r) return r;\n  if (re(e) && (e = await e.slice(0, 10).arrayBuffer(), r = ui(e, t, n, s)), !r && !(n != null && n.nothrow)) throw new Error(da(e));\n  return r;\n}\n\nfunction ui(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],\n      n = arguments.length > 2 ? arguments[2] : void 0,\n      s = arguments.length > 3 ? arguments[3] : void 0;\n  if (!fa(e)) return null;\n  if (t && !Array.isArray(t)) return ha(t);\n  let r = [];\n  t && (r = r.concat(t)), n != null && n.ignoreRegisteredLoaders || r.push(...Ol()), Gl(r);\n  const i = Pl(e, r, n, s);\n  if (!i && !(n != null && n.nothrow)) throw new Error(da(e));\n  return i;\n}\n\nfunction Pl(e, t, n, s) {\n  const r = Kn(e),\n        i = gr(e),\n        o = mr(r) || (s == null ? void 0 : s.url);\n  let a = null,\n      c = \"\";\n\n  if (n != null && n.mimeType && (a = hs(t, n == null ? void 0 : n.mimeType), c = `match forced by supplied MIME type ${n == null ? void 0 : n.mimeType}`), a = a || Nl(t, o), c = c || (a ? `matched url ${o}` : \"\"), a = a || hs(t, i), c = c || (a ? `matched MIME type ${i}` : \"\"), a = a || Hl(t, e), c = c || (a ? `matched initial data ${ma(e)}` : \"\"), n != null && n.fallbackMimeType && (a = a || hs(t, n == null ? void 0 : n.fallbackMimeType), c = c || (a ? `matched fallback MIME type ${i}` : \"\")), c) {\n    var u;\n    Fl.log(1, `selectLoader selected ${(u = a) === null || u === void 0 ? void 0 : u.name}: ${c}.`);\n  }\n\n  return a;\n}\n\nfunction fa(e) {\n  return !(e instanceof Response && e.status === 204);\n}\n\nfunction da(e) {\n  const t = Kn(e),\n        n = gr(e);\n  let s = \"No valid loader found (\";\n  s += t ? `${ta(t)}, ` : \"no url provided, \", s += `MIME type: ${n ? `\"${n}\"` : \"not provided\"}, `;\n  const r = e ? ma(e) : \"\";\n  return s += r ? ` first bytes: \"${r}\"` : \"first bytes: not available\", s += \")\", s;\n}\n\nfunction Gl(e) {\n  for (const t of e) ha(t);\n}\n\nfunction Nl(e, t) {\n  const n = t && Dl.exec(t),\n        s = n && n[1];\n  return s ? Ul(e, s) : null;\n}\n\nfunction Ul(e, t) {\n  t = t.toLowerCase();\n\n  for (const n of e) for (const s of n.extensions) if (s.toLowerCase() === t) return n;\n\n  return null;\n}\n\nfunction hs(e, t) {\n  for (const n of e) if (n.mimeTypes && n.mimeTypes.includes(t) || t === `application/x.${n.id}`) return n;\n\n  return null;\n}\n\nfunction Hl(e, t) {\n  if (!t) return null;\n\n  for (const n of e) if (typeof t == \"string\") {\n    if (Jl(t, n)) return n;\n  } else if (ArrayBuffer.isView(t)) {\n    if (li(t.buffer, t.byteOffset, n)) return n;\n  } else if (t instanceof ArrayBuffer && li(t, 0, n)) return n;\n\n  return null;\n}\n\nfunction Jl(e, t) {\n  return t.testText ? t.testText(e) : (Array.isArray(t.tests) ? t.tests : [t.tests]).some(s => e.startsWith(s));\n}\n\nfunction li(e, t, n) {\n  return (Array.isArray(n.tests) ? n.tests : [n.tests]).some(r => Vl(e, t, n, r));\n}\n\nfunction Vl(e, t, n, s) {\n  if (s instanceof ArrayBuffer) return Lu(s, e, s.byteLength);\n\n  switch (typeof s) {\n    case \"function\":\n      return s(e);\n\n    case \"string\":\n      const r = js(e, t, s.length);\n      return s === r;\n\n    default:\n      return !1;\n  }\n}\n\nfunction ma(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;\n  return typeof e == \"string\" ? e.slice(0, t) : ArrayBuffer.isView(e) ? js(e.buffer, e.byteOffset, t) : e instanceof ArrayBuffer ? js(e, 0, t) : \"\";\n}\n\nfunction js(e, t, n) {\n  if (e.byteLength < t + n) return \"\";\n  const s = new DataView(e);\n  let r = \"\";\n\n  for (let i = 0; i < n; i++) r += String.fromCharCode(s.getUint8(t + i));\n\n  return r;\n}\n\nconst jl = 256 * 1024;\n\nfunction* kl(e, t) {\n  const n = (t == null ? void 0 : t.chunkSize) || jl;\n  let s = 0;\n  const r = new TextEncoder();\n\n  for (; s < e.length;) {\n    const i = Math.min(e.length - s, n),\n          o = e.slice(s, s + i);\n    s += i, yield r.encode(o);\n  }\n}\n\nconst Kl = 256 * 1024;\n\nfunction zl(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  return function* () {\n    const {\n      chunkSize: n = Kl\n    } = t;\n    let s = 0;\n\n    for (; s < e.byteLength;) {\n      const r = Math.min(e.byteLength - s, n),\n            i = new ArrayBuffer(r),\n            o = new Uint8Array(e, s, r);\n      new Uint8Array(i).set(o), s += r, yield i;\n    }\n  }();\n}\n\nconst Wl = 1024 * 1024;\n\nasync function* Xl(e, t) {\n  const n = (t == null ? void 0 : t.chunkSize) || Wl;\n  let s = 0;\n\n  for (; s < e.size;) {\n    const r = s + n,\n          i = await e.slice(s, r).arrayBuffer();\n    s = r, yield i;\n  }\n}\n\nfunction hi(e, t) {\n  return kn ? Ql(e, t) : ql(e);\n}\n\nasync function* Ql(e, t) {\n  const n = e.getReader();\n  let s;\n\n  try {\n    for (;;) {\n      const r = s || n.read();\n      t != null && t._streamReadAhead && (s = n.read());\n      const {\n        done: i,\n        value: o\n      } = await r;\n      if (i) return;\n      yield Zo(o);\n    }\n  } catch {\n    n.releaseLock();\n  }\n}\n\nasync function* ql(e, t) {\n  for await (const n of e) yield Zo(n);\n}\n\nfunction Yl(e, t) {\n  if (typeof e == \"string\") return kl(e, t);\n  if (e instanceof ArrayBuffer) return zl(e, t);\n  if (re(e)) return Xl(e, t);\n  if (na(e)) return hi(e, t);\n  if (se(e)) return hi(e.body, t);\n  throw new Error(\"makeIterator\");\n}\n\nconst ga = \"Cannot convert supplied data type\";\n\nfunction $l(e, t, n) {\n  if (t.text && typeof e == \"string\") return e;\n\n  if (Qu(e) && (e = e.buffer), e instanceof ArrayBuffer) {\n    const s = e;\n    return t.text && !t.binary ? new TextDecoder(\"utf8\").decode(s) : s;\n  }\n\n  if (ArrayBuffer.isView(e)) {\n    if (t.text && !t.binary) return new TextDecoder(\"utf8\").decode(e);\n    let s = e.buffer;\n    const r = e.byteLength || e.length;\n    return (e.byteOffset !== 0 || r !== s.byteLength) && (s = s.slice(e.byteOffset, e.byteOffset + r)), s;\n  }\n\n  throw new Error(ga);\n}\n\nasync function Zl(e, t, n) {\n  const s = e instanceof ArrayBuffer || ArrayBuffer.isView(e);\n  if (typeof e == \"string\" || s) return $l(e, t);\n\n  if (re(e) && (e = await ra(e)), se(e)) {\n    const r = e;\n    return await sl(r), t.binary ? await r.arrayBuffer() : await r.text();\n  }\n\n  if (na(e) && (e = Yl(e, n)), Wu(e) || Xu(e)) return Uu(e);\n  throw new Error(ga);\n}\n\nfunction Aa(e, t) {\n  const n = la(),\n        s = e || n;\n  return typeof s.fetch == \"function\" ? s.fetch : We(s.fetch) ? r => Ge(r, s.fetch) : t != null && t.fetch ? t == null ? void 0 : t.fetch : Ge;\n}\n\nfunction th(e, t, n) {\n  if (n) return n;\n  const s = {\n    fetch: Aa(t, e),\n    ...e\n  };\n\n  if (s.url) {\n    const r = mr(s.url);\n    s.baseUrl = r, s.queryString = el(s.url), s.filename = ta(r), s.baseUrl = ea(r);\n  }\n\n  return Array.isArray(s.loaders) || (s.loaders = null), s;\n}\n\nfunction eh(e, t) {\n  if (e && !Array.isArray(e)) return e;\n  let n;\n\n  if (e && (n = Array.isArray(e) ? e : [e]), t && t.loaders) {\n    const s = Array.isArray(t.loaders) ? t.loaders : [t.loaders];\n    n = n ? [...n, ...s] : s;\n  }\n\n  return n && n.length ? n : void 0;\n}\n\nasync function vn(e, t, n, s) {\n  t && !Array.isArray(t) && !Ar(t) && (s = void 0, n = t, t = void 0), e = await e, n = n || {};\n  const r = Kn(e),\n        o = eh(t, s),\n        a = await Ll(e, o, n);\n  return a ? (n = Rl(n, a, o, r), s = th({\n    url: r,\n    _parse: vn,\n    loaders: o\n  }, n, s || null), await nh(a, e, n, s)) : null;\n}\n\nasync function nh(e, t, n, s) {\n  if (Tu(e), n = hu(e.options, n), se(t)) {\n    const i = t,\n          {\n      ok: o,\n      redirected: a,\n      status: c,\n      statusText: u,\n      type: l,\n      url: h\n    } = i,\n          f = Object.fromEntries(i.headers.entries());\n    s.response = {\n      headers: f,\n      ok: o,\n      redirected: a,\n      status: c,\n      statusText: u,\n      type: l,\n      url: h\n    };\n  }\n\n  t = await Zl(t, e, n);\n  const r = e;\n  if (r.parseTextSync && typeof t == \"string\") return r.parseTextSync(t, n, s);\n  if (xu(e, n)) return await vu(e, t, n, s, vn);\n  if (r.parseText && typeof t == \"string\") return await r.parseText(t, n, s);\n  if (r.parse) return await r.parse(t, n, s);\n  throw Jt(!r.parseSync), new Error(`${e.id} loader - no parser found and worker is disabled`);\n}\n\nfunction sh(e) {\n  switch (e.constructor) {\n    case Int8Array:\n      return \"int8\";\n\n    case Uint8Array:\n    case Uint8ClampedArray:\n      return \"uint8\";\n\n    case Int16Array:\n      return \"int16\";\n\n    case Uint16Array:\n      return \"uint16\";\n\n    case Int32Array:\n      return \"int32\";\n\n    case Uint32Array:\n      return \"uint32\";\n\n    case Float32Array:\n      return \"float32\";\n\n    case Float64Array:\n      return \"float64\";\n\n    default:\n      return \"null\";\n  }\n}\n\nfunction rh(e) {\n  let t = 1 / 0,\n      n = 1 / 0,\n      s = 1 / 0,\n      r = -1 / 0,\n      i = -1 / 0,\n      o = -1 / 0;\n  const a = e.POSITION ? e.POSITION.value : [],\n        c = a && a.length;\n\n  for (let u = 0; u < c; u += 3) {\n    const l = a[u],\n          h = a[u + 1],\n          f = a[u + 2];\n    t = l < t ? l : t, n = h < n ? h : n, s = f < s ? f : s, r = l > r ? l : r, i = h > i ? h : i, o = f > o ? f : o;\n  }\n\n  return [[t, n, s], [r, i, o]];\n}\n\nfunction ih(e, t, n) {\n  const s = sh(t.value),\n        r = n || oh(t);\n  return {\n    name: e,\n    type: {\n      type: \"fixed-size-list\",\n      listSize: t.size,\n      children: [{\n        name: \"value\",\n        type: s\n      }]\n    },\n    nullable: !1,\n    metadata: r\n  };\n}\n\nfunction oh(e) {\n  const t = {};\n  return \"byteOffset\" in e && (t.byteOffset = e.byteOffset.toString(10)), \"byteStride\" in e && (t.byteStride = e.byteStride.toString(10)), \"normalized\" in e && (t.normalized = e.normalized.toString()), t;\n}\n\nasync function Ae(e, t, n, s) {\n  let r, i;\n  !Array.isArray(t) && !Ar(t) ? (r = [], i = t) : (r = t, i = n);\n  const o = Aa(i);\n  let a = e;\n  return typeof e == \"string\" && (a = await o(e)), re(e) && (a = await o(e)), Array.isArray(r) ? await vn(a, r, i) : await vn(a, r, i);\n}\n\nconst ah = 1 / Math.PI * 180,\n      ch = 1 / 180 * Math.PI,\n      uh = {\n  EPSILON: 1e-12,\n  debug: !1,\n  precision: 4,\n  printTypes: !1,\n  printDegrees: !1,\n  printRowMajor: !0,\n  _cartographicRadians: !1\n};\nglobalThis.mathgl = globalThis.mathgl || {\n  config: { ...uh\n  }\n};\nconst et = globalThis.mathgl.config;\n\nfunction lh(e, {\n  precision: t = et.precision\n} = {}) {\n  return e = gh(e), \"\".concat(parseFloat(e.toPrecision(t)));\n}\n\nfunction ee(e) {\n  return Array.isArray(e) || ArrayBuffer.isView(e) && !(e instanceof DataView);\n}\n\nfunction hh(e) {\n  return dh(e);\n}\n\nfunction fh(e) {\n  return Rt(e);\n}\n\nfunction dh(e, t) {\n  return pr(e, n => n * ch, t);\n}\n\nfunction Rt(e, t) {\n  return pr(e, n => n * ah, t);\n}\n\nfunction mh(e, t, n) {\n  return pr(e, s => Math.max(t, Math.min(n, s)));\n}\n\nfunction Kt(e, t, n) {\n  const s = et.EPSILON;\n  n && (et.EPSILON = n);\n\n  try {\n    if (e === t) return !0;\n\n    if (ee(e) && ee(t)) {\n      if (e.length !== t.length) return !1;\n\n      for (let r = 0; r < e.length; ++r) if (!Kt(e[r], t[r])) return !1;\n\n      return !0;\n    }\n\n    return e && e.equals ? e.equals(t) : t && t.equals ? t.equals(e) : typeof e == \"number\" && typeof t == \"number\" ? Math.abs(e - t) <= et.EPSILON * Math.max(1, Math.abs(e), Math.abs(t)) : !1;\n  } finally {\n    et.EPSILON = s;\n  }\n}\n\nfunction gh(e) {\n  return Math.round(e / et.EPSILON) * et.EPSILON;\n}\n\nfunction Ah(e) {\n  return e.clone ? e.clone() : new Array(e.length);\n}\n\nfunction pr(e, t, n) {\n  if (ee(e)) {\n    const s = e;\n    n = n || Ah(s);\n\n    for (let r = 0; r < n.length && r < s.length; ++r) {\n      const i = typeof e == \"number\" ? e : e[r];\n      n[r] = t(i, r, n);\n    }\n\n    return n;\n  }\n\n  return t(e);\n}\n\nfunction ph(e) {\n  function t() {\n    var n = Reflect.construct(e, Array.from(arguments));\n    return Object.setPrototypeOf(n, Object.getPrototypeOf(this)), n;\n  }\n\n  return t.prototype = Object.create(e.prototype, {\n    constructor: {\n      value: e,\n      enumerable: !1,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e, t;\n}\n\nclass yr extends ph(Array) {\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  fromArray(t, n = 0) {\n    for (let s = 0; s < this.ELEMENTS; ++s) this[s] = t[s + n];\n\n    return this.check();\n  }\n\n  toArray(t = [], n = 0) {\n    for (let s = 0; s < this.ELEMENTS; ++s) t[n + s] = this[s];\n\n    return t;\n  }\n\n  toObject(t) {\n    return t;\n  }\n\n  from(t) {\n    return Array.isArray(t) ? this.copy(t) : this.fromObject(t);\n  }\n\n  to(t) {\n    return t === this ? this : ee(t) ? this.toArray(t) : this.toObject(t);\n  }\n\n  toTarget(t) {\n    return t ? this.to(t) : this;\n  }\n\n  toFloat32Array() {\n    return new Float32Array(this);\n  }\n\n  toString() {\n    return this.formatString(et);\n  }\n\n  formatString(t) {\n    let n = \"\";\n\n    for (let s = 0; s < this.ELEMENTS; ++s) n += (s > 0 ? \", \" : \"\") + lh(this[s], t);\n\n    return \"\".concat(t.printTypes ? this.constructor.name : \"\", \"[\").concat(n, \"]\");\n  }\n\n  equals(t) {\n    if (!t || this.length !== t.length) return !1;\n\n    for (let n = 0; n < this.ELEMENTS; ++n) if (!Kt(this[n], t[n])) return !1;\n\n    return !0;\n  }\n\n  exactEquals(t) {\n    if (!t || this.length !== t.length) return !1;\n\n    for (let n = 0; n < this.ELEMENTS; ++n) if (this[n] !== t[n]) return !1;\n\n    return !0;\n  }\n\n  negate() {\n    for (let t = 0; t < this.ELEMENTS; ++t) this[t] = -this[t];\n\n    return this.check();\n  }\n\n  lerp(t, n, s) {\n    if (s === void 0) return this.lerp(this, t, n);\n\n    for (let r = 0; r < this.ELEMENTS; ++r) {\n      const i = t[r],\n            o = typeof n == \"number\" ? n : n[r];\n      this[r] = i + s * (o - i);\n    }\n\n    return this.check();\n  }\n\n  min(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n) this[n] = Math.min(t[n], this[n]);\n\n    return this.check();\n  }\n\n  max(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n) this[n] = Math.max(t[n], this[n]);\n\n    return this.check();\n  }\n\n  clamp(t, n) {\n    for (let s = 0; s < this.ELEMENTS; ++s) this[s] = Math.min(Math.max(this[s], t[s]), n[s]);\n\n    return this.check();\n  }\n\n  add(...t) {\n    for (const n of t) for (let s = 0; s < this.ELEMENTS; ++s) this[s] += n[s];\n\n    return this.check();\n  }\n\n  subtract(...t) {\n    for (const n of t) for (let s = 0; s < this.ELEMENTS; ++s) this[s] -= n[s];\n\n    return this.check();\n  }\n\n  scale(t) {\n    if (typeof t == \"number\") for (let n = 0; n < this.ELEMENTS; ++n) this[n] *= t;else for (let n = 0; n < this.ELEMENTS && n < t.length; ++n) this[n] *= t[n];\n    return this.check();\n  }\n\n  multiplyByScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n) this[n] *= t;\n\n    return this.check();\n  }\n\n  check() {\n    if (et.debug && !this.validate()) throw new Error(\"math.gl: \".concat(this.constructor.name, \" some fields set to invalid numbers'\"));\n    return this;\n  }\n\n  validate() {\n    let t = this.length === this.ELEMENTS;\n\n    for (let n = 0; n < this.ELEMENTS; ++n) t = t && Number.isFinite(this[n]);\n\n    return t;\n  }\n\n  sub(t) {\n    return this.subtract(t);\n  }\n\n  setScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n) this[n] = t;\n\n    return this.check();\n  }\n\n  addScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n) this[n] += t;\n\n    return this.check();\n  }\n\n  subScalar(t) {\n    return this.addScalar(-t);\n  }\n\n  multiplyScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n) this[n] *= t;\n\n    return this.check();\n  }\n\n  divideScalar(t) {\n    return this.multiplyByScalar(1 / t);\n  }\n\n  clampScalar(t, n) {\n    for (let s = 0; s < this.ELEMENTS; ++s) this[s] = Math.min(Math.max(this[s], t), n);\n\n    return this.check();\n  }\n\n  get elements() {\n    return this;\n  }\n\n}\n\nfunction yh(e, t) {\n  if (e.length !== t) return !1;\n\n  for (let n = 0; n < e.length; ++n) if (!Number.isFinite(e[n])) return !1;\n\n  return !0;\n}\n\nfunction U(e) {\n  if (!Number.isFinite(e)) throw new Error(\"Invalid number \".concat(JSON.stringify(e)));\n  return e;\n}\n\nfunction Oe(e, t, n = \"\") {\n  if (et.debug && !yh(e, t)) throw new Error(\"math.gl: \".concat(n, \" some fields set to invalid numbers'\"));\n  return e;\n}\n\nfunction j(e, t) {\n  if (!e) throw new Error(\"math.gl assertion \".concat(t));\n}\n\nclass Br extends yr {\n  get x() {\n    return this[0];\n  }\n\n  set x(t) {\n    this[0] = U(t);\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  set y(t) {\n    this[1] = U(t);\n  }\n\n  len() {\n    return Math.sqrt(this.lengthSquared());\n  }\n\n  magnitude() {\n    return this.len();\n  }\n\n  lengthSquared() {\n    let t = 0;\n\n    for (let n = 0; n < this.ELEMENTS; ++n) t += this[n] * this[n];\n\n    return t;\n  }\n\n  magnitudeSquared() {\n    return this.lengthSquared();\n  }\n\n  distance(t) {\n    return Math.sqrt(this.distanceSquared(t));\n  }\n\n  distanceSquared(t) {\n    let n = 0;\n\n    for (let s = 0; s < this.ELEMENTS; ++s) {\n      const r = this[s] - t[s];\n      n += r * r;\n    }\n\n    return U(n);\n  }\n\n  dot(t) {\n    let n = 0;\n\n    for (let s = 0; s < this.ELEMENTS; ++s) n += this[s] * t[s];\n\n    return U(n);\n  }\n\n  normalize() {\n    const t = this.magnitude();\n    if (t !== 0) for (let n = 0; n < this.ELEMENTS; ++n) this[n] /= t;\n    return this.check();\n  }\n\n  multiply(...t) {\n    for (const n of t) for (let s = 0; s < this.ELEMENTS; ++s) this[s] *= n[s];\n\n    return this.check();\n  }\n\n  divide(...t) {\n    for (const n of t) for (let s = 0; s < this.ELEMENTS; ++s) this[s] /= n[s];\n\n    return this.check();\n  }\n\n  lengthSq() {\n    return this.lengthSquared();\n  }\n\n  distanceTo(t) {\n    return this.distance(t);\n  }\n\n  distanceToSquared(t) {\n    return this.distanceSquared(t);\n  }\n\n  getComponent(t) {\n    return j(t >= 0 && t < this.ELEMENTS, \"index is out of range\"), U(this[t]);\n  }\n\n  setComponent(t, n) {\n    return j(t >= 0 && t < this.ELEMENTS, \"index is out of range\"), this[t] = n, this.check();\n  }\n\n  addVectors(t, n) {\n    return this.copy(t).add(n);\n  }\n\n  subVectors(t, n) {\n    return this.copy(t).subtract(n);\n  }\n\n  multiplyVectors(t, n) {\n    return this.copy(t).multiply(n);\n  }\n\n  addScaledVector(t, n) {\n    return this.add(new this.constructor(t).multiplyScalar(n));\n  }\n\n}\n\nconst Fe = 1e-6;\nlet It = typeof Float32Array < \"u\" ? Float32Array : Array;\n\nfunction Bh() {\n  const e = new It(2);\n  return It != Float32Array && (e[0] = 0, e[1] = 0), e;\n}\n\nfunction Ch(e, t, n) {\n  const s = t[0],\n        r = t[1];\n  return e[0] = n[0] * s + n[2] * r, e[1] = n[1] * s + n[3] * r, e;\n}\n\nfunction Eh(e, t, n) {\n  const s = t[0],\n        r = t[1];\n  return e[0] = n[0] * s + n[2] * r + n[4], e[1] = n[1] * s + n[3] * r + n[5], e;\n}\n\nfunction pa(e, t, n) {\n  const s = t[0],\n        r = t[1];\n  return e[0] = n[0] * s + n[3] * r + n[6], e[1] = n[1] * s + n[4] * r + n[7], e;\n}\n\nfunction ya(e, t, n) {\n  const s = t[0],\n        r = t[1];\n  return e[0] = n[0] * s + n[4] * r + n[12], e[1] = n[1] * s + n[5] * r + n[13], e;\n}\n\n(function () {\n  const e = Bh();\n  return function (t, n, s, r, i, o) {\n    let a, c;\n\n    for (n || (n = 2), s || (s = 0), r ? c = Math.min(r * n + s, t.length) : c = t.length, a = s; a < c; a += n) e[0] = t[a], e[1] = t[a + 1], i(e, e, o), t[a] = e[0], t[a + 1] = e[1];\n\n    return t;\n  };\n})();\n\nfunction Ba(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = n[3] * s + n[7] * r || 1;\n  return e[0] = (n[0] * s + n[4] * r) / i, e[1] = (n[1] * s + n[5] * r) / i, e;\n}\n\nfunction Ca(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = n[3] * s + n[7] * r + n[11] * i || 1;\n  return e[0] = (n[0] * s + n[4] * r + n[8] * i) / o, e[1] = (n[1] * s + n[5] * r + n[9] * i) / o, e[2] = (n[2] * s + n[6] * r + n[10] * i) / o, e;\n}\n\nfunction Th(e, t, n) {\n  const s = t[0],\n        r = t[1];\n  return e[0] = n[0] * s + n[2] * r, e[1] = n[1] * s + n[3] * r, e[2] = t[2], e;\n}\n\nfunction bh(e, t, n) {\n  const s = t[0],\n        r = t[1];\n  return e[0] = n[0] * s + n[2] * r, e[1] = n[1] * s + n[3] * r, e[2] = t[2], e[3] = t[3], e;\n}\n\nfunction Ea(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2];\n  return e[0] = n[0] * s + n[3] * r + n[6] * i, e[1] = n[1] * s + n[4] * r + n[7] * i, e[2] = n[2] * s + n[5] * r + n[8] * i, e[3] = t[3], e;\n}\n\nclass Wn extends Br {\n  constructor(t = 0, n = 0) {\n    super(2), ee(t) && arguments.length === 1 ? this.copy(t) : (et.debug && (U(t), U(n)), this[0] = t, this[1] = n);\n  }\n\n  set(t, n) {\n    return this[0] = t, this[1] = n, this.check();\n  }\n\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this.check();\n  }\n\n  fromObject(t) {\n    return et.debug && (U(t.x), U(t.y)), this[0] = t.x, this[1] = t.y, this.check();\n  }\n\n  toObject(t) {\n    return t.x = this[0], t.y = this[1], t;\n  }\n\n  get ELEMENTS() {\n    return 2;\n  }\n\n  horizontalAngle() {\n    return Math.atan2(this.y, this.x);\n  }\n\n  verticalAngle() {\n    return Math.atan2(this.x, this.y);\n  }\n\n  transform(t) {\n    return this.transformAsPoint(t);\n  }\n\n  transformAsPoint(t) {\n    return ya(this, this, t), this.check();\n  }\n\n  transformAsVector(t) {\n    return Ba(this, this, t), this.check();\n  }\n\n  transformByMatrix3(t) {\n    return pa(this, this, t), this.check();\n  }\n\n  transformByMatrix2x3(t) {\n    return Eh(this, this, t), this.check();\n  }\n\n  transformByMatrix2(t) {\n    return Ch(this, this, t), this.check();\n  }\n\n}\n\nfunction Ta() {\n  const e = new It(3);\n  return It != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e;\n}\n\nfunction ba(e) {\n  const t = e[0],\n        n = e[1],\n        s = e[2];\n  return Math.sqrt(t * t + n * n + s * s);\n}\n\nfunction fi(e, t, n) {\n  const s = new It(3);\n  return s[0] = e, s[1] = t, s[2] = n, s;\n}\n\nfunction _h(e, t) {\n  const n = t[0],\n        s = t[1],\n        r = t[2];\n  let i = n * n + s * s + r * r;\n  return i > 0 && (i = 1 / Math.sqrt(i)), e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i, e;\n}\n\nfunction Cr(e, t) {\n  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];\n}\n\nfunction Tn(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = n[0],\n        a = n[1],\n        c = n[2];\n  return e[0] = r * c - i * a, e[1] = i * o - s * c, e[2] = s * a - r * o, e;\n}\n\nfunction Er(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2];\n  let o = n[3] * s + n[7] * r + n[11] * i + n[15];\n  return o = o || 1, e[0] = (n[0] * s + n[4] * r + n[8] * i + n[12]) / o, e[1] = (n[1] * s + n[5] * r + n[9] * i + n[13]) / o, e[2] = (n[2] * s + n[6] * r + n[10] * i + n[14]) / o, e;\n}\n\nfunction _a(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2];\n  return e[0] = s * n[0] + r * n[3] + i * n[6], e[1] = s * n[1] + r * n[4] + i * n[7], e[2] = s * n[2] + r * n[5] + i * n[8], e;\n}\n\nfunction wa(e, t, n) {\n  const s = n[0],\n        r = n[1],\n        i = n[2],\n        o = n[3],\n        a = t[0],\n        c = t[1],\n        u = t[2];\n  let l = r * u - i * c,\n      h = i * a - s * u,\n      f = s * c - r * a,\n      d = r * f - i * h,\n      m = i * l - s * f,\n      g = s * h - r * l;\n  const y = o * 2;\n  return l *= y, h *= y, f *= y, d *= 2, m *= 2, g *= 2, e[0] = a + l + d, e[1] = c + h + m, e[2] = u + f + g, e;\n}\n\nfunction wh(e, t, n, s) {\n  const r = [],\n        i = [];\n  return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], i[0] = r[0], i[1] = r[1] * Math.cos(s) - r[2] * Math.sin(s), i[2] = r[1] * Math.sin(s) + r[2] * Math.cos(s), e[0] = i[0] + n[0], e[1] = i[1] + n[1], e[2] = i[2] + n[2], e;\n}\n\nfunction Rh(e, t, n, s) {\n  const r = [],\n        i = [];\n  return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], i[0] = r[2] * Math.sin(s) + r[0] * Math.cos(s), i[1] = r[1], i[2] = r[2] * Math.cos(s) - r[0] * Math.sin(s), e[0] = i[0] + n[0], e[1] = i[1] + n[1], e[2] = i[2] + n[2], e;\n}\n\nfunction Mh(e, t, n, s) {\n  const r = [],\n        i = [];\n  return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], i[0] = r[0] * Math.cos(s) - r[1] * Math.sin(s), i[1] = r[0] * Math.sin(s) + r[1] * Math.cos(s), i[2] = r[2], e[0] = i[0] + n[0], e[1] = i[1] + n[1], e[2] = i[2] + n[2], e;\n}\n\nfunction Sh(e, t) {\n  const n = e[0],\n        s = e[1],\n        r = e[2],\n        i = t[0],\n        o = t[1],\n        a = t[2],\n        c = Math.sqrt((n * n + s * s + r * r) * (i * i + o * o + a * a)),\n        u = c && Cr(e, t) / c;\n  return Math.acos(Math.min(Math.max(u, -1), 1));\n}\n\nconst Ih = ba;\n\n(function () {\n  const e = Ta();\n  return function (t, n, s, r, i, o) {\n    let a, c;\n\n    for (n || (n = 3), s || (s = 0), r ? c = Math.min(r * n + s, t.length) : c = t.length, a = s; a < c; a += n) e[0] = t[a], e[1] = t[a + 1], e[2] = t[a + 2], i(e, e, o), t[a] = e[0], t[a + 1] = e[1], t[a + 2] = e[2];\n\n    return t;\n  };\n})();\n\nconst fs = [0, 0, 0];\nlet tn;\n\nclass A extends Br {\n  static get ZERO() {\n    return tn || (tn = new A(0, 0, 0), Object.freeze(tn)), tn;\n  }\n\n  constructor(t = 0, n = 0, s = 0) {\n    super(-0, -0, -0), arguments.length === 1 && ee(t) ? this.copy(t) : (et.debug && (U(t), U(n), U(s)), this[0] = t, this[1] = n, this[2] = s);\n  }\n\n  set(t, n, s) {\n    return this[0] = t, this[1] = n, this[2] = s, this.check();\n  }\n\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this.check();\n  }\n\n  fromObject(t) {\n    return et.debug && (U(t.x), U(t.y), U(t.z)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this.check();\n  }\n\n  toObject(t) {\n    return t.x = this[0], t.y = this[1], t.z = this[2], t;\n  }\n\n  get ELEMENTS() {\n    return 3;\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set z(t) {\n    this[2] = U(t);\n  }\n\n  angle(t) {\n    return Sh(this, t);\n  }\n\n  cross(t) {\n    return Tn(this, this, t), this.check();\n  }\n\n  rotateX({\n    radians: t,\n    origin: n = fs\n  }) {\n    return wh(this, this, n, t), this.check();\n  }\n\n  rotateY({\n    radians: t,\n    origin: n = fs\n  }) {\n    return Rh(this, this, n, t), this.check();\n  }\n\n  rotateZ({\n    radians: t,\n    origin: n = fs\n  }) {\n    return Mh(this, this, n, t), this.check();\n  }\n\n  transform(t) {\n    return this.transformAsPoint(t);\n  }\n\n  transformAsPoint(t) {\n    return Er(this, this, t), this.check();\n  }\n\n  transformAsVector(t) {\n    return Ca(this, this, t), this.check();\n  }\n\n  transformByMatrix3(t) {\n    return _a(this, this, t), this.check();\n  }\n\n  transformByMatrix2(t) {\n    return Th(this, this, t), this.check();\n  }\n\n  transformByQuaternion(t) {\n    return wa(this, this, t), this.check();\n  }\n\n}\n\nlet en;\n\nclass Tr extends Br {\n  static get ZERO() {\n    return en || (en = new Tr(0, 0, 0, 0), Object.freeze(en)), en;\n  }\n\n  constructor(t = 0, n = 0, s = 0, r = 0) {\n    super(-0, -0, -0, -0), ee(t) && arguments.length === 1 ? this.copy(t) : (et.debug && (U(t), U(n), U(s), U(r)), this[0] = t, this[1] = n, this[2] = s, this[3] = r);\n  }\n\n  set(t, n, s, r) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this.check();\n  }\n\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this.check();\n  }\n\n  fromObject(t) {\n    return et.debug && (U(t.x), U(t.y), U(t.z), U(t.w)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this[3] = t.w, this;\n  }\n\n  toObject(t) {\n    return t.x = this[0], t.y = this[1], t.z = this[2], t.w = this[3], t;\n  }\n\n  get ELEMENTS() {\n    return 4;\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set z(t) {\n    this[2] = U(t);\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set w(t) {\n    this[3] = U(t);\n  }\n\n  transform(t) {\n    return Er(this, this, t), this.check();\n  }\n\n  transformByMatrix3(t) {\n    return Ea(this, this, t), this.check();\n  }\n\n  transformByMatrix2(t) {\n    return bh(this, this, t), this.check();\n  }\n\n  transformByQuaternion(t) {\n    return wa(this, this, t), this.check();\n  }\n\n  applyMatrix4(t) {\n    return t.transform(this, this), this;\n  }\n\n}\n\nclass Ra extends yr {\n  toString() {\n    let t = \"[\";\n\n    if (et.printRowMajor) {\n      t += \"row-major:\";\n\n      for (let n = 0; n < this.RANK; ++n) for (let s = 0; s < this.RANK; ++s) t += \" \".concat(this[s * this.RANK + n]);\n    } else {\n      t += \"column-major:\";\n\n      for (let n = 0; n < this.ELEMENTS; ++n) t += \" \".concat(this[n]);\n    }\n\n    return t += \"]\", t;\n  }\n\n  getElementIndex(t, n) {\n    return n * this.RANK + t;\n  }\n\n  getElement(t, n) {\n    return this[n * this.RANK + t];\n  }\n\n  setElement(t, n, s) {\n    return this[n * this.RANK + t] = U(s), this;\n  }\n\n  getColumn(t, n = new Array(this.RANK).fill(-0)) {\n    const s = t * this.RANK;\n\n    for (let r = 0; r < this.RANK; ++r) n[r] = this[s + r];\n\n    return n;\n  }\n\n  setColumn(t, n) {\n    const s = t * this.RANK;\n\n    for (let r = 0; r < this.RANK; ++r) this[s + r] = n[r];\n\n    return this;\n  }\n\n}\n\nfunction xh() {\n  const e = new It(9);\n  return It != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[0] = 1, e[4] = 1, e[8] = 1, e;\n}\n\nfunction vh(e, t) {\n  if (e === t) {\n    const n = t[1],\n          s = t[2],\n          r = t[5];\n    e[1] = t[3], e[2] = t[6], e[3] = n, e[5] = t[7], e[6] = s, e[7] = r;\n  } else e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8];\n\n  return e;\n}\n\nfunction Oh(e, t) {\n  const n = t[0],\n        s = t[1],\n        r = t[2],\n        i = t[3],\n        o = t[4],\n        a = t[5],\n        c = t[6],\n        u = t[7],\n        l = t[8],\n        h = l * o - a * u,\n        f = -l * i + a * c,\n        d = u * i - o * c;\n  let m = n * h + s * f + r * d;\n  return m ? (m = 1 / m, e[0] = h * m, e[1] = (-l * s + r * u) * m, e[2] = (a * s - r * o) * m, e[3] = f * m, e[4] = (l * n - r * c) * m, e[5] = (-a * n + r * i) * m, e[6] = d * m, e[7] = (-u * n + s * c) * m, e[8] = (o * n - s * i) * m, e) : null;\n}\n\nfunction Fh(e) {\n  const t = e[0],\n        n = e[1],\n        s = e[2],\n        r = e[3],\n        i = e[4],\n        o = e[5],\n        a = e[6],\n        c = e[7],\n        u = e[8];\n  return t * (u * i - o * c) + n * (-u * r + o * a) + s * (c * r - i * a);\n}\n\nfunction di(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = t[3],\n        a = t[4],\n        c = t[5],\n        u = t[6],\n        l = t[7],\n        h = t[8],\n        f = n[0],\n        d = n[1],\n        m = n[2],\n        g = n[3],\n        y = n[4],\n        E = n[5],\n        R = n[6],\n        B = n[7],\n        C = n[8];\n  return e[0] = f * s + d * o + m * u, e[1] = f * r + d * a + m * l, e[2] = f * i + d * c + m * h, e[3] = g * s + y * o + E * u, e[4] = g * r + y * a + E * l, e[5] = g * i + y * c + E * h, e[6] = R * s + B * o + C * u, e[7] = R * r + B * a + C * l, e[8] = R * i + B * c + C * h, e;\n}\n\nfunction Dh(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = t[3],\n        a = t[4],\n        c = t[5],\n        u = t[6],\n        l = t[7],\n        h = t[8],\n        f = n[0],\n        d = n[1];\n  return e[0] = s, e[1] = r, e[2] = i, e[3] = o, e[4] = a, e[5] = c, e[6] = f * s + d * o + u, e[7] = f * r + d * a + l, e[8] = f * i + d * c + h, e;\n}\n\nfunction Lh(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = t[3],\n        a = t[4],\n        c = t[5],\n        u = t[6],\n        l = t[7],\n        h = t[8],\n        f = Math.sin(n),\n        d = Math.cos(n);\n  return e[0] = d * s + f * o, e[1] = d * r + f * a, e[2] = d * i + f * c, e[3] = d * o - f * s, e[4] = d * a - f * r, e[5] = d * c - f * i, e[6] = u, e[7] = l, e[8] = h, e;\n}\n\nfunction mi(e, t, n) {\n  const s = n[0],\n        r = n[1];\n  return e[0] = s * t[0], e[1] = s * t[1], e[2] = s * t[2], e[3] = r * t[3], e[4] = r * t[4], e[5] = r * t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e;\n}\n\nfunction Ph(e, t) {\n  const n = t[0],\n        s = t[1],\n        r = t[2],\n        i = t[3],\n        o = n + n,\n        a = s + s,\n        c = r + r,\n        u = n * o,\n        l = s * o,\n        h = s * a,\n        f = r * o,\n        d = r * a,\n        m = r * c,\n        g = i * o,\n        y = i * a,\n        E = i * c;\n  return e[0] = 1 - h - m, e[3] = l - E, e[6] = f + y, e[1] = l + E, e[4] = 1 - u - m, e[7] = d - g, e[2] = f - y, e[5] = d + g, e[8] = 1 - u - h, e;\n}\n\nvar ks;\n\n(function (e) {\n  e[e.COL0ROW0 = 0] = \"COL0ROW0\", e[e.COL0ROW1 = 1] = \"COL0ROW1\", e[e.COL0ROW2 = 2] = \"COL0ROW2\", e[e.COL1ROW0 = 3] = \"COL1ROW0\", e[e.COL1ROW1 = 4] = \"COL1ROW1\", e[e.COL1ROW2 = 5] = \"COL1ROW2\", e[e.COL2ROW0 = 6] = \"COL2ROW0\", e[e.COL2ROW1 = 7] = \"COL2ROW1\", e[e.COL2ROW2 = 8] = \"COL2ROW2\";\n})(ks || (ks = {}));\n\nconst Gh = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);\n\nclass X extends Ra {\n  static get IDENTITY() {\n    return Uh();\n  }\n\n  static get ZERO() {\n    return Nh();\n  }\n\n  get ELEMENTS() {\n    return 9;\n  }\n\n  get RANK() {\n    return 3;\n  }\n\n  get INDICES() {\n    return ks;\n  }\n\n  constructor(t, ...n) {\n    super(-0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(t) ? this.copy(t) : n.length > 0 ? this.copy([t, ...n]) : this.identity();\n  }\n\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this[4] = t[4], this[5] = t[5], this[6] = t[6], this[7] = t[7], this[8] = t[8], this.check();\n  }\n\n  identity() {\n    return this.copy(Gh);\n  }\n\n  fromObject(t) {\n    return this.check();\n  }\n\n  fromQuaternion(t) {\n    return Ph(this, t), this.check();\n  }\n\n  set(t, n, s, r, i, o, a, c, u) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this[4] = i, this[5] = o, this[6] = a, this[7] = c, this[8] = u, this.check();\n  }\n\n  setRowMajor(t, n, s, r, i, o, a, c, u) {\n    return this[0] = t, this[1] = r, this[2] = a, this[3] = n, this[4] = i, this[5] = c, this[6] = s, this[7] = o, this[8] = u, this.check();\n  }\n\n  determinant() {\n    return Fh(this);\n  }\n\n  transpose() {\n    return vh(this, this), this.check();\n  }\n\n  invert() {\n    return Oh(this, this), this.check();\n  }\n\n  multiplyLeft(t) {\n    return di(this, t, this), this.check();\n  }\n\n  multiplyRight(t) {\n    return di(this, this, t), this.check();\n  }\n\n  rotate(t) {\n    return Lh(this, this, t), this.check();\n  }\n\n  scale(t) {\n    return Array.isArray(t) ? mi(this, this, t) : mi(this, this, [t, t]), this.check();\n  }\n\n  translate(t) {\n    return Dh(this, this, t), this.check();\n  }\n\n  transform(t, n) {\n    let s;\n\n    switch (t.length) {\n      case 2:\n        s = pa(n || [-0, -0], t, this);\n        break;\n\n      case 3:\n        s = _a(n || [-0, -0, -0], t, this);\n        break;\n\n      case 4:\n        s = Ea(n || [-0, -0, -0, -0], t, this);\n        break;\n\n      default:\n        throw new Error(\"Illegal vector\");\n    }\n\n    return Oe(s, t.length), s;\n  }\n\n  transformVector(t, n) {\n    return this.transform(t, n);\n  }\n\n  transformVector2(t, n) {\n    return this.transform(t, n);\n  }\n\n  transformVector3(t, n) {\n    return this.transform(t, n);\n  }\n\n}\n\nlet nn,\n    sn = null;\n\nfunction Nh() {\n  return nn || (nn = new X([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(nn)), nn;\n}\n\nfunction Uh() {\n  return sn || (sn = new X(), Object.freeze(sn)), sn;\n}\n\nfunction Hh(e) {\n  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;\n}\n\nfunction Jh(e, t) {\n  if (e === t) {\n    const n = t[1],\n          s = t[2],\n          r = t[3],\n          i = t[6],\n          o = t[7],\n          a = t[11];\n    e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = n, e[6] = t[9], e[7] = t[13], e[8] = s, e[9] = i, e[11] = t[14], e[12] = r, e[13] = o, e[14] = a;\n  } else e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];\n\n  return e;\n}\n\nfunction Vh(e, t) {\n  const n = t[0],\n        s = t[1],\n        r = t[2],\n        i = t[3],\n        o = t[4],\n        a = t[5],\n        c = t[6],\n        u = t[7],\n        l = t[8],\n        h = t[9],\n        f = t[10],\n        d = t[11],\n        m = t[12],\n        g = t[13],\n        y = t[14],\n        E = t[15],\n        R = n * a - s * o,\n        B = n * c - r * o,\n        C = n * u - i * o,\n        M = s * c - r * a,\n        b = s * u - i * a,\n        O = r * u - i * c,\n        F = l * g - h * m,\n        v = l * y - f * m,\n        L = l * E - d * m,\n        k = h * y - f * g,\n        q = h * E - d * g,\n        Y = f * E - d * y;\n  let P = R * Y - B * q + C * k + M * L - b * v + O * F;\n  return P ? (P = 1 / P, e[0] = (a * Y - c * q + u * k) * P, e[1] = (r * q - s * Y - i * k) * P, e[2] = (g * O - y * b + E * M) * P, e[3] = (f * b - h * O - d * M) * P, e[4] = (c * L - o * Y - u * v) * P, e[5] = (n * Y - r * L + i * v) * P, e[6] = (y * C - m * O - E * B) * P, e[7] = (l * O - f * C + d * B) * P, e[8] = (o * q - a * L + u * F) * P, e[9] = (s * L - n * q - i * F) * P, e[10] = (m * b - g * C + E * R) * P, e[11] = (h * C - l * b - d * R) * P, e[12] = (a * v - o * k - c * F) * P, e[13] = (n * k - s * v + r * F) * P, e[14] = (g * B - m * M - y * R) * P, e[15] = (l * M - h * B + f * R) * P, e) : null;\n}\n\nfunction jh(e) {\n  const t = e[0],\n        n = e[1],\n        s = e[2],\n        r = e[3],\n        i = e[4],\n        o = e[5],\n        a = e[6],\n        c = e[7],\n        u = e[8],\n        l = e[9],\n        h = e[10],\n        f = e[11],\n        d = e[12],\n        m = e[13],\n        g = e[14],\n        y = e[15],\n        E = t * o - n * i,\n        R = t * a - s * i,\n        B = n * a - s * o,\n        C = u * m - l * d,\n        M = u * g - h * d,\n        b = l * g - h * m,\n        O = t * b - n * M + s * C,\n        F = i * b - o * M + a * C,\n        v = u * B - l * R + h * E,\n        L = d * B - m * R + g * E;\n  return c * O - r * F + y * v - f * L;\n}\n\nfunction gi(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = t[3],\n        a = t[4],\n        c = t[5],\n        u = t[6],\n        l = t[7],\n        h = t[8],\n        f = t[9],\n        d = t[10],\n        m = t[11],\n        g = t[12],\n        y = t[13],\n        E = t[14],\n        R = t[15];\n  let B = n[0],\n      C = n[1],\n      M = n[2],\n      b = n[3];\n  return e[0] = B * s + C * a + M * h + b * g, e[1] = B * r + C * c + M * f + b * y, e[2] = B * i + C * u + M * d + b * E, e[3] = B * o + C * l + M * m + b * R, B = n[4], C = n[5], M = n[6], b = n[7], e[4] = B * s + C * a + M * h + b * g, e[5] = B * r + C * c + M * f + b * y, e[6] = B * i + C * u + M * d + b * E, e[7] = B * o + C * l + M * m + b * R, B = n[8], C = n[9], M = n[10], b = n[11], e[8] = B * s + C * a + M * h + b * g, e[9] = B * r + C * c + M * f + b * y, e[10] = B * i + C * u + M * d + b * E, e[11] = B * o + C * l + M * m + b * R, B = n[12], C = n[13], M = n[14], b = n[15], e[12] = B * s + C * a + M * h + b * g, e[13] = B * r + C * c + M * f + b * y, e[14] = B * i + C * u + M * d + b * E, e[15] = B * o + C * l + M * m + b * R, e;\n}\n\nfunction kh(e, t, n) {\n  const s = n[0],\n        r = n[1],\n        i = n[2];\n  let o, a, c, u, l, h, f, d, m, g, y, E;\n  return t === e ? (e[12] = t[0] * s + t[4] * r + t[8] * i + t[12], e[13] = t[1] * s + t[5] * r + t[9] * i + t[13], e[14] = t[2] * s + t[6] * r + t[10] * i + t[14], e[15] = t[3] * s + t[7] * r + t[11] * i + t[15]) : (o = t[0], a = t[1], c = t[2], u = t[3], l = t[4], h = t[5], f = t[6], d = t[7], m = t[8], g = t[9], y = t[10], E = t[11], e[0] = o, e[1] = a, e[2] = c, e[3] = u, e[4] = l, e[5] = h, e[6] = f, e[7] = d, e[8] = m, e[9] = g, e[10] = y, e[11] = E, e[12] = o * s + l * r + m * i + t[12], e[13] = a * s + h * r + g * i + t[13], e[14] = c * s + f * r + y * i + t[14], e[15] = u * s + d * r + E * i + t[15]), e;\n}\n\nfunction Kh(e, t, n) {\n  const s = n[0],\n        r = n[1],\n        i = n[2];\n  return e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s, e[3] = t[3] * s, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * i, e[9] = t[9] * i, e[10] = t[10] * i, e[11] = t[11] * i, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;\n}\n\nfunction zh(e, t, n, s) {\n  let r = s[0],\n      i = s[1],\n      o = s[2],\n      a = Math.sqrt(r * r + i * i + o * o),\n      c,\n      u,\n      l,\n      h,\n      f,\n      d,\n      m,\n      g,\n      y,\n      E,\n      R,\n      B,\n      C,\n      M,\n      b,\n      O,\n      F,\n      v,\n      L,\n      k,\n      q,\n      Y,\n      P,\n      ct;\n  return a < Fe ? null : (a = 1 / a, r *= a, i *= a, o *= a, u = Math.sin(n), c = Math.cos(n), l = 1 - c, h = t[0], f = t[1], d = t[2], m = t[3], g = t[4], y = t[5], E = t[6], R = t[7], B = t[8], C = t[9], M = t[10], b = t[11], O = r * r * l + c, F = i * r * l + o * u, v = o * r * l - i * u, L = r * i * l - o * u, k = i * i * l + c, q = o * i * l + r * u, Y = r * o * l + i * u, P = i * o * l - r * u, ct = o * o * l + c, e[0] = h * O + g * F + B * v, e[1] = f * O + y * F + C * v, e[2] = d * O + E * F + M * v, e[3] = m * O + R * F + b * v, e[4] = h * L + g * k + B * q, e[5] = f * L + y * k + C * q, e[6] = d * L + E * k + M * q, e[7] = m * L + R * k + b * q, e[8] = h * Y + g * P + B * ct, e[9] = f * Y + y * P + C * ct, e[10] = d * Y + E * P + M * ct, e[11] = m * Y + R * P + b * ct, t !== e && (e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e);\n}\n\nfunction Wh(e, t, n) {\n  const s = Math.sin(n),\n        r = Math.cos(n),\n        i = t[4],\n        o = t[5],\n        a = t[6],\n        c = t[7],\n        u = t[8],\n        l = t[9],\n        h = t[10],\n        f = t[11];\n  return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = i * r + u * s, e[5] = o * r + l * s, e[6] = a * r + h * s, e[7] = c * r + f * s, e[8] = u * r - i * s, e[9] = l * r - o * s, e[10] = h * r - a * s, e[11] = f * r - c * s, e;\n}\n\nfunction Xh(e, t, n) {\n  const s = Math.sin(n),\n        r = Math.cos(n),\n        i = t[0],\n        o = t[1],\n        a = t[2],\n        c = t[3],\n        u = t[8],\n        l = t[9],\n        h = t[10],\n        f = t[11];\n  return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = i * r - u * s, e[1] = o * r - l * s, e[2] = a * r - h * s, e[3] = c * r - f * s, e[8] = i * s + u * r, e[9] = o * s + l * r, e[10] = a * s + h * r, e[11] = c * s + f * r, e;\n}\n\nfunction Qh(e, t, n) {\n  const s = Math.sin(n),\n        r = Math.cos(n),\n        i = t[0],\n        o = t[1],\n        a = t[2],\n        c = t[3],\n        u = t[4],\n        l = t[5],\n        h = t[6],\n        f = t[7];\n  return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = i * r + u * s, e[1] = o * r + l * s, e[2] = a * r + h * s, e[3] = c * r + f * s, e[4] = u * r - i * s, e[5] = l * r - o * s, e[6] = h * r - a * s, e[7] = f * r - c * s, e;\n}\n\nfunction qh(e, t) {\n  const n = t[0],\n        s = t[1],\n        r = t[2],\n        i = t[4],\n        o = t[5],\n        a = t[6],\n        c = t[8],\n        u = t[9],\n        l = t[10];\n  return e[0] = Math.sqrt(n * n + s * s + r * r), e[1] = Math.sqrt(i * i + o * o + a * a), e[2] = Math.sqrt(c * c + u * u + l * l), e;\n}\n\nfunction Yh(e, t) {\n  const n = t[0],\n        s = t[1],\n        r = t[2],\n        i = t[3],\n        o = n + n,\n        a = s + s,\n        c = r + r,\n        u = n * o,\n        l = s * o,\n        h = s * a,\n        f = r * o,\n        d = r * a,\n        m = r * c,\n        g = i * o,\n        y = i * a,\n        E = i * c;\n  return e[0] = 1 - h - m, e[1] = l + E, e[2] = f - y, e[3] = 0, e[4] = l - E, e[5] = 1 - u - m, e[6] = d + g, e[7] = 0, e[8] = f + y, e[9] = d - g, e[10] = 1 - u - h, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;\n}\n\nfunction $h(e, t, n, s, r, i, o) {\n  const a = 1 / (n - t),\n        c = 1 / (r - s),\n        u = 1 / (i - o);\n  return e[0] = i * 2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i * 2 * c, e[6] = 0, e[7] = 0, e[8] = (n + t) * a, e[9] = (r + s) * c, e[10] = (o + i) * u, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = o * i * 2 * u, e[15] = 0, e;\n}\n\nfunction Zh(e, t, n, s, r) {\n  const i = 1 / Math.tan(t / 2);\n\n  if (e[0] = i / n, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, r != null && r !== 1 / 0) {\n    const o = 1 / (s - r);\n    e[10] = (r + s) * o, e[14] = 2 * r * s * o;\n  } else e[10] = -1, e[14] = -2 * s;\n\n  return e;\n}\n\nconst tf = Zh;\n\nfunction ef(e, t, n, s, r, i, o) {\n  const a = 1 / (t - n),\n        c = 1 / (s - r),\n        u = 1 / (i - o);\n  return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * u, e[11] = 0, e[12] = (t + n) * a, e[13] = (r + s) * c, e[14] = (o + i) * u, e[15] = 1, e;\n}\n\nconst nf = ef;\n\nfunction sf(e, t, n, s) {\n  let r, i, o, a, c, u, l, h, f, d;\n  const m = t[0],\n        g = t[1],\n        y = t[2],\n        E = s[0],\n        R = s[1],\n        B = s[2],\n        C = n[0],\n        M = n[1],\n        b = n[2];\n  return Math.abs(m - C) < Fe && Math.abs(g - M) < Fe && Math.abs(y - b) < Fe ? Hh(e) : (h = m - C, f = g - M, d = y - b, r = 1 / Math.sqrt(h * h + f * f + d * d), h *= r, f *= r, d *= r, i = R * d - B * f, o = B * h - E * d, a = E * f - R * h, r = Math.sqrt(i * i + o * o + a * a), r ? (r = 1 / r, i *= r, o *= r, a *= r) : (i = 0, o = 0, a = 0), c = f * a - d * o, u = d * i - h * a, l = h * o - f * i, r = Math.sqrt(c * c + u * u + l * l), r ? (r = 1 / r, c *= r, u *= r, l *= r) : (c = 0, u = 0, l = 0), e[0] = i, e[1] = c, e[2] = h, e[3] = 0, e[4] = o, e[5] = u, e[6] = f, e[7] = 0, e[8] = a, e[9] = l, e[10] = d, e[11] = 0, e[12] = -(i * m + o * g + a * y), e[13] = -(c * m + u * g + l * y), e[14] = -(h * m + f * g + d * y), e[15] = 1, e);\n}\n\nfunction rf() {\n  const e = new It(4);\n  return It != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0), e;\n}\n\nfunction of(e, t, n) {\n  return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e;\n}\n\nfunction af(e, t, n) {\n  return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e;\n}\n\nfunction cf(e) {\n  const t = e[0],\n        n = e[1],\n        s = e[2],\n        r = e[3];\n  return Math.sqrt(t * t + n * n + s * s + r * r);\n}\n\nfunction uf(e) {\n  const t = e[0],\n        n = e[1],\n        s = e[2],\n        r = e[3];\n  return t * t + n * n + s * s + r * r;\n}\n\nfunction lf(e, t) {\n  const n = t[0],\n        s = t[1],\n        r = t[2],\n        i = t[3];\n  let o = n * n + s * s + r * r + i * i;\n  return o > 0 && (o = 1 / Math.sqrt(o)), e[0] = n * o, e[1] = s * o, e[2] = r * o, e[3] = i * o, e;\n}\n\nfunction hf(e, t) {\n  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];\n}\n\nfunction ff(e, t, n, s) {\n  const r = t[0],\n        i = t[1],\n        o = t[2],\n        a = t[3];\n  return e[0] = r + s * (n[0] - r), e[1] = i + s * (n[1] - i), e[2] = o + s * (n[2] - o), e[3] = a + s * (n[3] - a), e;\n}\n\nfunction df(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = t[3];\n  return e[0] = n[0] * s + n[4] * r + n[8] * i + n[12] * o, e[1] = n[1] * s + n[5] * r + n[9] * i + n[13] * o, e[2] = n[2] * s + n[6] * r + n[10] * i + n[14] * o, e[3] = n[3] * s + n[7] * r + n[11] * i + n[15] * o, e;\n}\n\nfunction mf(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = n[0],\n        a = n[1],\n        c = n[2],\n        u = n[3],\n        l = u * s + a * i - c * r,\n        h = u * r + c * s - o * i,\n        f = u * i + o * r - a * s,\n        d = -o * s - a * r - c * i;\n  return e[0] = l * u + d * -o + h * -c - f * -a, e[1] = h * u + d * -a + f * -o - l * -c, e[2] = f * u + d * -c + l * -a - h * -o, e[3] = t[3], e;\n}\n\n(function () {\n  const e = rf();\n  return function (t, n, s, r, i, o) {\n    let a, c;\n\n    for (n || (n = 4), s || (s = 0), r ? c = Math.min(r * n + s, t.length) : c = t.length, a = s; a < c; a += n) e[0] = t[a], e[1] = t[a + 1], e[2] = t[a + 2], e[3] = t[a + 3], i(e, e, o), t[a] = e[0], t[a + 1] = e[1], t[a + 2] = e[2], t[a + 3] = e[3];\n\n    return t;\n  };\n})();\n\nvar Ks;\n\n(function (e) {\n  e[e.COL0ROW0 = 0] = \"COL0ROW0\", e[e.COL0ROW1 = 1] = \"COL0ROW1\", e[e.COL0ROW2 = 2] = \"COL0ROW2\", e[e.COL0ROW3 = 3] = \"COL0ROW3\", e[e.COL1ROW0 = 4] = \"COL1ROW0\", e[e.COL1ROW1 = 5] = \"COL1ROW1\", e[e.COL1ROW2 = 6] = \"COL1ROW2\", e[e.COL1ROW3 = 7] = \"COL1ROW3\", e[e.COL2ROW0 = 8] = \"COL2ROW0\", e[e.COL2ROW1 = 9] = \"COL2ROW1\", e[e.COL2ROW2 = 10] = \"COL2ROW2\", e[e.COL2ROW3 = 11] = \"COL2ROW3\", e[e.COL3ROW0 = 12] = \"COL3ROW0\", e[e.COL3ROW1 = 13] = \"COL3ROW1\", e[e.COL3ROW2 = 14] = \"COL3ROW2\", e[e.COL3ROW3 = 15] = \"COL3ROW3\";\n})(Ks || (Ks = {}));\n\nconst gf = 45 * Math.PI / 180,\n      Af = 1,\n      ds = 0.1,\n      ms = 500,\n      pf = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n\nclass V extends Ra {\n  static get IDENTITY() {\n    return Bf();\n  }\n\n  static get ZERO() {\n    return yf();\n  }\n\n  get ELEMENTS() {\n    return 16;\n  }\n\n  get RANK() {\n    return 4;\n  }\n\n  get INDICES() {\n    return Ks;\n  }\n\n  constructor(t) {\n    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(t) ? this.copy(t) : this.identity();\n  }\n\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this[4] = t[4], this[5] = t[5], this[6] = t[6], this[7] = t[7], this[8] = t[8], this[9] = t[9], this[10] = t[10], this[11] = t[11], this[12] = t[12], this[13] = t[13], this[14] = t[14], this[15] = t[15], this.check();\n  }\n\n  set(t, n, s, r, i, o, a, c, u, l, h, f, d, m, g, y) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this[4] = i, this[5] = o, this[6] = a, this[7] = c, this[8] = u, this[9] = l, this[10] = h, this[11] = f, this[12] = d, this[13] = m, this[14] = g, this[15] = y, this.check();\n  }\n\n  setRowMajor(t, n, s, r, i, o, a, c, u, l, h, f, d, m, g, y) {\n    return this[0] = t, this[1] = i, this[2] = u, this[3] = d, this[4] = n, this[5] = o, this[6] = l, this[7] = m, this[8] = s, this[9] = a, this[10] = h, this[11] = g, this[12] = r, this[13] = c, this[14] = f, this[15] = y, this.check();\n  }\n\n  toRowMajor(t) {\n    return t[0] = this[0], t[1] = this[4], t[2] = this[8], t[3] = this[12], t[4] = this[1], t[5] = this[5], t[6] = this[9], t[7] = this[13], t[8] = this[2], t[9] = this[6], t[10] = this[10], t[11] = this[14], t[12] = this[3], t[13] = this[7], t[14] = this[11], t[15] = this[15], t;\n  }\n\n  identity() {\n    return this.copy(pf);\n  }\n\n  fromObject(t) {\n    return this.check();\n  }\n\n  fromQuaternion(t) {\n    return Yh(this, t), this.check();\n  }\n\n  frustum(t) {\n    const {\n      left: n,\n      right: s,\n      bottom: r,\n      top: i,\n      near: o = ds,\n      far: a = ms\n    } = t;\n    return a === 1 / 0 ? Cf(this, n, s, r, i, o) : $h(this, n, s, r, i, o, a), this.check();\n  }\n\n  lookAt(t) {\n    const {\n      eye: n,\n      center: s = [0, 0, 0],\n      up: r = [0, 1, 0]\n    } = t;\n    return sf(this, n, s, r), this.check();\n  }\n\n  ortho(t) {\n    const {\n      left: n,\n      right: s,\n      bottom: r,\n      top: i,\n      near: o = ds,\n      far: a = ms\n    } = t;\n    return nf(this, n, s, r, i, o, a), this.check();\n  }\n\n  orthographic(t) {\n    const {\n      fovy: n = gf,\n      aspect: s = Af,\n      focalDistance: r = 1,\n      near: i = ds,\n      far: o = ms\n    } = t;\n    Ai(n);\n    const a = n / 2,\n          c = r * Math.tan(a),\n          u = c * s;\n    return this.ortho({\n      left: -u,\n      right: u,\n      bottom: -c,\n      top: c,\n      near: i,\n      far: o\n    });\n  }\n\n  perspective(t) {\n    const {\n      fovy: n = 45 * Math.PI / 180,\n      aspect: s = 1,\n      near: r = 0.1,\n      far: i = 500\n    } = t;\n    return Ai(n), tf(this, n, s, r, i), this.check();\n  }\n\n  determinant() {\n    return jh(this);\n  }\n\n  getScale(t = [-0, -0, -0]) {\n    return t[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), t[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), t[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), t;\n  }\n\n  getTranslation(t = [-0, -0, -0]) {\n    return t[0] = this[12], t[1] = this[13], t[2] = this[14], t;\n  }\n\n  getRotation(t, n) {\n    t = t || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], n = n || [-0, -0, -0];\n    const s = this.getScale(n),\n          r = 1 / s[0],\n          i = 1 / s[1],\n          o = 1 / s[2];\n    return t[0] = this[0] * r, t[1] = this[1] * i, t[2] = this[2] * o, t[3] = 0, t[4] = this[4] * r, t[5] = this[5] * i, t[6] = this[6] * o, t[7] = 0, t[8] = this[8] * r, t[9] = this[9] * i, t[10] = this[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n  }\n\n  getRotationMatrix3(t, n) {\n    t = t || [-0, -0, -0, -0, -0, -0, -0, -0, -0], n = n || [-0, -0, -0];\n    const s = this.getScale(n),\n          r = 1 / s[0],\n          i = 1 / s[1],\n          o = 1 / s[2];\n    return t[0] = this[0] * r, t[1] = this[1] * i, t[2] = this[2] * o, t[3] = this[4] * r, t[4] = this[5] * i, t[5] = this[6] * o, t[6] = this[8] * r, t[7] = this[9] * i, t[8] = this[10] * o, t;\n  }\n\n  transpose() {\n    return Jh(this, this), this.check();\n  }\n\n  invert() {\n    return Vh(this, this), this.check();\n  }\n\n  multiplyLeft(t) {\n    return gi(this, t, this), this.check();\n  }\n\n  multiplyRight(t) {\n    return gi(this, this, t), this.check();\n  }\n\n  rotateX(t) {\n    return Wh(this, this, t), this.check();\n  }\n\n  rotateY(t) {\n    return Xh(this, this, t), this.check();\n  }\n\n  rotateZ(t) {\n    return Qh(this, this, t), this.check();\n  }\n\n  rotateXYZ(t) {\n    return this.rotateX(t[0]).rotateY(t[1]).rotateZ(t[2]);\n  }\n\n  rotateAxis(t, n) {\n    return zh(this, this, t, n), this.check();\n  }\n\n  scale(t) {\n    return Kh(this, this, Array.isArray(t) ? t : [t, t, t]), this.check();\n  }\n\n  translate(t) {\n    return kh(this, this, t), this.check();\n  }\n\n  transform(t, n) {\n    return t.length === 4 ? (n = df(n || [-0, -0, -0, -0], t, this), Oe(n, 4), n) : this.transformAsPoint(t, n);\n  }\n\n  transformAsPoint(t, n) {\n    const {\n      length: s\n    } = t;\n    let r;\n\n    switch (s) {\n      case 2:\n        r = ya(n || [-0, -0], t, this);\n        break;\n\n      case 3:\n        r = Er(n || [-0, -0, -0], t, this);\n        break;\n\n      default:\n        throw new Error(\"Illegal vector\");\n    }\n\n    return Oe(r, t.length), r;\n  }\n\n  transformAsVector(t, n) {\n    let s;\n\n    switch (t.length) {\n      case 2:\n        s = Ba(n || [-0, -0], t, this);\n        break;\n\n      case 3:\n        s = Ca(n || [-0, -0, -0], t, this);\n        break;\n\n      default:\n        throw new Error(\"Illegal vector\");\n    }\n\n    return Oe(s, t.length), s;\n  }\n\n  transformPoint(t, n) {\n    return this.transformAsPoint(t, n);\n  }\n\n  transformVector(t, n) {\n    return this.transformAsPoint(t, n);\n  }\n\n  transformDirection(t, n) {\n    return this.transformAsVector(t, n);\n  }\n\n  makeRotationX(t) {\n    return this.identity().rotateX(t);\n  }\n\n  makeTranslation(t, n, s) {\n    return this.identity().translate([t, n, s]);\n  }\n\n}\n\nlet rn, on;\n\nfunction yf() {\n  return rn || (rn = new V([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(rn)), rn;\n}\n\nfunction Bf() {\n  return on || (on = new V(), Object.freeze(on)), on;\n}\n\nfunction Ai(e) {\n  if (e > Math.PI * 2) throw Error(\"expected radians\");\n}\n\nfunction Cf(e, t, n, s, r, i) {\n  const o = 2 * i / (n - t),\n        a = 2 * i / (r - s),\n        c = (n + t) / (n - t),\n        u = (r + s) / (r - s),\n        l = -1,\n        h = -1,\n        f = -2 * i;\n  return e[0] = o, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = a, e[6] = 0, e[7] = 0, e[8] = c, e[9] = u, e[10] = l, e[11] = h, e[12] = 0, e[13] = 0, e[14] = f, e[15] = 0, e;\n}\n\nfunction pi() {\n  const e = new It(4);\n  return It != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e[3] = 1, e;\n}\n\nfunction Ef(e) {\n  return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;\n}\n\nfunction Ma(e, t, n) {\n  n = n * 0.5;\n  const s = Math.sin(n);\n  return e[0] = s * t[0], e[1] = s * t[1], e[2] = s * t[2], e[3] = Math.cos(n), e;\n}\n\nfunction yi(e, t, n) {\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = t[3],\n        a = n[0],\n        c = n[1],\n        u = n[2],\n        l = n[3];\n  return e[0] = s * l + o * a + r * u - i * c, e[1] = r * l + o * c + i * a - s * u, e[2] = i * l + o * u + s * c - r * a, e[3] = o * l - s * a - r * c - i * u, e;\n}\n\nfunction Tf(e, t, n) {\n  n *= 0.5;\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = t[3],\n        a = Math.sin(n),\n        c = Math.cos(n);\n  return e[0] = s * c + o * a, e[1] = r * c + i * a, e[2] = i * c - r * a, e[3] = o * c - s * a, e;\n}\n\nfunction bf(e, t, n) {\n  n *= 0.5;\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = t[3],\n        a = Math.sin(n),\n        c = Math.cos(n);\n  return e[0] = s * c - i * a, e[1] = r * c + o * a, e[2] = i * c + s * a, e[3] = o * c - r * a, e;\n}\n\nfunction _f(e, t, n) {\n  n *= 0.5;\n  const s = t[0],\n        r = t[1],\n        i = t[2],\n        o = t[3],\n        a = Math.sin(n),\n        c = Math.cos(n);\n  return e[0] = s * c + r * a, e[1] = r * c - s * a, e[2] = i * c + o * a, e[3] = o * c - i * a, e;\n}\n\nfunction wf(e, t) {\n  const n = t[0],\n        s = t[1],\n        r = t[2];\n  return e[0] = n, e[1] = s, e[2] = r, e[3] = Math.sqrt(Math.abs(1 - n * n - s * s - r * r)), e;\n}\n\nfunction bn(e, t, n, s) {\n  const r = t[0],\n        i = t[1],\n        o = t[2],\n        a = t[3];\n  let c = n[0],\n      u = n[1],\n      l = n[2],\n      h = n[3],\n      f,\n      d,\n      m,\n      g,\n      y;\n  return f = r * c + i * u + o * l + a * h, f < 0 && (f = -f, c = -c, u = -u, l = -l, h = -h), 1 - f > Fe ? (d = Math.acos(f), y = Math.sin(d), m = Math.sin((1 - s) * d) / y, g = Math.sin(s * d) / y) : (m = 1 - s, g = s), e[0] = m * r + g * c, e[1] = m * i + g * u, e[2] = m * o + g * l, e[3] = m * a + g * h, e;\n}\n\nfunction Rf(e, t) {\n  const n = t[0],\n        s = t[1],\n        r = t[2],\n        i = t[3],\n        o = n * n + s * s + r * r + i * i,\n        a = o ? 1 / o : 0;\n  return e[0] = -n * a, e[1] = -s * a, e[2] = -r * a, e[3] = i * a, e;\n}\n\nfunction Mf(e, t) {\n  return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e;\n}\n\nfunction Sa(e, t) {\n  const n = t[0] + t[4] + t[8];\n  let s;\n  if (n > 0) s = Math.sqrt(n + 1), e[3] = 0.5 * s, s = 0.5 / s, e[0] = (t[5] - t[7]) * s, e[1] = (t[6] - t[2]) * s, e[2] = (t[1] - t[3]) * s;else {\n    let r = 0;\n    t[4] > t[0] && (r = 1), t[8] > t[r * 3 + r] && (r = 2);\n    const i = (r + 1) % 3,\n          o = (r + 2) % 3;\n    s = Math.sqrt(t[r * 3 + r] - t[i * 3 + i] - t[o * 3 + o] + 1), e[r] = 0.5 * s, s = 0.5 / s, e[3] = (t[i * 3 + o] - t[o * 3 + i]) * s, e[i] = (t[i * 3 + r] + t[r * 3 + i]) * s, e[o] = (t[o * 3 + r] + t[r * 3 + o]) * s;\n  }\n  return e;\n}\n\nconst Sf = of,\n      If = af,\n      xf = hf,\n      vf = ff,\n      Of = cf,\n      Ff = uf,\n      Ia = lf,\n      Df = function () {\n  const e = Ta(),\n        t = fi(1, 0, 0),\n        n = fi(0, 1, 0);\n  return function (s, r, i) {\n    const o = Cr(r, i);\n    return o < -0.999999 ? (Tn(e, t, r), Ih(e) < 1e-6 && Tn(e, n, r), _h(e, e), Ma(s, e, Math.PI), s) : o > 0.999999 ? (s[0] = 0, s[1] = 0, s[2] = 0, s[3] = 1, s) : (Tn(e, r, i), s[0] = e[0], s[1] = e[1], s[2] = e[2], s[3] = 1 + o, Ia(s, s));\n  };\n}();\n\n(function () {\n  const e = pi(),\n        t = pi();\n  return function (n, s, r, i, o, a) {\n    return bn(e, s, o, a), bn(t, r, i, a), bn(n, e, t, 2 * a * (1 - a)), n;\n  };\n})();\n\n(function () {\n  const e = xh();\n  return function (t, n, s, r) {\n    return e[0] = s[0], e[3] = s[1], e[6] = s[2], e[1] = r[0], e[4] = r[1], e[7] = r[2], e[2] = -n[0], e[5] = -n[1], e[8] = -n[2], Ia(t, Sa(t, e));\n  };\n})();\n\nconst Lf = [0, 0, 0, 1];\n\nclass On extends yr {\n  constructor(t = 0, n = 0, s = 0, r = 1) {\n    super(-0, -0, -0, -0), Array.isArray(t) && arguments.length === 1 ? this.copy(t) : this.set(t, n, s, r);\n  }\n\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this.check();\n  }\n\n  set(t, n, s, r) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this.check();\n  }\n\n  fromObject(t) {\n    return this[0] = t.x, this[1] = t.y, this[2] = t.z, this[3] = t.w, this.check();\n  }\n\n  fromMatrix3(t) {\n    return Sa(this, t), this.check();\n  }\n\n  fromAxisRotation(t, n) {\n    return Ma(this, t, n), this.check();\n  }\n\n  identity() {\n    return Ef(this), this.check();\n  }\n\n  setAxisAngle(t, n) {\n    return this.fromAxisRotation(t, n);\n  }\n\n  get ELEMENTS() {\n    return 4;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  set x(t) {\n    this[0] = U(t);\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  set y(t) {\n    this[1] = U(t);\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set z(t) {\n    this[2] = U(t);\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set w(t) {\n    this[3] = U(t);\n  }\n\n  len() {\n    return Of(this);\n  }\n\n  lengthSquared() {\n    return Ff(this);\n  }\n\n  dot(t) {\n    return xf(this, t);\n  }\n\n  rotationTo(t, n) {\n    return Df(this, t, n), this.check();\n  }\n\n  add(t) {\n    return Sf(this, this, t), this.check();\n  }\n\n  calculateW() {\n    return wf(this, this), this.check();\n  }\n\n  conjugate() {\n    return Mf(this, this), this.check();\n  }\n\n  invert() {\n    return Rf(this, this), this.check();\n  }\n\n  lerp(t, n, s) {\n    return s === void 0 ? this.lerp(this, t, n) : (vf(this, t, n, s), this.check());\n  }\n\n  multiplyRight(t) {\n    return yi(this, this, t), this.check();\n  }\n\n  multiplyLeft(t) {\n    return yi(this, t, this), this.check();\n  }\n\n  normalize() {\n    const t = this.len(),\n          n = t > 0 ? 1 / t : 0;\n    return this[0] = this[0] * n, this[1] = this[1] * n, this[2] = this[2] * n, this[3] = this[3] * n, t === 0 && (this[3] = 1), this.check();\n  }\n\n  rotateX(t) {\n    return Tf(this, this, t), this.check();\n  }\n\n  rotateY(t) {\n    return bf(this, this, t), this.check();\n  }\n\n  rotateZ(t) {\n    return _f(this, this, t), this.check();\n  }\n\n  scale(t) {\n    return If(this, this, t), this.check();\n  }\n\n  slerp(t, n, s) {\n    let r, i, o;\n\n    switch (arguments.length) {\n      case 1:\n        ({\n          start: r = Lf,\n          target: i,\n          ratio: o\n        } = t);\n        break;\n\n      case 2:\n        r = this, i = t, o = n;\n        break;\n\n      default:\n        r = t, i = n, o = s;\n    }\n\n    return bn(this, r, i, o), this.check();\n  }\n\n  transformVector4(t, n = new Tr()) {\n    return mf(n, t, this), Oe(n, 4);\n  }\n\n  lengthSq() {\n    return this.lengthSquared();\n  }\n\n  setFromAxisAngle(t, n) {\n    return this.setAxisAngle(t, n);\n  }\n\n  premultiply(t) {\n    return this.multiplyLeft(t);\n  }\n\n  multiply(t) {\n    return this.multiplyRight(t);\n  }\n\n}\n\nfunction Ne(e) {\n  \"@babel/helpers - typeof\";\n\n  return Ne = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function (t) {\n    return typeof t;\n  } : function (t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Ne(e);\n}\n\nfunction Pf(e, t) {\n  if (Ne(e) != \"object\" || !e) return e;\n  var n = e[Symbol.toPrimitive];\n\n  if (n !== void 0) {\n    var s = n.call(e, t || \"default\");\n    if (Ne(s) != \"object\") return s;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (t === \"string\" ? String : Number)(e);\n}\n\nfunction Gf(e) {\n  var t = Pf(e, \"string\");\n  return Ne(t) == \"symbol\" ? t : String(t);\n}\n\nfunction x(e, t, n) {\n  return t = Gf(t), t in e ? Object.defineProperty(e, t, {\n    value: n,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[t] = n, e;\n}\n\nconst Nf = 0.1,\n      Uf = 1e-12,\n      xa = 1e-15,\n      Hf = 1e-20,\n      Jf = 6378137,\n      Vf = 6378137,\n      jf = 6356752314245179e-9;\n\nfunction Xn(e) {\n  return e;\n}\n\nnew A();\n\nfunction kf(e, t = [], n = Xn) {\n  return \"longitude\" in e ? (t[0] = n(e.longitude), t[1] = n(e.latitude), t[2] = e.height) : \"x\" in e ? (t[0] = n(e.x), t[1] = n(e.y), t[2] = e.z) : (t[0] = n(e[0]), t[1] = n(e[1]), t[2] = e[2]), t;\n}\n\nfunction Kf(e, t = []) {\n  return kf(e, t, et._cartographicRadians ? Xn : hh);\n}\n\nfunction zf(e, t, n = Xn) {\n  return \"longitude\" in t ? (t.longitude = n(e[0]), t.latitude = n(e[1]), t.height = e[2]) : \"x\" in t ? (t.x = n(e[0]), t.y = n(e[1]), t.z = e[2]) : (t[0] = n(e[0]), t[1] = n(e[1]), t[2] = e[2]), t;\n}\n\nfunction Wf(e, t) {\n  return zf(e, t, et._cartographicRadians ? Xn : fh);\n}\n\nconst Bi = 1e-14,\n      Xf = new A(),\n      Ci = {\n  up: {\n    south: \"east\",\n    north: \"west\",\n    west: \"south\",\n    east: \"north\"\n  },\n  down: {\n    south: \"west\",\n    north: \"east\",\n    west: \"north\",\n    east: \"south\"\n  },\n  south: {\n    up: \"west\",\n    down: \"east\",\n    west: \"down\",\n    east: \"up\"\n  },\n  north: {\n    up: \"east\",\n    down: \"west\",\n    west: \"up\",\n    east: \"down\"\n  },\n  west: {\n    up: \"north\",\n    down: \"south\",\n    north: \"down\",\n    south: \"up\"\n  },\n  east: {\n    up: \"south\",\n    down: \"north\",\n    north: \"up\",\n    south: \"down\"\n  }\n},\n      gs = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1]\n},\n      Te = {\n  east: new A(),\n  north: new A(),\n  up: new A(),\n  west: new A(),\n  south: new A(),\n  down: new A()\n},\n      Qf = new A(),\n      qf = new A(),\n      Yf = new A();\n\nfunction Ei(e, t, n, s, r, i) {\n  const o = Ci[t] && Ci[t][n];\n  j(o && (!s || s === o));\n  let a, c, u;\n  const l = Xf.copy(r);\n\n  if (Kt(l.x, 0, Bi) && Kt(l.y, 0, Bi)) {\n    const f = Math.sign(l.z);\n    a = Qf.fromArray(gs[t]), t !== \"east\" && t !== \"west\" && a.scale(f), c = qf.fromArray(gs[n]), n !== \"east\" && n !== \"west\" && c.scale(f), u = Yf.fromArray(gs[s]), s !== \"east\" && s !== \"west\" && u.scale(f);\n  } else {\n    const {\n      up: f,\n      east: d,\n      north: m\n    } = Te;\n    d.set(-l.y, l.x, 0).normalize(), e.geodeticSurfaceNormal(l, f), m.copy(f).cross(d);\n    const {\n      down: g,\n      west: y,\n      south: E\n    } = Te;\n    g.copy(f).scale(-1), y.copy(d).scale(-1), E.copy(m).scale(-1), a = Te[t], c = Te[n], u = Te[s];\n  }\n\n  return i[0] = a.x, i[1] = a.y, i[2] = a.z, i[3] = 0, i[4] = c.x, i[5] = c.y, i[6] = c.z, i[7] = 0, i[8] = u.x, i[9] = u.y, i[10] = u.z, i[11] = 0, i[12] = l.x, i[13] = l.y, i[14] = l.z, i[15] = 1, i;\n}\n\nconst ue = new A(),\n      $f = new A(),\n      Zf = new A();\n\nfunction td(e, t, n = []) {\n  const {\n    oneOverRadii: s,\n    oneOverRadiiSquared: r,\n    centerToleranceSquared: i\n  } = t;\n  ue.from(e);\n  const o = ue.x,\n        a = ue.y,\n        c = ue.z,\n        u = s.x,\n        l = s.y,\n        h = s.z,\n        f = o * o * u * u,\n        d = a * a * l * l,\n        m = c * c * h * h,\n        g = f + d + m,\n        y = Math.sqrt(1 / g);\n  if (!Number.isFinite(y)) return;\n  const E = $f;\n  if (E.copy(e).scale(y), g < i) return E.to(n);\n  const R = r.x,\n        B = r.y,\n        C = r.z,\n        M = Zf;\n  M.set(E.x * R * 2, E.y * B * 2, E.z * C * 2);\n  let b = (1 - y) * ue.len() / (0.5 * M.len()),\n      O = 0,\n      F,\n      v,\n      L,\n      k;\n\n  do {\n    b -= O, F = 1 / (1 + b * R), v = 1 / (1 + b * B), L = 1 / (1 + b * C);\n    const q = F * F,\n          Y = v * v,\n          P = L * L,\n          ct = q * F,\n          Wt = Y * v,\n          oe = P * L;\n    k = f * q + d * Y + m * P - 1;\n    const vt = -2 * (f * ct * R + d * Wt * B + m * oe * C);\n    O = k / vt;\n  } while (Math.abs(k) > Uf);\n\n  return ue.scale([F, v, L]).to(n);\n}\n\nconst an = new A(),\n      Ti = new A(),\n      ed = new A(),\n      wt = new A(),\n      nd = new A(),\n      cn = new A();\n\nclass J {\n  constructor(t = 0, n = 0, s = 0) {\n    x(this, \"radii\", void 0), x(this, \"radiiSquared\", void 0), x(this, \"radiiToTheFourth\", void 0), x(this, \"oneOverRadii\", void 0), x(this, \"oneOverRadiiSquared\", void 0), x(this, \"minimumRadius\", void 0), x(this, \"maximumRadius\", void 0), x(this, \"centerToleranceSquared\", Nf), x(this, \"squaredXOverSquaredZ\", void 0), j(t >= 0), j(n >= 0), j(s >= 0), this.radii = new A(t, n, s), this.radiiSquared = new A(t * t, n * n, s * s), this.radiiToTheFourth = new A(t * t * t * t, n * n * n * n, s * s * s * s), this.oneOverRadii = new A(t === 0 ? 0 : 1 / t, n === 0 ? 0 : 1 / n, s === 0 ? 0 : 1 / s), this.oneOverRadiiSquared = new A(t === 0 ? 0 : 1 / (t * t), n === 0 ? 0 : 1 / (n * n), s === 0 ? 0 : 1 / (s * s)), this.minimumRadius = Math.min(t, n, s), this.maximumRadius = Math.max(t, n, s), this.radiiSquared.z !== 0 && (this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z), Object.freeze(this);\n  }\n\n  equals(t) {\n    return this === t || !!(t && this.radii.equals(t.radii));\n  }\n\n  toString() {\n    return this.radii.toString();\n  }\n\n  cartographicToCartesian(t, n = [0, 0, 0]) {\n    const s = Ti,\n          r = ed,\n          [,, i] = t;\n    this.geodeticSurfaceNormalCartographic(t, s), r.copy(this.radiiSquared).scale(s);\n    const o = Math.sqrt(s.dot(r));\n    return r.scale(1 / o), s.scale(i), r.add(s), r.to(n);\n  }\n\n  cartesianToCartographic(t, n = [0, 0, 0]) {\n    cn.from(t);\n    const s = this.scaleToGeodeticSurface(cn, wt);\n    if (!s) return;\n    const r = this.geodeticSurfaceNormal(s, Ti),\n          i = nd;\n    i.copy(cn).subtract(s);\n    const o = Math.atan2(r.y, r.x),\n          a = Math.asin(r.z),\n          c = Math.sign(Cr(i, cn)) * ba(i);\n    return Wf([o, a, c], n);\n  }\n\n  eastNorthUpToFixedFrame(t, n = new V()) {\n    return Ei(this, \"east\", \"north\", \"up\", t, n);\n  }\n\n  localFrameToFixedFrame(t, n, s, r, i = new V()) {\n    return Ei(this, t, n, s, r, i);\n  }\n\n  geocentricSurfaceNormal(t, n = [0, 0, 0]) {\n    return an.from(t).normalize().to(n);\n  }\n\n  geodeticSurfaceNormalCartographic(t, n = [0, 0, 0]) {\n    const s = Kf(t),\n          r = s[0],\n          i = s[1],\n          o = Math.cos(i);\n    return an.set(o * Math.cos(r), o * Math.sin(r), Math.sin(i)).normalize(), an.to(n);\n  }\n\n  geodeticSurfaceNormal(t, n = [0, 0, 0]) {\n    return an.from(t).scale(this.oneOverRadiiSquared).normalize().to(n);\n  }\n\n  scaleToGeodeticSurface(t, n) {\n    return td(t, this, n);\n  }\n\n  scaleToGeocentricSurface(t, n = [0, 0, 0]) {\n    wt.from(t);\n    const s = wt.x,\n          r = wt.y,\n          i = wt.z,\n          o = this.oneOverRadiiSquared,\n          a = 1 / Math.sqrt(s * s * o.x + r * r * o.y + i * i * o.z);\n    return wt.multiplyScalar(a).to(n);\n  }\n\n  transformPositionToScaledSpace(t, n = [0, 0, 0]) {\n    return wt.from(t).scale(this.oneOverRadii).to(n);\n  }\n\n  transformPositionFromScaledSpace(t, n = [0, 0, 0]) {\n    return wt.from(t).scale(this.radii).to(n);\n  }\n\n  getSurfaceNormalIntersectionWithZAxis(t, n = 0, s = [0, 0, 0]) {\n    j(Kt(this.radii.x, this.radii.y, xa)), j(this.radii.z > 0), wt.from(t);\n    const r = wt.z * (1 - this.squaredXOverSquaredZ);\n    if (!(Math.abs(r) >= this.radii.z - n)) return wt.set(0, 0, r).to(s);\n  }\n\n}\n\nx(J, \"WGS84\", new J(Jf, Vf, jf));\nconst pt = {\n  OUTSIDE: -1,\n  INTERSECTING: 0,\n  INSIDE: 1\n};\nnew A();\nnew A();\nconst be = new A(),\n      bi = new A();\n\nclass Qe {\n  constructor(t = [0, 0, 0], n = 0) {\n    x(this, \"center\", void 0), x(this, \"radius\", void 0), this.radius = -0, this.center = new A(), this.fromCenterRadius(t, n);\n  }\n\n  fromCenterRadius(t, n) {\n    return this.center.from(t), this.radius = n, this;\n  }\n\n  fromCornerPoints(t, n) {\n    return n = be.from(n), this.center = new A().from(t).add(n).scale(0.5), this.radius = this.center.distance(n), this;\n  }\n\n  equals(t) {\n    return this === t || !!t && this.center.equals(t.center) && this.radius === t.radius;\n  }\n\n  clone() {\n    return new Qe(this.center, this.radius);\n  }\n\n  union(t) {\n    const n = this.center,\n          s = this.radius,\n          r = t.center,\n          i = t.radius,\n          o = be.copy(r).subtract(n),\n          a = o.magnitude();\n    if (s >= a + i) return this.clone();\n    if (i >= a + s) return t.clone();\n    const c = (s + a + i) * 0.5;\n    return bi.copy(o).scale((-s + c) / a).add(n), this.center.copy(bi), this.radius = c, this;\n  }\n\n  expand(t) {\n    const s = be.from(t).subtract(this.center).magnitude();\n    return s > this.radius && (this.radius = s), this;\n  }\n\n  transform(t) {\n    this.center.transform(t);\n    const n = qh(be, t);\n    return this.radius = Math.max(n[0], Math.max(n[1], n[2])) * this.radius, this;\n  }\n\n  distanceSquaredTo(t) {\n    const n = this.distanceTo(t);\n    return n * n;\n  }\n\n  distanceTo(t) {\n    const s = be.from(t).subtract(this.center);\n    return Math.max(0, s.len() - this.radius);\n  }\n\n  intersectPlane(t) {\n    const n = this.center,\n          s = this.radius,\n          i = t.normal.dot(n) + t.distance;\n    return i < -s ? pt.OUTSIDE : i < s ? pt.INTERSECTING : pt.INSIDE;\n  }\n\n}\n\nconst sd = new A(),\n      rd = new A(),\n      un = new A(),\n      ln = new A(),\n      hn = new A(),\n      id = new A(),\n      od = new A(),\n      Gt = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\n\nclass qe {\n  constructor(t = [0, 0, 0], n = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n    x(this, \"center\", void 0), x(this, \"halfAxes\", void 0), this.center = new A().from(t), this.halfAxes = new X(n);\n  }\n\n  get halfSize() {\n    const t = this.halfAxes.getColumn(0),\n          n = this.halfAxes.getColumn(1),\n          s = this.halfAxes.getColumn(2);\n    return [new A(t).len(), new A(n).len(), new A(s).len()];\n  }\n\n  get quaternion() {\n    const t = this.halfAxes.getColumn(0),\n          n = this.halfAxes.getColumn(1),\n          s = this.halfAxes.getColumn(2),\n          r = new A(t).normalize(),\n          i = new A(n).normalize(),\n          o = new A(s).normalize();\n    return new On().fromMatrix3(new X([...r, ...i, ...o]));\n  }\n\n  fromCenterHalfSizeQuaternion(t, n, s) {\n    const r = new On(s),\n          i = new X().fromQuaternion(r);\n    return i[0] = i[0] * n[0], i[1] = i[1] * n[0], i[2] = i[2] * n[0], i[3] = i[3] * n[1], i[4] = i[4] * n[1], i[5] = i[5] * n[1], i[6] = i[6] * n[2], i[7] = i[7] * n[2], i[8] = i[8] * n[2], this.center = new A().from(t), this.halfAxes = i, this;\n  }\n\n  clone() {\n    return new qe(this.center, this.halfAxes);\n  }\n\n  equals(t) {\n    return this === t || !!t && this.center.equals(t.center) && this.halfAxes.equals(t.halfAxes);\n  }\n\n  getBoundingSphere(t = new Qe()) {\n    const n = this.halfAxes,\n          s = n.getColumn(0, un),\n          r = n.getColumn(1, ln),\n          i = n.getColumn(2, hn),\n          o = sd.copy(s).add(r).add(i);\n    return t.center.copy(this.center), t.radius = o.magnitude(), t;\n  }\n\n  intersectPlane(t) {\n    const n = this.center,\n          s = t.normal,\n          r = this.halfAxes,\n          i = s.x,\n          o = s.y,\n          a = s.z,\n          c = Math.abs(i * r[Gt.COLUMN0ROW0] + o * r[Gt.COLUMN0ROW1] + a * r[Gt.COLUMN0ROW2]) + Math.abs(i * r[Gt.COLUMN1ROW0] + o * r[Gt.COLUMN1ROW1] + a * r[Gt.COLUMN1ROW2]) + Math.abs(i * r[Gt.COLUMN2ROW0] + o * r[Gt.COLUMN2ROW1] + a * r[Gt.COLUMN2ROW2]),\n          u = s.dot(n) + t.distance;\n    return u <= -c ? pt.OUTSIDE : u >= c ? pt.INSIDE : pt.INTERSECTING;\n  }\n\n  distanceTo(t) {\n    return Math.sqrt(this.distanceSquaredTo(t));\n  }\n\n  distanceSquaredTo(t) {\n    const n = rd.from(t).subtract(this.center),\n          s = this.halfAxes,\n          r = s.getColumn(0, un),\n          i = s.getColumn(1, ln),\n          o = s.getColumn(2, hn),\n          a = r.magnitude(),\n          c = i.magnitude(),\n          u = o.magnitude();\n    r.normalize(), i.normalize(), o.normalize();\n    let l = 0,\n        h;\n    return h = Math.abs(n.dot(r)) - a, h > 0 && (l += h * h), h = Math.abs(n.dot(i)) - c, h > 0 && (l += h * h), h = Math.abs(n.dot(o)) - u, h > 0 && (l += h * h), l;\n  }\n\n  computePlaneDistances(t, n, s = [-0, -0]) {\n    let r = Number.POSITIVE_INFINITY,\n        i = Number.NEGATIVE_INFINITY;\n    const o = this.center,\n          a = this.halfAxes,\n          c = a.getColumn(0, un),\n          u = a.getColumn(1, ln),\n          l = a.getColumn(2, hn),\n          h = id.copy(c).add(u).add(l).add(o),\n          f = od.copy(h).subtract(t);\n    let d = n.dot(f);\n    return r = Math.min(d, r), i = Math.max(d, i), h.copy(o).add(c).add(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), h.copy(o).add(c).subtract(u).add(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), h.copy(o).add(c).subtract(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).add(u).add(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).add(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).subtract(u).add(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).subtract(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), s[0] = r, s[1] = i, s;\n  }\n\n  transform(t) {\n    this.center.transformAsPoint(t);\n    const n = this.halfAxes.getColumn(0, un);\n    n.transformAsPoint(t);\n    const s = this.halfAxes.getColumn(1, ln);\n    s.transformAsPoint(t);\n    const r = this.halfAxes.getColumn(2, hn);\n    return r.transformAsPoint(t), this.halfAxes = new X([...n, ...s, ...r]), this;\n  }\n\n  getTransform() {\n    throw new Error(\"not implemented\");\n  }\n\n}\n\nconst _i = new A(),\n      wi = new A();\n\nclass nt {\n  constructor(t = [0, 0, 1], n = 0) {\n    x(this, \"normal\", void 0), x(this, \"distance\", void 0), this.normal = new A(), this.distance = -0, this.fromNormalDistance(t, n);\n  }\n\n  fromNormalDistance(t, n) {\n    return j(Number.isFinite(n)), this.normal.from(t).normalize(), this.distance = n, this;\n  }\n\n  fromPointNormal(t, n) {\n    t = _i.from(t), this.normal.from(n).normalize();\n    const s = -this.normal.dot(t);\n    return this.distance = s, this;\n  }\n\n  fromCoefficients(t, n, s, r) {\n    return this.normal.set(t, n, s), j(Kt(this.normal.len(), 1)), this.distance = r, this;\n  }\n\n  clone() {\n    return new nt(this.normal, this.distance);\n  }\n\n  equals(t) {\n    return Kt(this.distance, t.distance) && Kt(this.normal, t.normal);\n  }\n\n  getPointDistance(t) {\n    return this.normal.dot(t) + this.distance;\n  }\n\n  transform(t) {\n    const n = wi.copy(this.normal).transformAsVector(t).normalize(),\n          s = this.normal.scale(-this.distance).transform(t);\n    return this.fromPointNormal(s, n);\n  }\n\n  projectPointOntoPlane(t, n = [0, 0, 0]) {\n    const s = _i.from(t),\n          r = this.getPointDistance(s),\n          i = wi.copy(this.normal).scale(r);\n\n    return s.subtract(i).to(n);\n  }\n\n}\n\nconst Ri = [new A([1, 0, 0]), new A([0, 1, 0]), new A([0, 0, 1])],\n      Mi = new A(),\n      ad = new A();\n\nclass dt {\n  constructor(t = []) {\n    x(this, \"planes\", void 0), this.planes = t;\n  }\n\n  fromBoundingSphere(t) {\n    this.planes.length = 2 * Ri.length;\n    const n = t.center,\n          s = t.radius;\n    let r = 0;\n\n    for (const i of Ri) {\n      let o = this.planes[r],\n          a = this.planes[r + 1];\n      o || (o = this.planes[r] = new nt()), a || (a = this.planes[r + 1] = new nt());\n      const c = Mi.copy(i).scale(-s).add(n);\n      o.fromPointNormal(c, i);\n      const u = Mi.copy(i).scale(s).add(n),\n            l = ad.copy(i).negate();\n      a.fromPointNormal(u, l), r += 2;\n    }\n\n    return this;\n  }\n\n  computeVisibility(t) {\n    let n = pt.INSIDE;\n\n    for (const s of this.planes) switch (t.intersectPlane(s)) {\n      case pt.OUTSIDE:\n        return pt.OUTSIDE;\n\n      case pt.INTERSECTING:\n        n = pt.INTERSECTING;\n        break;\n    }\n\n    return n;\n  }\n\n  computeVisibilityWithPlaneMask(t, n) {\n    if (j(Number.isFinite(n), \"parentPlaneMask is required.\"), n === dt.MASK_OUTSIDE || n === dt.MASK_INSIDE) return n;\n    let s = dt.MASK_INSIDE;\n    const r = this.planes;\n\n    for (let i = 0; i < this.planes.length; ++i) {\n      const o = i < 31 ? 1 << i : 0;\n      if (i < 31 && !(n & o)) continue;\n      const a = r[i],\n            c = t.intersectPlane(a);\n      if (c === pt.OUTSIDE) return dt.MASK_OUTSIDE;\n      c === pt.INTERSECTING && (s |= o);\n    }\n\n    return s;\n  }\n\n}\n\nx(dt, \"MASK_OUTSIDE\", 4294967295);\nx(dt, \"MASK_INSIDE\", 0);\nx(dt, \"MASK_INDETERMINATE\", 2147483647);\nconst cd = new A(),\n      ud = new A(),\n      ld = new A(),\n      hd = new A(),\n      fd = new A();\n\nclass Fn {\n  constructor(t = {}) {\n    x(this, \"left\", void 0), x(this, \"_left\", void 0), x(this, \"right\", void 0), x(this, \"_right\", void 0), x(this, \"top\", void 0), x(this, \"_top\", void 0), x(this, \"bottom\", void 0), x(this, \"_bottom\", void 0), x(this, \"near\", void 0), x(this, \"_near\", void 0), x(this, \"far\", void 0), x(this, \"_far\", void 0), x(this, \"_cullingVolume\", new dt([new nt(), new nt(), new nt(), new nt(), new nt(), new nt()])), x(this, \"_perspectiveMatrix\", new V()), x(this, \"_infinitePerspective\", new V());\n    const {\n      near: n = 1,\n      far: s = 5e8\n    } = t;\n    this.left = t.left, this._left = void 0, this.right = t.right, this._right = void 0, this.top = t.top, this._top = void 0, this.bottom = t.bottom, this._bottom = void 0, this.near = n, this._near = n, this.far = s, this._far = s;\n  }\n\n  clone() {\n    return new Fn({\n      right: this.right,\n      left: this.left,\n      top: this.top,\n      bottom: this.bottom,\n      near: this.near,\n      far: this.far\n    });\n  }\n\n  equals(t) {\n    return t && t instanceof Fn && this.right === t.right && this.left === t.left && this.top === t.top && this.bottom === t.bottom && this.near === t.near && this.far === t.far;\n  }\n\n  get projectionMatrix() {\n    return this._update(), this._perspectiveMatrix;\n  }\n\n  get infiniteProjectionMatrix() {\n    return this._update(), this._infinitePerspective;\n  }\n\n  computeCullingVolume(t, n, s) {\n    j(t, \"position is required.\"), j(n, \"direction is required.\"), j(s, \"up is required.\");\n    const r = this._cullingVolume.planes;\n    s = cd.copy(s).normalize();\n    const i = ud.copy(n).cross(s).normalize(),\n          o = ld.copy(n).multiplyByScalar(this.near).add(t),\n          a = hd.copy(n).multiplyByScalar(this.far).add(t);\n    let c = fd;\n    return c.copy(i).multiplyByScalar(this.left).add(o).subtract(t).cross(s), r[0].fromPointNormal(t, c), c.copy(i).multiplyByScalar(this.right).add(o).subtract(t).cross(s).negate(), r[1].fromPointNormal(t, c), c.copy(s).multiplyByScalar(this.bottom).add(o).subtract(t).cross(i).negate(), r[2].fromPointNormal(t, c), c.copy(s).multiplyByScalar(this.top).add(o).subtract(t).cross(i), r[3].fromPointNormal(t, c), c = new A().copy(n), r[4].fromPointNormal(o, c), c.negate(), r[5].fromPointNormal(a, c), this._cullingVolume;\n  }\n\n  getPixelDimensions(t, n, s, r) {\n    this._update(), j(Number.isFinite(t) && Number.isFinite(n)), j(t > 0), j(n > 0), j(s > 0), j(r);\n    const i = 1 / this.near;\n    let o = this.top * i;\n    const a = 2 * s * o / n;\n    o = this.right * i;\n    const c = 2 * s * o / t;\n    return r.x = c, r.y = a, r;\n  }\n\n  _update() {\n    j(Number.isFinite(this.right) && Number.isFinite(this.left) && Number.isFinite(this.top) && Number.isFinite(this.bottom) && Number.isFinite(this.near) && Number.isFinite(this.far));\n    const {\n      top: t,\n      bottom: n,\n      right: s,\n      left: r,\n      near: i,\n      far: o\n    } = this;\n    (t !== this._top || n !== this._bottom || r !== this._left || s !== this._right || i !== this._near || o !== this._far) && (j(this.near > 0 && this.near < this.far, \"near must be greater than zero and less than far.\"), this._left = r, this._right = s, this._top = t, this._bottom = n, this._near = i, this._far = o, this._perspectiveMatrix = new V().frustum({\n      left: r,\n      right: s,\n      bottom: n,\n      top: t,\n      near: i,\n      far: o\n    }), this._infinitePerspective = new V().frustum({\n      left: r,\n      right: s,\n      bottom: n,\n      top: t,\n      near: i,\n      far: 1 / 0\n    }));\n  }\n\n}\n\nconst dd = e => e !== null && typeof e < \"u\";\n\nclass Dn {\n  constructor(t = {}) {\n    x(this, \"_offCenterFrustum\", new Fn()), x(this, \"fov\", void 0), x(this, \"_fov\", void 0), x(this, \"_fovy\", void 0), x(this, \"_sseDenominator\", void 0), x(this, \"aspectRatio\", void 0), x(this, \"_aspectRatio\", void 0), x(this, \"near\", void 0), x(this, \"_near\", void 0), x(this, \"far\", void 0), x(this, \"_far\", void 0), x(this, \"xOffset\", void 0), x(this, \"_xOffset\", void 0), x(this, \"yOffset\", void 0), x(this, \"_yOffset\", void 0);\n    const {\n      fov: n,\n      aspectRatio: s,\n      near: r = 1,\n      far: i = 5e8,\n      xOffset: o = 0,\n      yOffset: a = 0\n    } = t;\n    this.fov = n, this.aspectRatio = s, this.near = r, this.far = i, this.xOffset = o, this.yOffset = a;\n  }\n\n  clone() {\n    return new Dn({\n      aspectRatio: this.aspectRatio,\n      fov: this.fov,\n      near: this.near,\n      far: this.far\n    });\n  }\n\n  equals(t) {\n    return !dd(t) || !(t instanceof Dn) ? !1 : (this._update(), t._update(), this.fov === t.fov && this.aspectRatio === t.aspectRatio && this.near === t.near && this.far === t.far && this._offCenterFrustum.equals(t._offCenterFrustum));\n  }\n\n  get projectionMatrix() {\n    return this._update(), this._offCenterFrustum.projectionMatrix;\n  }\n\n  get infiniteProjectionMatrix() {\n    return this._update(), this._offCenterFrustum.infiniteProjectionMatrix;\n  }\n\n  get fovy() {\n    return this._update(), this._fovy;\n  }\n\n  get sseDenominator() {\n    return this._update(), this._sseDenominator;\n  }\n\n  computeCullingVolume(t, n, s) {\n    return this._update(), this._offCenterFrustum.computeCullingVolume(t, n, s);\n  }\n\n  getPixelDimensions(t, n, s, r) {\n    return this._update(), this._offCenterFrustum.getPixelDimensions(t, n, s, r || new Wn());\n  }\n\n  _update() {\n    j(Number.isFinite(this.fov) && Number.isFinite(this.aspectRatio) && Number.isFinite(this.near) && Number.isFinite(this.far));\n    const t = this._offCenterFrustum;\n    (this.fov !== this._fov || this.aspectRatio !== this._aspectRatio || this.near !== this._near || this.far !== this._far || this.xOffset !== this._xOffset || this.yOffset !== this._yOffset) && (j(this.fov >= 0 && this.fov < Math.PI), j(this.aspectRatio > 0), j(this.near >= 0 && this.near < this.far), this._aspectRatio = this.aspectRatio, this._fov = this.fov, this._fovy = this.aspectRatio <= 1 ? this.fov : Math.atan(Math.tan(this.fov * 0.5) / this.aspectRatio) * 2, this._near = this.near, this._far = this.far, this._sseDenominator = 2 * Math.tan(0.5 * this._fovy), this._xOffset = this.xOffset, this._yOffset = this.yOffset, t.top = this.near * Math.tan(0.5 * this._fovy), t.bottom = -t.top, t.right = this.aspectRatio * t.top, t.left = -t.right, t.near = this.near, t.far = this.far, t.right += this.xOffset, t.left += this.xOffset, t.top += this.yOffset, t.bottom += this.yOffset);\n  }\n\n}\n\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nconst Ot = new X(),\n      md = new X(),\n      gd = new X(),\n      fn = new X(),\n      Si = new X();\n\nfunction Ad(e, t = {}) {\n  const n = Hf,\n        s = 10;\n  let r = 0,\n      i = 0;\n  const o = md,\n        a = gd;\n  o.identity(), a.copy(e);\n  const c = n * pd(a);\n\n  for (; i < s && yd(a) > c;) Bd(a, fn), Si.copy(fn).transpose(), a.multiplyRight(fn), a.multiplyLeft(Si), o.multiplyRight(fn), ++r > 2 && (++i, r = 0);\n\n  return t.unitary = o.toTarget(t.unitary), t.diagonal = a.toTarget(t.diagonal), t;\n}\n\nfunction pd(e) {\n  let t = 0;\n\n  for (let n = 0; n < 9; ++n) {\n    const s = e[n];\n    t += s * s;\n  }\n\n  return Math.sqrt(t);\n}\n\nconst zs = [1, 0, 0],\n      Ws = [2, 2, 1];\n\nfunction yd(e) {\n  let t = 0;\n\n  for (let n = 0; n < 3; ++n) {\n    const s = e[Ot.getElementIndex(Ws[n], zs[n])];\n    t += 2 * s * s;\n  }\n\n  return Math.sqrt(t);\n}\n\nfunction Bd(e, t) {\n  const n = xa;\n  let s = 0,\n      r = 1;\n\n  for (let u = 0; u < 3; ++u) {\n    const l = Math.abs(e[Ot.getElementIndex(Ws[u], zs[u])]);\n    l > s && (r = u, s = l);\n  }\n\n  const i = zs[r],\n        o = Ws[r];\n  let a = 1,\n      c = 0;\n\n  if (Math.abs(e[Ot.getElementIndex(o, i)]) > n) {\n    const u = e[Ot.getElementIndex(o, o)],\n          l = e[Ot.getElementIndex(i, i)],\n          h = e[Ot.getElementIndex(o, i)],\n          f = (u - l) / 2 / h;\n    let d;\n    f < 0 ? d = -1 / (-f + Math.sqrt(1 + f * f)) : d = 1 / (f + Math.sqrt(1 + f * f)), a = 1 / Math.sqrt(1 + d * d), c = d * a;\n  }\n\n  return X.IDENTITY.to(t), t[Ot.getElementIndex(i, i)] = t[Ot.getElementIndex(o, o)] = a, t[Ot.getElementIndex(o, i)] = c, t[Ot.getElementIndex(i, o)] = -c, t;\n}\n\nconst Vt = new A(),\n      Cd = new A(),\n      Ed = new A(),\n      Td = new A(),\n      bd = new A(),\n      _d = new X(),\n      wd = {\n  diagonal: new X(),\n  unitary: new X()\n};\n\nfunction Rd(e, t = new qe()) {\n  if (!e || e.length === 0) return t.halfAxes = new X([0, 0, 0, 0, 0, 0, 0, 0, 0]), t.center = new A(), t;\n  const n = e.length,\n        s = new A(0, 0, 0);\n\n  for (const v of e) s.add(v);\n\n  const r = 1 / n;\n  s.multiplyByScalar(r);\n  let i = 0,\n      o = 0,\n      a = 0,\n      c = 0,\n      u = 0,\n      l = 0;\n\n  for (const v of e) {\n    const L = Vt.copy(v).subtract(s);\n    i += L.x * L.x, o += L.x * L.y, a += L.x * L.z, c += L.y * L.y, u += L.y * L.z, l += L.z * L.z;\n  }\n\n  i *= r, o *= r, a *= r, c *= r, u *= r, l *= r;\n  const h = _d;\n  h[0] = i, h[1] = o, h[2] = a, h[3] = o, h[4] = c, h[5] = u, h[6] = a, h[7] = u, h[8] = l;\n  const {\n    unitary: f\n  } = Ad(h, wd),\n        d = t.halfAxes.copy(f);\n  let m = d.getColumn(0, Ed),\n      g = d.getColumn(1, Td),\n      y = d.getColumn(2, bd),\n      E = -Number.MAX_VALUE,\n      R = -Number.MAX_VALUE,\n      B = -Number.MAX_VALUE,\n      C = Number.MAX_VALUE,\n      M = Number.MAX_VALUE,\n      b = Number.MAX_VALUE;\n\n  for (const v of e) Vt.copy(v), E = Math.max(Vt.dot(m), E), R = Math.max(Vt.dot(g), R), B = Math.max(Vt.dot(y), B), C = Math.min(Vt.dot(m), C), M = Math.min(Vt.dot(g), M), b = Math.min(Vt.dot(y), b);\n\n  m = m.multiplyByScalar(0.5 * (C + E)), g = g.multiplyByScalar(0.5 * (M + R)), y = y.multiplyByScalar(0.5 * (b + B)), t.center.copy(m).add(g).add(y);\n  const O = Cd.set(E - C, R - M, B - b).multiplyByScalar(0.5),\n        F = new X([O[0], 0, 0, 0, O[1], 0, 0, 0, O[2]]);\n  return t.halfAxes.multiplyRight(F), t;\n}\n\nlet Ii = function (e) {\n  return e[e.ADD = 1] = \"ADD\", e[e.REPLACE = 2] = \"REPLACE\", e;\n}({}),\n    dn = function (e) {\n  return e.EMPTY = \"empty\", e.SCENEGRAPH = \"scenegraph\", e.POINTCLOUD = \"pointcloud\", e.MESH = \"mesh\", e;\n}({}),\n    Md = function (e) {\n  return e.I3S = \"I3S\", e.TILES3D = \"TILES3D\", e;\n}({}),\n    Qn = function (e) {\n  return e.GEOMETRIC_ERROR = \"geometricError\", e.MAX_SCREEN_THRESHOLD = \"maxScreenThreshold\", e;\n}({});\n\nconst va = \"4.1.1\",\n      _e = {\n  COMPOSITE: \"cmpt\",\n  POINT_CLOUD: \"pnts\",\n  BATCHED_3D_MODEL: \"b3dm\",\n  INSTANCED_3D_MODEL: \"i3dm\",\n  GEOMETRY: \"geom\",\n  VECTOR: \"vect\",\n  GLTF: \"glTF\"\n};\n\nfunction Oa(e, t, n) {\n  z(e instanceof ArrayBuffer);\n  const s = new TextDecoder(\"utf8\"),\n        r = new Uint8Array(e, t, n);\n  return s.decode(r);\n}\n\nfunction Sd(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n  const n = new DataView(e);\n  return `${String.fromCharCode(n.getUint8(t + 0))}${String.fromCharCode(n.getUint8(t + 1))}${String.fromCharCode(n.getUint8(t + 2))}${String.fromCharCode(n.getUint8(t + 3))}`;\n}\n\nconst Id = \"4.1.1\",\n      xd = {\n  name: \"Draco\",\n  id: \"draco\",\n  module: \"draco\",\n  version: Id,\n  worker: !0,\n  extensions: [\"drc\"],\n  mimeTypes: [\"application/octet-stream\"],\n  binary: !0,\n  tests: [\"DRACO\"],\n  options: {\n    draco: {\n      decoderType: typeof WebAssembly == \"object\" ? \"wasm\" : \"js\",\n      libraryPath: \"libs/\",\n      extraAttributes: {},\n      attributeNameEntry: void 0\n    }\n  }\n};\n\nfunction vd(e, t, n) {\n  const s = Fa(t.metadata),\n        r = [],\n        i = Od(t.attributes);\n\n  for (const o in e) {\n    const a = e[o],\n          c = xi(o, a, i[o]);\n    r.push(c);\n  }\n\n  if (n) {\n    const o = xi(\"indices\", n);\n    r.push(o);\n  }\n\n  return {\n    fields: r,\n    metadata: s\n  };\n}\n\nfunction Od(e) {\n  const t = {};\n\n  for (const n in e) {\n    const s = e[n];\n    t[s.name || \"undefined\"] = s;\n  }\n\n  return t;\n}\n\nfunction xi(e, t, n) {\n  const s = n ? Fa(n.metadata) : void 0;\n  return ih(e, t, s);\n}\n\nfunction Fa(e) {\n  Object.entries(e);\n  const t = {};\n\n  for (const n in e) t[`${n}.string`] = JSON.stringify(e[n]);\n\n  return t;\n}\n\nconst vi = {\n  POSITION: \"POSITION\",\n  NORMAL: \"NORMAL\",\n  COLOR: \"COLOR_0\",\n  TEX_COORD: \"TEXCOORD_0\"\n},\n      Fd = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n},\n      Dd = 4;\n\nclass Ld {\n  constructor(t) {\n    this.draco = void 0, this.decoder = void 0, this.metadataQuerier = void 0, this.draco = t, this.decoder = new this.draco.Decoder(), this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n\n  destroy() {\n    this.draco.destroy(this.decoder), this.draco.destroy(this.metadataQuerier);\n  }\n\n  parseSync(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const s = new this.draco.DecoderBuffer();\n    s.Init(new Int8Array(t), t.byteLength), this._disableAttributeTransforms(n);\n    const r = this.decoder.GetEncodedGeometryType(s),\n          i = r === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();\n\n    try {\n      let o;\n\n      switch (r) {\n        case this.draco.TRIANGULAR_MESH:\n          o = this.decoder.DecodeBufferToMesh(s, i);\n          break;\n\n        case this.draco.POINT_CLOUD:\n          o = this.decoder.DecodeBufferToPointCloud(s, i);\n          break;\n\n        default:\n          throw new Error(\"DRACO: Unknown geometry type.\");\n      }\n\n      if (!o.ok() || !i.ptr) {\n        const f = `DRACO decompression failed: ${o.error_msg()}`;\n        throw new Error(f);\n      }\n\n      const a = this._getDracoLoaderData(i, r, n),\n            c = this._getMeshData(i, a, n),\n            u = rh(c.attributes),\n            l = vd(c.attributes, a, c.indices);\n\n      return {\n        loader: \"draco\",\n        loaderData: a,\n        header: {\n          vertexCount: i.num_points(),\n          boundingBox: u\n        },\n        ...c,\n        schema: l\n      };\n    } finally {\n      this.draco.destroy(s), i && this.draco.destroy(i);\n    }\n  }\n\n  _getDracoLoaderData(t, n, s) {\n    const r = this._getTopLevelMetadata(t),\n          i = this._getDracoAttributes(t, s);\n\n    return {\n      geometry_type: n,\n      num_attributes: t.num_attributes(),\n      num_points: t.num_points(),\n      num_faces: t instanceof this.draco.Mesh ? t.num_faces() : 0,\n      metadata: r,\n      attributes: i\n    };\n  }\n\n  _getDracoAttributes(t, n) {\n    const s = {};\n\n    for (let r = 0; r < t.num_attributes(); r++) {\n      const i = this.decoder.GetAttribute(t, r),\n            o = this._getAttributeMetadata(t, r);\n\n      s[i.unique_id()] = {\n        unique_id: i.unique_id(),\n        attribute_type: i.attribute_type(),\n        data_type: i.data_type(),\n        num_components: i.num_components(),\n        byte_offset: i.byte_offset(),\n        byte_stride: i.byte_stride(),\n        normalized: i.normalized(),\n        attribute_index: r,\n        metadata: o\n      };\n\n      const a = this._getQuantizationTransform(i, n);\n\n      a && (s[i.unique_id()].quantization_transform = a);\n\n      const c = this._getOctahedronTransform(i, n);\n\n      c && (s[i.unique_id()].octahedron_transform = c);\n    }\n\n    return s;\n  }\n\n  _getMeshData(t, n, s) {\n    const r = this._getMeshAttributes(n, t, s);\n\n    if (!r.POSITION) throw new Error(\"DRACO: No position attribute found.\");\n    if (t instanceof this.draco.Mesh) switch (s.topology) {\n      case \"triangle-strip\":\n        return {\n          topology: \"triangle-strip\",\n          mode: 4,\n          attributes: r,\n          indices: {\n            value: this._getTriangleStripIndices(t),\n            size: 1\n          }\n        };\n\n      case \"triangle-list\":\n      default:\n        return {\n          topology: \"triangle-list\",\n          mode: 5,\n          attributes: r,\n          indices: {\n            value: this._getTriangleListIndices(t),\n            size: 1\n          }\n        };\n    }\n    return {\n      topology: \"point-list\",\n      mode: 0,\n      attributes: r\n    };\n  }\n\n  _getMeshAttributes(t, n, s) {\n    const r = {};\n\n    for (const i of Object.values(t.attributes)) {\n      const o = this._deduceAttributeName(i, s);\n\n      i.name = o;\n\n      const {\n        value: a,\n        size: c\n      } = this._getAttributeValues(n, i);\n\n      r[o] = {\n        value: a,\n        size: c,\n        byteOffset: i.byte_offset,\n        byteStride: i.byte_stride,\n        normalized: i.normalized\n      };\n    }\n\n    return r;\n  }\n\n  _getTriangleListIndices(t) {\n    const s = t.num_faces() * 3,\n          r = s * Dd,\n          i = this.draco._malloc(r);\n\n    try {\n      return this.decoder.GetTrianglesUInt32Array(t, r, i), new Uint32Array(this.draco.HEAPF32.buffer, i, s).slice();\n    } finally {\n      this.draco._free(i);\n    }\n  }\n\n  _getTriangleStripIndices(t) {\n    const n = new this.draco.DracoInt32Array();\n\n    try {\n      return this.decoder.GetTriangleStripsFromMesh(t, n), Nd(n);\n    } finally {\n      this.draco.destroy(n);\n    }\n  }\n\n  _getAttributeValues(t, n) {\n    const s = Fd[n.data_type],\n          r = n.num_components,\n          o = t.num_points() * r,\n          a = o * s.BYTES_PER_ELEMENT,\n          c = Pd(this.draco, s);\n    let u;\n\n    const l = this.draco._malloc(a);\n\n    try {\n      const h = this.decoder.GetAttribute(t, n.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(t, h, c, a, l), u = new s(this.draco.HEAPF32.buffer, l, o).slice();\n    } finally {\n      this.draco._free(l);\n    }\n\n    return {\n      value: u,\n      size: r\n    };\n  }\n\n  _deduceAttributeName(t, n) {\n    const s = t.unique_id;\n\n    for (const [o, a] of Object.entries(n.extraAttributes || {})) if (a === s) return o;\n\n    const r = t.attribute_type;\n\n    for (const o in vi) if (this.draco[o] === r) return vi[o];\n\n    const i = n.attributeNameEntry || \"name\";\n    return t.metadata[i] ? t.metadata[i].string : `CUSTOM_ATTRIBUTE_${s}`;\n  }\n\n  _getTopLevelMetadata(t) {\n    const n = this.decoder.GetMetadata(t);\n    return this._getDracoMetadata(n);\n  }\n\n  _getAttributeMetadata(t, n) {\n    const s = this.decoder.GetAttributeMetadata(t, n);\n    return this._getDracoMetadata(s);\n  }\n\n  _getDracoMetadata(t) {\n    if (!t || !t.ptr) return {};\n    const n = {},\n          s = this.metadataQuerier.NumEntries(t);\n\n    for (let r = 0; r < s; r++) {\n      const i = this.metadataQuerier.GetEntryName(t, r);\n      n[i] = this._getDracoMetadataField(t, i);\n    }\n\n    return n;\n  }\n\n  _getDracoMetadataField(t, n) {\n    const s = new this.draco.DracoInt32Array();\n\n    try {\n      this.metadataQuerier.GetIntEntryArray(t, n, s);\n      const r = Gd(s);\n      return {\n        int: this.metadataQuerier.GetIntEntry(t, n),\n        string: this.metadataQuerier.GetStringEntry(t, n),\n        double: this.metadataQuerier.GetDoubleEntry(t, n),\n        intArray: r\n      };\n    } finally {\n      this.draco.destroy(s);\n    }\n  }\n\n  _disableAttributeTransforms(t) {\n    const {\n      quantizedAttributes: n = [],\n      octahedronAttributes: s = []\n    } = t,\n          r = [...n, ...s];\n\n    for (const i of r) this.decoder.SkipAttributeTransform(this.draco[i]);\n  }\n\n  _getQuantizationTransform(t, n) {\n    const {\n      quantizedAttributes: s = []\n    } = n,\n          r = t.attribute_type();\n\n    if (s.map(o => this.decoder[o]).includes(r)) {\n      const o = new this.draco.AttributeQuantizationTransform();\n\n      try {\n        if (o.InitFromAttribute(t)) return {\n          quantization_bits: o.quantization_bits(),\n          range: o.range(),\n          min_values: new Float32Array([1, 2, 3]).map(a => o.min_value(a))\n        };\n      } finally {\n        this.draco.destroy(o);\n      }\n    }\n\n    return null;\n  }\n\n  _getOctahedronTransform(t, n) {\n    const {\n      octahedronAttributes: s = []\n    } = n,\n          r = t.attribute_type();\n\n    if (s.map(o => this.decoder[o]).includes(r)) {\n      const o = new this.draco.AttributeQuantizationTransform();\n\n      try {\n        if (o.InitFromAttribute(t)) return {\n          quantization_bits: o.quantization_bits()\n        };\n      } finally {\n        this.draco.destroy(o);\n      }\n    }\n\n    return null;\n  }\n\n}\n\nfunction Pd(e, t) {\n  switch (t) {\n    case Float32Array:\n      return e.DT_FLOAT32;\n\n    case Int8Array:\n      return e.DT_INT8;\n\n    case Int16Array:\n      return e.DT_INT16;\n\n    case Int32Array:\n      return e.DT_INT32;\n\n    case Uint8Array:\n      return e.DT_UINT8;\n\n    case Uint16Array:\n      return e.DT_UINT16;\n\n    case Uint32Array:\n      return e.DT_UINT32;\n\n    default:\n      return e.DT_INVALID;\n  }\n}\n\nfunction Gd(e) {\n  const t = e.size(),\n        n = new Int32Array(t);\n\n  for (let s = 0; s < t; s++) n[s] = e.GetValue(s);\n\n  return n;\n}\n\nfunction Nd(e) {\n  const t = e.size(),\n        n = new Int32Array(t);\n\n  for (let s = 0; s < t; s++) n[s] = e.GetValue(s);\n\n  return n;\n}\n\nconst Ud = \"1.5.6\",\n      Hd = \"1.4.1\",\n      As = `https://www.gstatic.com/draco/versioned/decoders/${Ud}`,\n      ft = {\n  DECODER: \"draco_wasm_wrapper.js\",\n  DECODER_WASM: \"draco_decoder.wasm\",\n  FALLBACK_DECODER: \"draco_decoder.js\",\n  ENCODER: \"draco_encoder.js\"\n},\n      ps = {\n  [ft.DECODER]: `${As}/${ft.DECODER}`,\n  [ft.DECODER_WASM]: `${As}/${ft.DECODER_WASM}`,\n  [ft.FALLBACK_DECODER]: `${As}/${ft.FALLBACK_DECODER}`,\n  [ft.ENCODER]: `https://raw.githubusercontent.com/google/draco/${Hd}/javascript/${ft.ENCODER}`\n};\nlet we;\n\nasync function Jd(e) {\n  const t = e.modules || {};\n  return t.draco3d ? we = we || t.draco3d.createDecoderModule({}).then(n => ({\n    draco: n\n  })) : we = we || Vd(e), await we;\n}\n\nasync function Vd(e) {\n  let t, n;\n\n  switch (e.draco && e.draco.decoderType) {\n    case \"js\":\n      t = await Zt(ps[ft.FALLBACK_DECODER], \"draco\", e, ft.FALLBACK_DECODER);\n      break;\n\n    case \"wasm\":\n    default:\n      [t, n] = await Promise.all([await Zt(ps[ft.DECODER], \"draco\", e, ft.DECODER), await Zt(ps[ft.DECODER_WASM], \"draco\", e, ft.DECODER_WASM)]);\n  }\n\n  return t = t || globalThis.DracoDecoderModule, await jd(t, n);\n}\n\nfunction jd(e, t) {\n  const n = {};\n  return t && (n.wasmBinary = t), new Promise(s => {\n    e({ ...n,\n      onModuleLoaded: r => s({\n        draco: r\n      })\n    });\n  });\n}\n\nconst Da = { ...xd,\n  parse: kd\n};\n\nasync function kd(e, t) {\n  const {\n    draco: n\n  } = await Jd(t),\n        s = new Ld(n);\n\n  try {\n    return s.parseSync(e, t == null ? void 0 : t.draco);\n  } finally {\n    s.destroy();\n  }\n}\n\nconst Kd = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6\n},\n      $ = {\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  DOUBLE: 5130\n},\n      G = { ...Kd,\n  ...$\n},\n      ys = {\n  [$.DOUBLE]: Float64Array,\n  [$.FLOAT]: Float32Array,\n  [$.UNSIGNED_SHORT]: Uint16Array,\n  [$.UNSIGNED_INT]: Uint32Array,\n  [$.UNSIGNED_BYTE]: Uint8Array,\n  [$.BYTE]: Int8Array,\n  [$.SHORT]: Int16Array,\n  [$.INT]: Int32Array\n},\n      zd = {\n  DOUBLE: $.DOUBLE,\n  FLOAT: $.FLOAT,\n  UNSIGNED_SHORT: $.UNSIGNED_SHORT,\n  UNSIGNED_INT: $.UNSIGNED_INT,\n  UNSIGNED_BYTE: $.UNSIGNED_BYTE,\n  BYTE: $.BYTE,\n  SHORT: $.SHORT,\n  INT: $.INT\n},\n      Bs = \"Failed to convert GL type\";\n\nclass Lt {\n  static fromTypedArray(t) {\n    t = ArrayBuffer.isView(t) ? t.constructor : t;\n\n    for (const n in ys) if (ys[n] === t) return n;\n\n    throw new Error(Bs);\n  }\n\n  static fromName(t) {\n    const n = zd[t];\n    if (!n) throw new Error(Bs);\n    return n;\n  }\n\n  static getArrayType(t) {\n    switch (t) {\n      case $.UNSIGNED_SHORT_5_6_5:\n      case $.UNSIGNED_SHORT_4_4_4_4:\n      case $.UNSIGNED_SHORT_5_5_5_1:\n        return Uint16Array;\n\n      default:\n        const n = ys[t];\n        if (!n) throw new Error(Bs);\n        return n;\n    }\n  }\n\n  static getByteSize(t) {\n    return Lt.getArrayType(t).BYTES_PER_ELEMENT;\n  }\n\n  static validate(t) {\n    return !!Lt.getArrayType(t);\n  }\n\n  static createTypedArray(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,\n        r = arguments.length > 3 ? arguments[3] : void 0;\n    r === void 0 && (r = (n.byteLength - s) / Lt.getByteSize(t));\n    const i = Lt.getArrayType(t);\n    return new i(n, s, r);\n  }\n\n}\n\nfunction Wd(e, t) {\n  if (!e) throw new Error(`math.gl assertion failed. ${t}`);\n}\n\nfunction Xd(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];\n  const n = e >> 11 & 31,\n        s = e >> 5 & 63,\n        r = e & 31;\n  return t[0] = n << 3, t[1] = s << 2, t[2] = r << 3, t;\n}\n\nnew Wn();\nnew A();\nnew Wn();\nnew Wn();\n\nfunction Oi(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 255;\n  return mh(e, 0, t) / t * 2 - 1;\n}\n\nfunction Fi(e) {\n  return e < 0 ? -1 : 1;\n}\n\nfunction Qd(e, t, n, s) {\n  if (Wd(s), e < 0 || e > n || t < 0 || t > n) throw new Error(`x and y must be unsigned normalized integers between 0 and ${n}`);\n\n  if (s.x = Oi(e, n), s.y = Oi(t, n), s.z = 1 - (Math.abs(s.x) + Math.abs(s.y)), s.z < 0) {\n    const r = s.x;\n    s.x = (1 - Math.abs(s.y)) * Fi(r), s.y = (1 - Math.abs(r)) * Fi(s.y);\n  }\n\n  return s.normalize();\n}\n\nfunction qd(e, t, n) {\n  return Qd(e, t, 255, n);\n}\n\nclass br {\n  constructor(t, n) {\n    this.json = void 0, this.buffer = void 0, this.featuresLength = 0, this._cachedTypedArrays = {}, this.json = t, this.buffer = n;\n  }\n\n  getExtension(t) {\n    return this.json.extensions && this.json.extensions[t];\n  }\n\n  hasProperty(t) {\n    return !!this.json[t];\n  }\n\n  getGlobalProperty(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : G.UNSIGNED_INT,\n        s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n    const r = this.json[t];\n    return r && Number.isFinite(r.byteOffset) ? this._getTypedArrayFromBinary(t, n, s, 1, r.byteOffset) : r;\n  }\n\n  getPropertyArray(t, n, s) {\n    const r = this.json[t];\n    return r && Number.isFinite(r.byteOffset) ? (\"componentType\" in r && (n = Lt.fromName(r.componentType)), this._getTypedArrayFromBinary(t, n, s, this.featuresLength, r.byteOffset)) : this._getTypedArrayFromArray(t, n, r);\n  }\n\n  getProperty(t, n, s, r, i) {\n    const o = this.json[t];\n    if (!o) return o;\n    const a = this.getPropertyArray(t, n, s);\n    if (s === 1) return a[r];\n\n    for (let c = 0; c < s; ++c) i[c] = a[s * r + c];\n\n    return i;\n  }\n\n  _getTypedArrayFromBinary(t, n, s, r, i) {\n    const o = this._cachedTypedArrays;\n    let a = o[t];\n    return a || (a = Lt.createTypedArray(n, this.buffer.buffer, this.buffer.byteOffset + i, r * s), o[t] = a), a;\n  }\n\n  _getTypedArrayFromArray(t, n, s) {\n    const r = this._cachedTypedArrays;\n    let i = r[t];\n    return i || (i = Lt.createTypedArray(n, s), r[t] = i), i;\n  }\n\n}\n\nconst Yd = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n},\n      $d = {\n  SCALAR: (e, t) => e[t],\n  VEC2: (e, t) => [e[2 * t + 0], e[2 * t + 1]],\n  VEC3: (e, t) => [e[3 * t + 0], e[3 * t + 1], e[3 * t + 2]],\n  VEC4: (e, t) => [e[4 * t + 0], e[4 * t + 1], e[4 * t + 2], e[4 * t + 3]],\n  MAT2: (e, t) => [e[4 * t + 0], e[4 * t + 1], e[4 * t + 2], e[4 * t + 3]],\n  MAT3: (e, t) => [e[9 * t + 0], e[9 * t + 1], e[9 * t + 2], e[9 * t + 3], e[9 * t + 4], e[9 * t + 5], e[9 * t + 6], e[9 * t + 7], e[9 * t + 8]],\n  MAT4: (e, t) => [e[16 * t + 0], e[16 * t + 1], e[16 * t + 2], e[16 * t + 3], e[16 * t + 4], e[16 * t + 5], e[16 * t + 6], e[16 * t + 7], e[16 * t + 8], e[16 * t + 9], e[16 * t + 10], e[16 * t + 11], e[16 * t + 12], e[16 * t + 13], e[16 * t + 14], e[16 * t + 15]]\n},\n      Zd = {\n  SCALAR: (e, t, n) => {\n    t[n] = e;\n  },\n  VEC2: (e, t, n) => {\n    t[2 * n + 0] = e[0], t[2 * n + 1] = e[1];\n  },\n  VEC3: (e, t, n) => {\n    t[3 * n + 0] = e[0], t[3 * n + 1] = e[1], t[3 * n + 2] = e[2];\n  },\n  VEC4: (e, t, n) => {\n    t[4 * n + 0] = e[0], t[4 * n + 1] = e[1], t[4 * n + 2] = e[2], t[4 * n + 3] = e[3];\n  },\n  MAT2: (e, t, n) => {\n    t[4 * n + 0] = e[0], t[4 * n + 1] = e[1], t[4 * n + 2] = e[2], t[4 * n + 3] = e[3];\n  },\n  MAT3: (e, t, n) => {\n    t[9 * n + 0] = e[0], t[9 * n + 1] = e[1], t[9 * n + 2] = e[2], t[9 * n + 3] = e[3], t[9 * n + 4] = e[4], t[9 * n + 5] = e[5], t[9 * n + 6] = e[6], t[9 * n + 7] = e[7], t[9 * n + 8] = e[8], t[9 * n + 9] = e[9];\n  },\n  MAT4: (e, t, n) => {\n    t[16 * n + 0] = e[0], t[16 * n + 1] = e[1], t[16 * n + 2] = e[2], t[16 * n + 3] = e[3], t[16 * n + 4] = e[4], t[16 * n + 5] = e[5], t[16 * n + 6] = e[6], t[16 * n + 7] = e[7], t[16 * n + 8] = e[8], t[16 * n + 9] = e[9], t[16 * n + 10] = e[10], t[16 * n + 11] = e[11], t[16 * n + 12] = e[12], t[16 * n + 13] = e[13], t[16 * n + 14] = e[14], t[16 * n + 15] = e[15];\n  }\n};\n\nfunction tm(e, t, n, s) {\n  const {\n    componentType: r\n  } = e;\n  z(e.componentType);\n  const i = typeof r == \"string\" ? Lt.fromName(r) : r,\n        o = Yd[e.type],\n        a = $d[e.type],\n        c = Zd[e.type];\n  return n += e.byteOffset, {\n    values: Lt.createTypedArray(i, t, n, o * s),\n    type: i,\n    size: o,\n    unpacker: a,\n    packer: c\n  };\n}\n\nconst Ft = e => e !== void 0;\n\nfunction em(e, t, n) {\n  if (!t) return null;\n  let s = e.getExtension(\"3DTILES_batch_table_hierarchy\");\n  const r = t.HIERARCHY;\n  return r && (console.warn(\"3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.\"), t.extensions = t.extensions || {}, t.extensions[\"3DTILES_batch_table_hierarchy\"] = r, s = r), s ? nm(s, n) : null;\n}\n\nfunction nm(e, t) {\n  let n, s, r;\n  const i = e.instancesLength,\n        o = e.classes;\n  let a = e.classIds,\n      c = e.parentCounts,\n      u = e.parentIds,\n      l = i;\n  Ft(a.byteOffset) && (a.componentType = defaultValue(a.componentType, GL.UNSIGNED_SHORT), a.type = AttributeType.SCALAR, r = getBinaryAccessor(a), a = r.createArrayBufferView(t.buffer, t.byteOffset + a.byteOffset, i));\n  let h;\n  if (Ft(c)) for (Ft(c.byteOffset) && (c.componentType = defaultValue(c.componentType, GL.UNSIGNED_SHORT), c.type = AttributeType.SCALAR, r = getBinaryAccessor(c), c = r.createArrayBufferView(t.buffer, t.byteOffset + c.byteOffset, i)), h = new Uint16Array(i), l = 0, n = 0; n < i; ++n) h[n] = l, l += c[n];\n  Ft(u) && Ft(u.byteOffset) && (u.componentType = defaultValue(u.componentType, GL.UNSIGNED_SHORT), u.type = AttributeType.SCALAR, r = getBinaryAccessor(u), u = r.createArrayBufferView(t.buffer, t.byteOffset + u.byteOffset, l));\n  const f = o.length;\n\n  for (n = 0; n < f; ++n) {\n    const y = o[n].length,\n          E = o[n].instances,\n          R = getBinaryProperties(y, E, t);\n    o[n].instances = combine(R, E);\n  }\n\n  const d = new Array(f).fill(0),\n        m = new Uint16Array(i);\n\n  for (n = 0; n < i; ++n) s = a[n], m[n] = d[s], ++d[s];\n\n  const g = {\n    classes: o,\n    classIds: a,\n    classIndexes: m,\n    parentCounts: c,\n    parentIndexes: h,\n    parentIds: u\n  };\n  return im(g), g;\n}\n\nfunction Re(e, t, n) {\n  if (!e) return;\n  const s = e.parentCounts;\n  return e.parentIds ? n(e, t) : s > 0 ? sm(e, t, n) : rm(e, t, n);\n}\n\nfunction sm(e, t, n) {\n  const s = e.classIds,\n        r = e.parentCounts,\n        i = e.parentIds,\n        o = e.parentIndexes,\n        a = s.length,\n        c = scratchVisited;\n  c.length = Math.max(c.length, a);\n  const u = ++marker,\n        l = scratchStack;\n\n  for (l.length = 0, l.push(t); l.length > 0;) {\n    if (t = l.pop(), c[t] === u) continue;\n    c[t] = u;\n    const h = n(e, t);\n    if (Ft(h)) return h;\n    const f = r[t],\n          d = o[t];\n\n    for (let m = 0; m < f; ++m) {\n      const g = i[d + m];\n      g !== t && l.push(g);\n    }\n  }\n\n  return null;\n}\n\nfunction rm(e, t, n) {\n  let s = !0;\n\n  for (; s;) {\n    const r = n(e, t);\n    if (Ft(r)) return r;\n    const i = e.parentIds[t];\n    s = i !== t, t = i;\n  }\n\n  throw new Error(\"traverseHierarchySingleParent\");\n}\n\nfunction im(e) {\n  const n = e.classIds.length;\n\n  for (let s = 0; s < n; ++s) La(e, s, stack);\n}\n\nfunction La(e, t, n) {\n  const s = e.parentCounts,\n        r = e.parentIds,\n        i = e.parentIndexes,\n        a = e.classIds.length;\n  if (!Ft(r)) return;\n  assert(t < a, `Parent index ${t} exceeds the total number of instances: ${a}`), assert(n.indexOf(t) === -1, \"Circular dependency detected in the batch table hierarchy.\"), n.push(t);\n  const c = Ft(s) ? s[t] : 1,\n        u = Ft(s) ? i[t] : t;\n\n  for (let l = 0; l < c; ++l) {\n    const h = r[u + l];\n    h !== t && La(e, h, n);\n  }\n\n  n.pop(t);\n}\n\nfunction ut(e) {\n  return e != null;\n}\n\nconst mn = (e, t) => e,\n      om = {\n  HIERARCHY: !0,\n  extensions: !0,\n  extras: !0\n};\n\nclass Pa {\n  constructor(t, n, s) {\n    var r;\n    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    this.json = void 0, this.binary = void 0, this.featureCount = void 0, this._extensions = void 0, this._properties = void 0, this._binaryProperties = void 0, this._hierarchy = void 0, z(s >= 0), this.json = t || {}, this.binary = n, this.featureCount = s, this._extensions = ((r = this.json) === null || r === void 0 ? void 0 : r.extensions) || {}, this._properties = {};\n\n    for (const o in this.json) om[o] || (this._properties[o] = this.json[o]);\n\n    this._binaryProperties = this._initializeBinaryProperties(), i[\"3DTILES_batch_table_hierarchy\"] && (this._hierarchy = em(this, this.json, this.binary));\n  }\n\n  getExtension(t) {\n    return this.json && this.json.extensions && this.json.extensions[t];\n  }\n\n  memorySizeInBytes() {\n    return 0;\n  }\n\n  isClass(t, n) {\n    if (this._checkBatchId(t), z(typeof n == \"string\", n), this._hierarchy) {\n      const s = Re(this._hierarchy, t, (r, i) => {\n        const o = r.classIds[i];\n        return r.classes[o].name === n;\n      });\n      return ut(s);\n    }\n\n    return !1;\n  }\n\n  isExactClass(t, n) {\n    return z(typeof n == \"string\", n), this.getExactClassName(t) === n;\n  }\n\n  getExactClassName(t) {\n    if (this._checkBatchId(t), this._hierarchy) {\n      const n = this._hierarchy.classIds[t];\n      return this._hierarchy.classes[n].name;\n    }\n  }\n\n  hasProperty(t, n) {\n    return this._checkBatchId(t), z(typeof n == \"string\", n), ut(this._properties[n]) || this._hasPropertyInHierarchy(t, n);\n  }\n\n  getPropertyNames(t, n) {\n    this._checkBatchId(t), n = ut(n) ? n : [], n.length = 0;\n    const s = Object.keys(this._properties);\n    return n.push(...s), this._hierarchy && this._getPropertyNamesInHierarchy(t, n), n;\n  }\n\n  getProperty(t, n) {\n    if (this._checkBatchId(t), z(typeof n == \"string\", n), this._binaryProperties) {\n      const r = this._binaryProperties[n];\n      if (ut(r)) return this._getBinaryProperty(r, t);\n    }\n\n    const s = this._properties[n];\n    if (ut(s)) return mn(s[t]);\n\n    if (this._hierarchy) {\n      const r = this._getHierarchyProperty(t, n);\n\n      if (ut(r)) return r;\n    }\n  }\n\n  setProperty(t, n, s) {\n    const r = this.featureCount;\n\n    if (this._checkBatchId(t), z(typeof n == \"string\", n), this._binaryProperties) {\n      const o = this._binaryProperties[n];\n\n      if (o) {\n        this._setBinaryProperty(o, t, s);\n\n        return;\n      }\n    }\n\n    if (this._hierarchy && this._setHierarchyProperty(this, t, n, s)) return;\n    let i = this._properties[n];\n    ut(i) || (this._properties[n] = new Array(r), i = this._properties[n]), i[t] = mn(s);\n  }\n\n  _checkBatchId(t) {\n    if (!(t >= 0 && t < this.featureCount)) throw new Error(\"batchId not in range [0, featureCount - 1].\");\n  }\n\n  _getBinaryProperty(t, n) {\n    return t.unpack(t.typedArray, n);\n  }\n\n  _setBinaryProperty(t, n, s) {\n    t.pack(s, t.typedArray, n);\n  }\n\n  _initializeBinaryProperties() {\n    let t = null;\n\n    for (const n in this._properties) {\n      const s = this._properties[n],\n            r = this._initializeBinaryProperty(n, s);\n\n      r && (t = t || {}, t[n] = r);\n    }\n\n    return t;\n  }\n\n  _initializeBinaryProperty(t, n) {\n    if (\"byteOffset\" in n) {\n      const s = n;\n      z(this.binary, `Property ${t} requires a batch table binary.`), z(s.type, `Property ${t} requires a type.`);\n      const r = tm(s, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);\n      return {\n        typedArray: r.values,\n        componentCount: r.size,\n        unpack: r.unpacker,\n        pack: r.packer\n      };\n    }\n\n    return null;\n  }\n\n  _hasPropertyInHierarchy(t, n) {\n    if (!this._hierarchy) return !1;\n    const s = Re(this._hierarchy, t, (r, i) => {\n      const o = r.classIds[i],\n            a = r.classes[o].instances;\n      return ut(a[n]);\n    });\n    return ut(s);\n  }\n\n  _getPropertyNamesInHierarchy(t, n) {\n    Re(this._hierarchy, t, (s, r) => {\n      const i = s.classIds[r],\n            o = s.classes[i].instances;\n\n      for (const a in o) o.hasOwnProperty(a) && n.indexOf(a) === -1 && n.push(a);\n    });\n  }\n\n  _getHierarchyProperty(t, n) {\n    return Re(this._hierarchy, t, (s, r) => {\n      const i = s.classIds[r],\n            o = s.classes[i],\n            a = s.classIndexes[r],\n            c = o.instances[n];\n      return ut(c) ? ut(c.typedArray) ? this._getBinaryProperty(c, a) : mn(c[a]) : null;\n    });\n  }\n\n  _setHierarchyProperty(t, n, s, r) {\n    const i = Re(this._hierarchy, n, (o, a) => {\n      const c = o.classIds[a],\n            u = o.classes[c],\n            l = o.classIndexes[a],\n            h = u.instances[s];\n      return ut(h) ? (z(a === n, `Inherited property \"${s}\" is read-only.`), ut(h.typedArray) ? this._setBinaryProperty(h, l, r) : h[l] = mn(r), !0) : !1;\n    });\n    return ut(i);\n  }\n\n}\n\nconst Cs = 4;\n\nfunction qn(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  const s = new DataView(t);\n  if (e.magic = s.getUint32(n, !0), n += Cs, e.version = s.getUint32(n, !0), n += Cs, e.byteLength = s.getUint32(n, !0), n += Cs, e.version !== 1) throw new Error(`3D Tile Version ${e.version} not supported`);\n  return n;\n}\n\nconst le = 4,\n      Di = \"b3dm tile in legacy format.\";\n\nfunction _r(e, t, n) {\n  const s = new DataView(t);\n  let r;\n  e.header = e.header || {};\n  let i = s.getUint32(n, !0);\n  n += le;\n  let o = s.getUint32(n, !0);\n  n += le;\n  let a = s.getUint32(n, !0);\n  n += le;\n  let c = s.getUint32(n, !0);\n  return n += le, a >= 570425344 ? (n -= le * 2, r = i, a = o, c = 0, i = 0, o = 0, console.warn(Di)) : c >= 570425344 && (n -= le, r = a, a = i, c = o, i = 0, o = 0, console.warn(Di)), e.header.featureTableJsonByteLength = i, e.header.featureTableBinaryByteLength = o, e.header.batchTableJsonByteLength = a, e.header.batchTableBinaryByteLength = c, e.header.batchLength = r, n;\n}\n\nfunction wr(e, t, n, s) {\n  return n = am(e, t, n), n = cm(e, t, n), n;\n}\n\nfunction am(e, t, n, s) {\n  const {\n    featureTableJsonByteLength: r,\n    featureTableBinaryByteLength: i,\n    batchLength: o\n  } = e.header || {};\n\n  if (e.featureTableJson = {\n    BATCH_LENGTH: o || 0\n  }, r && r > 0) {\n    const a = Oa(t, n, r);\n    e.featureTableJson = JSON.parse(a);\n  }\n\n  return n += r || 0, e.featureTableBinary = new Uint8Array(t, n, i), n += i || 0, n;\n}\n\nfunction cm(e, t, n, s) {\n  const {\n    batchTableJsonByteLength: r,\n    batchTableBinaryByteLength: i\n  } = e.header || {};\n\n  if (r && r > 0) {\n    const o = Oa(t, n, r);\n    e.batchTableJson = JSON.parse(o), n += r, i && i > 0 && (e.batchTableBinary = new Uint8Array(t, n, i), e.batchTableBinary = new Uint8Array(e.batchTableBinary), n += i);\n  }\n\n  return n;\n}\n\nfunction Ga(e, t, n) {\n  if (!t && (!e || !e.batchIds || !n)) return null;\n  const {\n    batchIds: s,\n    isRGB565: r,\n    pointCount: i = 0\n  } = e;\n\n  if (s && n) {\n    const o = new Uint8ClampedArray(i * 3);\n\n    for (let a = 0; a < i; a++) {\n      const c = s[a],\n            l = n.getProperty(c, \"dimensions\").map(h => h * 255);\n      o[a * 3] = l[0], o[a * 3 + 1] = l[1], o[a * 3 + 2] = l[2];\n    }\n\n    return {\n      type: G.UNSIGNED_BYTE,\n      value: o,\n      size: 3,\n      normalized: !0\n    };\n  }\n\n  if (t && r) {\n    const o = new Uint8ClampedArray(i * 3);\n\n    for (let a = 0; a < i; a++) {\n      const c = Xd(t[a]);\n      o[a * 3] = c[0], o[a * 3 + 1] = c[1], o[a * 3 + 2] = c[2];\n    }\n\n    return {\n      type: G.UNSIGNED_BYTE,\n      value: o,\n      size: 3,\n      normalized: !0\n    };\n  }\n\n  return t && t.length === i * 3 ? {\n    type: G.UNSIGNED_BYTE,\n    value: t,\n    size: 3,\n    normalized: !0\n  } : {\n    type: G.UNSIGNED_BYTE,\n    value: t || new Uint8ClampedArray(),\n    size: 4,\n    normalized: !0\n  };\n}\n\nconst Li = new A();\n\nfunction um(e, t) {\n  if (!t) return null;\n\n  if (e.isOctEncoded16P) {\n    const n = new Float32Array((e.pointsLength || 0) * 3);\n\n    for (let s = 0; s < (e.pointsLength || 0); s++) qd(t[s * 2], t[s * 2 + 1], Li), Li.toArray(n, s * 3);\n\n    return {\n      type: G.FLOAT,\n      size: 2,\n      value: n\n    };\n  }\n\n  return {\n    type: G.FLOAT,\n    size: 2,\n    value: t\n  };\n}\n\nfunction lm(e, t, n) {\n  return e.isQuantized ? n[\"3d-tiles\"] && n[\"3d-tiles\"].decodeQuantizedPositions ? (e.isQuantized = !1, hm(e, t)) : {\n    type: G.UNSIGNED_SHORT,\n    value: t,\n    size: 3,\n    normalized: !0\n  } : t;\n}\n\nfunction hm(e, t) {\n  const n = new A(),\n        s = new Float32Array(e.pointCount * 3);\n\n  for (let r = 0; r < e.pointCount; r++) n.set(t[r * 3], t[r * 3 + 1], t[r * 3 + 2]).scale(1 / e.quantizedRange).multiply(e.quantizedVolumeScale).add(e.quantizedVolumeOffset).toArray(s, r * 3);\n\n  return s;\n}\n\nasync function fm(e, t, n, s, r) {\n  n = qn(e, t, n), n = _r(e, t, n), n = wr(e, t, n), dm(e);\n  const {\n    featureTable: i,\n    batchTable: o\n  } = mm(e);\n  return await Bm(e, i, o, s, r), gm(e, i, s), Am(e, i, o), pm(e, i), n;\n}\n\nfunction dm(e) {\n  e.attributes = {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, e.isQuantized = !1, e.isTranslucent = !1, e.isRGB565 = !1, e.isOctEncoded16P = !1;\n}\n\nfunction mm(e) {\n  const t = new br(e.featureTableJson, e.featureTableBinary),\n        n = t.getGlobalProperty(\"POINTS_LENGTH\");\n  if (!Number.isFinite(n)) throw new Error(\"POINTS_LENGTH must be defined\");\n  t.featuresLength = n, e.featuresLength = n, e.pointsLength = n, e.pointCount = n, e.rtcCenter = t.getGlobalProperty(\"RTC_CENTER\", G.FLOAT, 3);\n  const s = ym(e, t);\n  return {\n    featureTable: t,\n    batchTable: s\n  };\n}\n\nfunction gm(e, t, n) {\n  if (e.attributes = e.attributes || {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, !e.attributes.positions) {\n    if (t.hasProperty(\"POSITION\")) e.attributes.positions = t.getPropertyArray(\"POSITION\", G.FLOAT, 3);else if (t.hasProperty(\"POSITION_QUANTIZED\")) {\n      const s = t.getPropertyArray(\"POSITION_QUANTIZED\", G.UNSIGNED_SHORT, 3);\n      if (e.isQuantized = !0, e.quantizedRange = 65535, e.quantizedVolumeScale = t.getGlobalProperty(\"QUANTIZED_VOLUME_SCALE\", G.FLOAT, 3), !e.quantizedVolumeScale) throw new Error(\"QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\");\n      if (e.quantizedVolumeOffset = t.getGlobalProperty(\"QUANTIZED_VOLUME_OFFSET\", G.FLOAT, 3), !e.quantizedVolumeOffset) throw new Error(\"QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\");\n      e.attributes.positions = lm(e, s, n);\n    }\n  }\n\n  if (!e.attributes.positions) throw new Error(\"Either POSITION or POSITION_QUANTIZED must be defined.\");\n}\n\nfunction Am(e, t, n) {\n  if (e.attributes = e.attributes || {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, !e.attributes.colors) {\n    let s = null;\n    t.hasProperty(\"RGBA\") ? (s = t.getPropertyArray(\"RGBA\", G.UNSIGNED_BYTE, 4), e.isTranslucent = !0) : t.hasProperty(\"RGB\") ? s = t.getPropertyArray(\"RGB\", G.UNSIGNED_BYTE, 3) : t.hasProperty(\"RGB565\") && (s = t.getPropertyArray(\"RGB565\", G.UNSIGNED_SHORT, 1), e.isRGB565 = !0), e.attributes.colors = Ga(e, s, n);\n  }\n\n  t.hasProperty(\"CONSTANT_RGBA\") && (e.constantRGBA = t.getGlobalProperty(\"CONSTANT_RGBA\", G.UNSIGNED_BYTE, 4));\n}\n\nfunction pm(e, t) {\n  if (e.attributes = e.attributes || {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, !e.attributes.normals) {\n    let n = null;\n    t.hasProperty(\"NORMAL\") ? n = t.getPropertyArray(\"NORMAL\", G.FLOAT, 3) : t.hasProperty(\"NORMAL_OCT16P\") && (n = t.getPropertyArray(\"NORMAL_OCT16P\", G.UNSIGNED_BYTE, 2), e.isOctEncoded16P = !0), e.attributes.normals = um(e, n);\n  }\n}\n\nfunction ym(e, t) {\n  let n = null;\n\n  if (!e.batchIds && t.hasProperty(\"BATCH_ID\") && (e.batchIds = t.getPropertyArray(\"BATCH_ID\", G.UNSIGNED_SHORT, 1), e.batchIds)) {\n    const s = t.getGlobalProperty(\"BATCH_LENGTH\");\n    if (!s) throw new Error(\"Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.\");\n    const {\n      batchTableJson: r,\n      batchTableBinary: i\n    } = e;\n    n = new Pa(r, i, s);\n  }\n\n  return n;\n}\n\nasync function Bm(e, t, n, s, r) {\n  let i, o, a;\n  const c = e.batchTableJson && e.batchTableJson.extensions && e.batchTableJson.extensions[\"3DTILES_draco_point_compression\"];\n  c && (a = c.properties);\n  const u = t.getExtension(\"3DTILES_draco_point_compression\");\n\n  if (u) {\n    o = u.properties;\n    const h = u.byteOffset,\n          f = u.byteLength;\n    if (!o || !Number.isFinite(h) || !f) throw new Error(\"Draco properties, byteOffset, and byteLength must be defined\");\n    i = (e.featureTableBinary || []).slice(h, h + f), e.hasPositions = Number.isFinite(o.POSITION), e.hasColors = Number.isFinite(o.RGB) || Number.isFinite(o.RGBA), e.hasNormals = Number.isFinite(o.NORMAL), e.hasBatchIds = Number.isFinite(o.BATCH_ID), e.isTranslucent = Number.isFinite(o.RGBA);\n  }\n\n  if (!i) return !0;\n  const l = {\n    buffer: i,\n    properties: { ...o,\n      ...a\n    },\n    featureTableProperties: o,\n    batchTableProperties: a,\n    dequantizeInShader: !1\n  };\n  return await Cm(e, l, s, r);\n}\n\nasync function Cm(e, t, n, s) {\n  if (!s) return;\n  const r = { ...n,\n    draco: { ...(n == null ? void 0 : n.draco),\n      extraAttributes: t.batchTableProperties || {}\n    }\n  };\n  delete r[\"3d-tiles\"];\n  const i = await Ke(t.buffer, Da, r, s),\n        o = i.attributes.POSITION && i.attributes.POSITION.value,\n        a = i.attributes.COLOR_0 && i.attributes.COLOR_0.value,\n        c = i.attributes.NORMAL && i.attributes.NORMAL.value,\n        u = i.attributes.BATCH_ID && i.attributes.BATCH_ID.value,\n        l = o && i.attributes.POSITION.value.quantization,\n        h = c && i.attributes.NORMAL.value.quantization;\n\n  if (l) {\n    const d = i.POSITION.data.quantization,\n          m = d.range;\n    e.quantizedVolumeScale = new A(m, m, m), e.quantizedVolumeOffset = new A(d.minValues), e.quantizedRange = (1 << d.quantizationBits) - 1, e.isQuantizedDraco = !0;\n  }\n\n  h && (e.octEncodedRange = (1 << i.NORMAL.data.quantization.quantizationBits) - 1, e.isOctEncodedDraco = !0);\n  const f = {};\n  if (t.batchTableProperties) for (const d of Object.keys(t.batchTableProperties)) i.attributes[d] && i.attributes[d].value && (f[d.toLowerCase()] = i.attributes[d].value);\n  e.attributes = {\n    positions: o,\n    colors: Ga(e, a, void 0),\n    normals: c,\n    batchIds: u,\n    ...f\n  };\n}\n\nconst Em = \"4.1.1\";\nvar Es;\nconst Tm = (Es = globalThis.loaders) === null || Es === void 0 ? void 0 : Es.parseImageNode,\n      Xs = typeof Image < \"u\",\n      Qs = typeof ImageBitmap < \"u\",\n      bm = !!Tm,\n      qs = kn ? !0 : bm;\n\nfunction _m(e) {\n  switch (e) {\n    case \"auto\":\n      return Qs || Xs || qs;\n\n    case \"imagebitmap\":\n      return Qs;\n\n    case \"image\":\n      return Xs;\n\n    case \"data\":\n      return qs;\n\n    default:\n      throw new Error(`@loaders.gl/images: image ${e} not supported in this environment`);\n  }\n}\n\nfunction wm() {\n  if (Qs) return \"imagebitmap\";\n  if (Xs) return \"image\";\n  if (qs) return \"data\";\n  throw new Error(\"Install '@loaders.gl/polyfills' to parse images under Node.js\");\n}\n\nfunction Rm(e) {\n  const t = Mm(e);\n  if (!t) throw new Error(\"Not an image\");\n  return t;\n}\n\nfunction Na(e) {\n  switch (Rm(e)) {\n    case \"data\":\n      return e;\n\n    case \"image\":\n    case \"imagebitmap\":\n      const t = document.createElement(\"canvas\"),\n            n = t.getContext(\"2d\");\n      if (!n) throw new Error(\"getImageData\");\n      return t.width = e.width, t.height = e.height, n.drawImage(e, 0, 0), n.getImageData(0, 0, e.width, e.height);\n\n    default:\n      throw new Error(\"getImageData\");\n  }\n}\n\nfunction Mm(e) {\n  return typeof ImageBitmap < \"u\" && e instanceof ImageBitmap ? \"imagebitmap\" : typeof Image < \"u\" && e instanceof Image ? \"image\" : e && typeof e == \"object\" && e.data && e.width && e.height ? \"data\" : null;\n}\n\nconst Sm = /^data:image\\/svg\\+xml/,\n      Im = /\\.svg((\\?|#).*)?$/;\n\nfunction Rr(e) {\n  return e && (Sm.test(e) || Im.test(e));\n}\n\nfunction xm(e, t) {\n  if (Rr(t)) {\n    let s = new TextDecoder().decode(e);\n\n    try {\n      typeof unescape == \"function\" && typeof encodeURIComponent == \"function\" && (s = unescape(encodeURIComponent(s)));\n    } catch (i) {\n      throw new Error(i.message);\n    }\n\n    return `data:image/svg+xml;base64,${btoa(s)}`;\n  }\n\n  return Ua(e, t);\n}\n\nfunction Ua(e, t) {\n  if (Rr(t)) throw new Error(\"SVG cannot be parsed directly to imagebitmap\");\n  return new Blob([new Uint8Array(e)]);\n}\n\nasync function Ha(e, t, n) {\n  const s = xm(e, n),\n        r = self.URL || self.webkitURL,\n        i = typeof s != \"string\" && r.createObjectURL(s);\n\n  try {\n    return await vm(i || s, t);\n  } finally {\n    i && r.revokeObjectURL(i);\n  }\n}\n\nasync function vm(e, t) {\n  const n = new Image();\n  return n.src = e, t.image && t.image.decode && n.decode ? (await n.decode(), n) : await new Promise((s, r) => {\n    try {\n      n.onload = () => s(n), n.onerror = i => {\n        const o = i instanceof Error ? i.message : \"error\";\n        r(new Error(o));\n      };\n    } catch (i) {\n      r(i);\n    }\n  });\n}\n\nconst Om = {};\nlet Pi = !0;\n\nasync function Fm(e, t, n) {\n  let s;\n  Rr(n) ? s = await Ha(e, t, n) : s = Ua(e, n);\n  const r = t && t.imagebitmap;\n  return await Dm(s, r);\n}\n\nasync function Dm(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n  if ((Lm(t) || !Pi) && (t = null), t) try {\n    return await createImageBitmap(e, t);\n  } catch (n) {\n    console.warn(n), Pi = !1;\n  }\n  return await createImageBitmap(e);\n}\n\nfunction Lm(e) {\n  for (const t in e || Om) return !1;\n\n  return !0;\n}\n\nfunction Pm(e) {\n  return !Hm(e, \"ftyp\", 4) || !(e[8] & 96) ? null : Gm(e);\n}\n\nfunction Gm(e) {\n  switch (Nm(e, 8, 12).replace(\"\\0\", \" \").trim()) {\n    case \"avif\":\n    case \"avis\":\n      return {\n        extension: \"avif\",\n        mimeType: \"image/avif\"\n      };\n\n    default:\n      return null;\n  }\n}\n\nfunction Nm(e, t, n) {\n  return String.fromCharCode(...e.slice(t, n));\n}\n\nfunction Um(e) {\n  return [...e].map(t => t.charCodeAt(0));\n}\n\nfunction Hm(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  const s = Um(t);\n\n  for (let r = 0; r < s.length; ++r) if (s[r] !== e[r + n]) return !1;\n\n  return !0;\n}\n\nconst Dt = !1,\n      De = !0;\n\nfunction Mr(e) {\n  const t = Ye(e);\n  return Vm(t) || Km(t) || jm(t) || km(t) || Jm(t);\n}\n\nfunction Jm(e) {\n  const t = new Uint8Array(e instanceof DataView ? e.buffer : e),\n        n = Pm(t);\n  return n ? {\n    mimeType: n.mimeType,\n    width: 0,\n    height: 0\n  } : null;\n}\n\nfunction Vm(e) {\n  const t = Ye(e);\n  return t.byteLength >= 24 && t.getUint32(0, Dt) === 2303741511 ? {\n    mimeType: \"image/png\",\n    width: t.getUint32(16, Dt),\n    height: t.getUint32(20, Dt)\n  } : null;\n}\n\nfunction jm(e) {\n  const t = Ye(e);\n  return t.byteLength >= 10 && t.getUint32(0, Dt) === 1195984440 ? {\n    mimeType: \"image/gif\",\n    width: t.getUint16(6, De),\n    height: t.getUint16(8, De)\n  } : null;\n}\n\nfunction km(e) {\n  const t = Ye(e);\n  return t.byteLength >= 14 && t.getUint16(0, Dt) === 16973 && t.getUint32(2, De) === t.byteLength ? {\n    mimeType: \"image/bmp\",\n    width: t.getUint32(18, De),\n    height: t.getUint32(22, De)\n  } : null;\n}\n\nfunction Km(e) {\n  const t = Ye(e);\n  if (!(t.byteLength >= 3 && t.getUint16(0, Dt) === 65496 && t.getUint8(2) === 255)) return null;\n  const {\n    tableMarkers: s,\n    sofMarkers: r\n  } = zm();\n  let i = 2;\n\n  for (; i + 9 < t.byteLength;) {\n    const o = t.getUint16(i, Dt);\n    if (r.has(o)) return {\n      mimeType: \"image/jpeg\",\n      height: t.getUint16(i + 5, Dt),\n      width: t.getUint16(i + 7, Dt)\n    };\n    if (!s.has(o)) return null;\n    i += 2, i += t.getUint16(i, Dt);\n  }\n\n  return null;\n}\n\nfunction zm() {\n  const e = /* @__PURE__ */new Set([65499, 65476, 65484, 65501, 65534]);\n\n  for (let n = 65504; n < 65520; ++n) e.add(n);\n\n  return {\n    tableMarkers: e,\n    sofMarkers: /* @__PURE__ */new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502])\n  };\n}\n\nfunction Ye(e) {\n  if (e instanceof DataView) return e;\n  if (ArrayBuffer.isView(e)) return new DataView(e.buffer);\n  if (e instanceof ArrayBuffer) return new DataView(e);\n  throw new Error(\"toDataView\");\n}\n\nasync function Wm(e, t) {\n  var n;\n  const {\n    mimeType: s\n  } = Mr(e) || {},\n        r = (n = globalThis.loaders) === null || n === void 0 ? void 0 : n.parseImageNode;\n  return z(r), await r(e, s);\n}\n\nasync function Xm(e, t, n) {\n  t = t || {};\n  const r = (t.image || {}).type || \"auto\",\n        {\n    url: i\n  } = n || {},\n        o = Qm(r);\n  let a;\n\n  switch (o) {\n    case \"imagebitmap\":\n      a = await Fm(e, t, i);\n      break;\n\n    case \"image\":\n      a = await Ha(e, t, i);\n      break;\n\n    case \"data\":\n      a = await Wm(e);\n      break;\n\n    default:\n      z(!1);\n  }\n\n  return r === \"data\" && (a = Na(a)), a;\n}\n\nfunction Qm(e) {\n  switch (e) {\n    case \"auto\":\n    case \"data\":\n      return wm();\n\n    default:\n      return _m(e), e;\n  }\n}\n\nconst qm = [\"png\", \"jpg\", \"jpeg\", \"gif\", \"webp\", \"bmp\", \"ico\", \"svg\", \"avif\"],\n      Ym = [\"image/png\", \"image/jpeg\", \"image/gif\", \"image/webp\", \"image/avif\", \"image/bmp\", \"image/vnd.microsoft.icon\", \"image/svg+xml\"],\n      $m = {\n  image: {\n    type: \"auto\",\n    decode: !0\n  }\n},\n      Zm = {\n  id: \"image\",\n  module: \"images\",\n  name: \"Images\",\n  version: Em,\n  mimeTypes: Ym,\n  extensions: qm,\n  parse: Xm,\n  tests: [e => !!Mr(new DataView(e))],\n  options: $m\n},\n      Ts = {};\n\nfunction tg(e) {\n  if (Ts[e] === void 0) {\n    const t = kn ? ng(e) : eg(e);\n    Ts[e] = t;\n  }\n\n  return Ts[e];\n}\n\nfunction eg(e) {\n  var t, n;\n  const s = [\"image/png\", \"image/jpeg\", \"image/gif\"],\n        r = ((t = globalThis.loaders) === null || t === void 0 ? void 0 : t.imageFormatsNode) || s;\n  return !!((n = globalThis.loaders) === null || n === void 0 ? void 0 : n.parseImageNode) && r.includes(e);\n}\n\nfunction ng(e) {\n  switch (e) {\n    case \"image/avif\":\n    case \"image/webp\":\n      return sg(e);\n\n    default:\n      return !0;\n  }\n}\n\nfunction sg(e) {\n  try {\n    return document.createElement(\"canvas\").toDataURL(e).indexOf(`data:${e}`) === 0;\n  } catch {\n    return !1;\n  }\n}\n\nfunction yt(e, t) {\n  if (!e) throw new Error(t || \"assert failed: gltf\");\n}\n\nconst Ja = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n},\n      Va = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n},\n      rg = 1.33,\n      Gi = [\"SCALAR\", \"VEC2\", \"VEC3\", \"VEC4\"],\n      ig = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]],\n      og = new Map(ig),\n      ag = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n},\n      cg = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n},\n      ug = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\nfunction ja(e) {\n  return Gi[e - 1] || Gi[0];\n}\n\nfunction Sr(e) {\n  const t = og.get(e.constructor);\n  if (!t) throw new Error(\"Illegal typed array\");\n  return t;\n}\n\nfunction Ir(e, t) {\n  const n = ug[e.componentType],\n        s = ag[e.type],\n        r = cg[e.componentType],\n        i = e.count * s,\n        o = e.count * s * r;\n  yt(o >= 0 && o <= t.byteLength);\n  const a = Va[e.componentType],\n        c = Ja[e.type];\n  return {\n    ArrayType: n,\n    length: i,\n    byteLength: o,\n    componentByteSize: a,\n    numberOfComponentsInElement: c\n  };\n}\n\nfunction ka(e) {\n  let {\n    images: t,\n    bufferViews: n\n  } = e;\n  t = t || [], n = n || [];\n  const s = t.map(o => o.bufferView);\n  n = n.filter(o => !s.includes(o));\n  const r = n.reduce((o, a) => o + a.byteLength, 0),\n        i = t.reduce((o, a) => {\n    const {\n      width: c,\n      height: u\n    } = a.image;\n    return o + c * u;\n  }, 0);\n  return r + Math.ceil(4 * i * rg);\n}\n\nfunction lg(e, t, n) {\n  const s = e.bufferViews[n];\n  yt(s);\n  const r = s.buffer,\n        i = t[r];\n  yt(i);\n  const o = (s.byteOffset || 0) + i.byteOffset;\n  return new Uint8Array(i.arrayBuffer, o, s.byteLength);\n}\n\nfunction hg(e, t, n) {\n  var s, r;\n  const i = typeof n == \"number\" ? (s = e.accessors) === null || s === void 0 ? void 0 : s[n] : n;\n  if (!i) throw new Error(`No gltf accessor ${JSON.stringify(n)}`);\n  const o = (r = e.bufferViews) === null || r === void 0 ? void 0 : r[i.bufferView || 0];\n  if (!o) throw new Error(`No gltf buffer view for accessor ${o}`);\n  const {\n    arrayBuffer: a,\n    byteOffset: c\n  } = t[o.buffer],\n        u = (c || 0) + (i.byteOffset || 0) + (o.byteOffset || 0),\n        {\n    ArrayType: l,\n    length: h,\n    componentByteSize: f,\n    numberOfComponentsInElement: d\n  } = Ir(i, o),\n        m = f * d,\n        g = o.byteStride || m;\n  if (typeof o.byteStride > \"u\" || o.byteStride === m) return new l(a, u, h);\n  const y = new l(h);\n\n  for (let E = 0; E < i.count; E++) {\n    const R = new l(a, u + E * g, d);\n    y.set(R, E * d);\n  }\n\n  return y;\n}\n\nfunction fg() {\n  return {\n    asset: {\n      version: \"2.0\",\n      generator: \"loaders.gl\"\n    },\n    buffers: [],\n    extensions: {},\n    extensionsRequired: [],\n    extensionsUsed: []\n  };\n}\n\nclass ot {\n  constructor(t) {\n    this.gltf = void 0, this.sourceBuffers = void 0, this.byteLength = void 0, this.gltf = {\n      json: (t == null ? void 0 : t.json) || fg(),\n      buffers: (t == null ? void 0 : t.buffers) || [],\n      images: (t == null ? void 0 : t.images) || []\n    }, this.sourceBuffers = [], this.byteLength = 0, this.gltf.buffers && this.gltf.buffers[0] && (this.byteLength = this.gltf.buffers[0].byteLength, this.sourceBuffers = [this.gltf.buffers[0]]);\n  }\n\n  get json() {\n    return this.gltf.json;\n  }\n\n  getApplicationData(t) {\n    return this.json[t];\n  }\n\n  getExtraData(t) {\n    return (this.json.extras || {})[t];\n  }\n\n  hasExtension(t) {\n    const n = this.getUsedExtensions().find(r => r === t),\n          s = this.getRequiredExtensions().find(r => r === t);\n    return typeof n == \"string\" || typeof s == \"string\";\n  }\n\n  getExtension(t) {\n    const n = this.getUsedExtensions().find(r => r === t),\n          s = this.json.extensions || {};\n    return n ? s[t] : null;\n  }\n\n  getRequiredExtension(t) {\n    return this.getRequiredExtensions().find(s => s === t) ? this.getExtension(t) : null;\n  }\n\n  getRequiredExtensions() {\n    return this.json.extensionsRequired || [];\n  }\n\n  getUsedExtensions() {\n    return this.json.extensionsUsed || [];\n  }\n\n  getRemovedExtensions() {\n    return this.json.extensionsRemoved || [];\n  }\n\n  getObjectExtension(t, n) {\n    return (t.extensions || {})[n];\n  }\n\n  getScene(t) {\n    return this.getObject(\"scenes\", t);\n  }\n\n  getNode(t) {\n    return this.getObject(\"nodes\", t);\n  }\n\n  getSkin(t) {\n    return this.getObject(\"skins\", t);\n  }\n\n  getMesh(t) {\n    return this.getObject(\"meshes\", t);\n  }\n\n  getMaterial(t) {\n    return this.getObject(\"materials\", t);\n  }\n\n  getAccessor(t) {\n    return this.getObject(\"accessors\", t);\n  }\n\n  getTexture(t) {\n    return this.getObject(\"textures\", t);\n  }\n\n  getSampler(t) {\n    return this.getObject(\"samplers\", t);\n  }\n\n  getImage(t) {\n    return this.getObject(\"images\", t);\n  }\n\n  getBufferView(t) {\n    return this.getObject(\"bufferViews\", t);\n  }\n\n  getBuffer(t) {\n    return this.getObject(\"buffers\", t);\n  }\n\n  getObject(t, n) {\n    if (typeof n == \"object\") return n;\n    const s = this.json[t] && this.json[t][n];\n    if (!s) throw new Error(`glTF file error: Could not find ${t}[${n}]`);\n    return s;\n  }\n\n  getTypedArrayForBufferView(t) {\n    t = this.getBufferView(t);\n    const n = t.buffer,\n          s = this.gltf.buffers[n];\n    yt(s);\n    const r = (t.byteOffset || 0) + s.byteOffset;\n    return new Uint8Array(s.arrayBuffer, r, t.byteLength);\n  }\n\n  getTypedArrayForAccessor(t) {\n    const n = this.getAccessor(t);\n    return hg(this.gltf.json, this.gltf.buffers, n);\n  }\n\n  getTypedArrayForImageData(t) {\n    t = this.getAccessor(t);\n    const n = this.getBufferView(t.bufferView),\n          r = this.getBuffer(n.buffer).data,\n          i = n.byteOffset || 0;\n    return new Uint8Array(r, i, n.byteLength);\n  }\n\n  addApplicationData(t, n) {\n    return this.json[t] = n, this;\n  }\n\n  addExtraData(t, n) {\n    return this.json.extras = this.json.extras || {}, this.json.extras[t] = n, this;\n  }\n\n  addObjectExtension(t, n, s) {\n    return t.extensions = t.extensions || {}, t.extensions[n] = s, this.registerUsedExtension(n), this;\n  }\n\n  setObjectExtension(t, n, s) {\n    const r = t.extensions || {};\n    r[n] = s;\n  }\n\n  removeObjectExtension(t, n) {\n    const s = (t == null ? void 0 : t.extensions) || {};\n\n    if (s[n]) {\n      this.json.extensionsRemoved = this.json.extensionsRemoved || [];\n      const r = this.json.extensionsRemoved;\n      r.includes(n) || r.push(n);\n    }\n\n    delete s[n];\n  }\n\n  addExtension(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return yt(n), this.json.extensions = this.json.extensions || {}, this.json.extensions[t] = n, this.registerUsedExtension(t), n;\n  }\n\n  addRequiredExtension(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return yt(n), this.addExtension(t, n), this.registerRequiredExtension(t), n;\n  }\n\n  registerUsedExtension(t) {\n    this.json.extensionsUsed = this.json.extensionsUsed || [], this.json.extensionsUsed.find(n => n === t) || this.json.extensionsUsed.push(t);\n  }\n\n  registerRequiredExtension(t) {\n    this.registerUsedExtension(t), this.json.extensionsRequired = this.json.extensionsRequired || [], this.json.extensionsRequired.find(n => n === t) || this.json.extensionsRequired.push(t);\n  }\n\n  removeExtension(t) {\n    var n;\n\n    if ((n = this.json.extensions) !== null && n !== void 0 && n[t]) {\n      this.json.extensionsRemoved = this.json.extensionsRemoved || [];\n      const s = this.json.extensionsRemoved;\n      s.includes(t) || s.push(t);\n    }\n\n    this.json.extensions && delete this.json.extensions[t], this.json.extensionsRequired && this._removeStringFromArray(this.json.extensionsRequired, t), this.json.extensionsUsed && this._removeStringFromArray(this.json.extensionsUsed, t);\n  }\n\n  setDefaultScene(t) {\n    this.json.scene = t;\n  }\n\n  addScene(t) {\n    const {\n      nodeIndices: n\n    } = t;\n    return this.json.scenes = this.json.scenes || [], this.json.scenes.push({\n      nodes: n\n    }), this.json.scenes.length - 1;\n  }\n\n  addNode(t) {\n    const {\n      meshIndex: n,\n      matrix: s\n    } = t;\n    this.json.nodes = this.json.nodes || [];\n    const r = {\n      mesh: n\n    };\n    return s && (r.matrix = s), this.json.nodes.push(r), this.json.nodes.length - 1;\n  }\n\n  addMesh(t) {\n    const {\n      attributes: n,\n      indices: s,\n      material: r,\n      mode: i = 4\n    } = t,\n          a = {\n      primitives: [{\n        attributes: this._addAttributes(n),\n        mode: i\n      }]\n    };\n\n    if (s) {\n      const c = this._addIndices(s);\n\n      a.primitives[0].indices = c;\n    }\n\n    return Number.isFinite(r) && (a.primitives[0].material = r), this.json.meshes = this.json.meshes || [], this.json.meshes.push(a), this.json.meshes.length - 1;\n  }\n\n  addPointCloud(t) {\n    const s = {\n      primitives: [{\n        attributes: this._addAttributes(t),\n        mode: 0\n      }]\n    };\n    return this.json.meshes = this.json.meshes || [], this.json.meshes.push(s), this.json.meshes.length - 1;\n  }\n\n  addImage(t, n) {\n    const s = Mr(t),\n          r = n || (s == null ? void 0 : s.mimeType),\n          o = {\n      bufferView: this.addBufferView(t),\n      mimeType: r\n    };\n    return this.json.images = this.json.images || [], this.json.images.push(o), this.json.images.length - 1;\n  }\n\n  addBufferView(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,\n        s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.byteLength;\n    const r = t.byteLength;\n    yt(Number.isFinite(r)), this.sourceBuffers = this.sourceBuffers || [], this.sourceBuffers.push(t);\n    const i = {\n      buffer: n,\n      byteOffset: s,\n      byteLength: r\n    };\n    return this.byteLength += ze(r, 4), this.json.bufferViews = this.json.bufferViews || [], this.json.bufferViews.push(i), this.json.bufferViews.length - 1;\n  }\n\n  addAccessor(t, n) {\n    const s = {\n      bufferView: t,\n      type: ja(n.size),\n      componentType: n.componentType,\n      count: n.count,\n      max: n.max,\n      min: n.min\n    };\n    return this.json.accessors = this.json.accessors || [], this.json.accessors.push(s), this.json.accessors.length - 1;\n  }\n\n  addBinaryBuffer(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n      size: 3\n    };\n    const s = this.addBufferView(t);\n    let r = {\n      min: n.min,\n      max: n.max\n    };\n    (!r.min || !r.max) && (r = this._getAccessorMinMax(t, n.size));\n    const i = {\n      size: n.size,\n      componentType: Sr(t),\n      count: Math.round(t.length / n.size),\n      min: r.min,\n      max: r.max\n    };\n    return this.addAccessor(s, Object.assign(i, n));\n  }\n\n  addTexture(t) {\n    const {\n      imageIndex: n\n    } = t,\n          s = {\n      source: n\n    };\n    return this.json.textures = this.json.textures || [], this.json.textures.push(s), this.json.textures.length - 1;\n  }\n\n  addMaterial(t) {\n    return this.json.materials = this.json.materials || [], this.json.materials.push(t), this.json.materials.length - 1;\n  }\n\n  createBinaryChunk() {\n    var t, n;\n    this.gltf.buffers = [];\n    const s = this.byteLength,\n          r = new ArrayBuffer(s),\n          i = new Uint8Array(r);\n    let o = 0;\n\n    for (const a of this.sourceBuffers || []) o = Nu(a, i, o);\n\n    (t = this.json) !== null && t !== void 0 && (n = t.buffers) !== null && n !== void 0 && n[0] ? this.json.buffers[0].byteLength = s : this.json.buffers = [{\n      byteLength: s\n    }], this.gltf.binary = r, this.sourceBuffers = [r];\n  }\n\n  _removeStringFromArray(t, n) {\n    let s = !0;\n\n    for (; s;) {\n      const r = t.indexOf(n);\n      r > -1 ? t.splice(r, 1) : s = !1;\n    }\n  }\n\n  _addAttributes() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const n = {};\n\n    for (const s in t) {\n      const r = t[s],\n            i = this._getGltfAttributeName(s),\n            o = this.addBinaryBuffer(r.value, r);\n\n      n[i] = o;\n    }\n\n    return n;\n  }\n\n  _addIndices(t) {\n    return this.addBinaryBuffer(t, {\n      size: 1\n    });\n  }\n\n  _getGltfAttributeName(t) {\n    switch (t.toLowerCase()) {\n      case \"position\":\n      case \"positions\":\n      case \"vertices\":\n        return \"POSITION\";\n\n      case \"normal\":\n      case \"normals\":\n        return \"NORMAL\";\n\n      case \"color\":\n      case \"colors\":\n        return \"COLOR_0\";\n\n      case \"texcoord\":\n      case \"texcoords\":\n        return \"TEXCOORD_0\";\n\n      default:\n        return t;\n    }\n  }\n\n  _getAccessorMinMax(t, n) {\n    const s = {\n      min: null,\n      max: null\n    };\n    if (t.length < n) return s;\n    s.min = [], s.max = [];\n    const r = t.subarray(0, n);\n\n    for (const i of r) s.min.push(i), s.max.push(i);\n\n    for (let i = n; i < t.length; i += n) for (let o = 0; o < n; o++) s.min[0 + o] = Math.min(s.min[0 + o], t[i + o]), s.max[0 + o] = Math.max(s.max[0 + o], t[i + o]);\n\n    return s;\n  }\n\n}\n\nfunction Ni(e) {\n  return (e % 1 + 1) % 1;\n}\n\nconst Ka = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16,\n  BOOLEAN: 1,\n  STRING: 1,\n  ENUM: 1\n},\n      dg = {\n  INT8: Int8Array,\n  UINT8: Uint8Array,\n  INT16: Int16Array,\n  UINT16: Uint16Array,\n  INT32: Int32Array,\n  UINT32: Uint32Array,\n  INT64: BigInt64Array,\n  UINT64: BigUint64Array,\n  FLOAT32: Float32Array,\n  FLOAT64: Float64Array\n},\n      za = {\n  INT8: 1,\n  UINT8: 1,\n  INT16: 2,\n  UINT16: 2,\n  INT32: 4,\n  UINT32: 4,\n  INT64: 8,\n  UINT64: 8,\n  FLOAT32: 4,\n  FLOAT64: 8\n};\n\nfunction xr(e, t) {\n  return za[t] * Ka[e];\n}\n\nfunction Yn(e, t, n, s) {\n  if (n !== \"UINT8\" && n !== \"UINT16\" && n !== \"UINT32\" && n !== \"UINT64\") return null;\n  const r = e.getTypedArrayForBufferView(t),\n        i = $n(r, \"SCALAR\", n, s + 1);\n  return i instanceof BigInt64Array || i instanceof BigUint64Array ? null : i;\n}\n\nfunction $n(e, t, n) {\n  let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n  const r = Ka[t],\n        i = dg[n],\n        o = za[n],\n        a = s * r,\n        c = a * o;\n  let u = e.buffer,\n      l = e.byteOffset;\n  return l % o !== 0 && (u = new Uint8Array(u).slice(l, l + c).buffer, l = 0), new i(u, l, a);\n}\n\nfunction vr(e, t, n) {\n  var s, r;\n  const i = `TEXCOORD_${t.texCoord || 0}`,\n        o = n.attributes[i],\n        a = e.getTypedArrayForAccessor(o),\n        c = e.gltf.json,\n        u = t.index,\n        l = (s = c.textures) === null || s === void 0 || (r = s[u]) === null || r === void 0 ? void 0 : r.source;\n\n  if (typeof l < \"u\") {\n    var h, f, d;\n    const m = (h = c.images) === null || h === void 0 || (f = h[l]) === null || f === void 0 ? void 0 : f.mimeType,\n          g = (d = e.gltf.images) === null || d === void 0 ? void 0 : d[l];\n\n    if (g && typeof g.width < \"u\") {\n      const y = [];\n\n      for (let E = 0; E < a.length; E += 2) {\n        const R = mg(g, m, a, E, t.channels);\n        y.push(R);\n      }\n\n      return y;\n    }\n  }\n\n  return [];\n}\n\nfunction Wa(e, t, n, s, r) {\n  if (!(n != null && n.length)) return;\n  const i = [];\n\n  for (const l of n) {\n    let h = s.findIndex(f => f === l);\n    h === -1 && (h = s.push(l) - 1), i.push(h);\n  }\n\n  const o = new Uint32Array(i),\n        a = e.gltf.buffers.push({\n    arrayBuffer: o.buffer,\n    byteOffset: o.byteOffset,\n    byteLength: o.byteLength\n  }) - 1,\n        c = e.addBufferView(o, a, 0),\n        u = e.addAccessor(c, {\n    size: 1,\n    componentType: Sr(o),\n    count: o.length\n  });\n  r.attributes[t] = u;\n}\n\nfunction mg(e, t, n, s) {\n  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [0];\n  const i = {\n    r: {\n      offset: 0,\n      shift: 0\n    },\n    g: {\n      offset: 1,\n      shift: 8\n    },\n    b: {\n      offset: 2,\n      shift: 16\n    },\n    a: {\n      offset: 3,\n      shift: 24\n    }\n  },\n        o = n[s],\n        a = n[s + 1];\n  let c = 1;\n  t && (t.indexOf(\"image/jpeg\") !== -1 || t.indexOf(\"image/png\") !== -1) && (c = 4);\n  const u = gg(o, a, e, c);\n  let l = 0;\n\n  for (const h of r) {\n    const f = typeof h == \"number\" ? Object.values(i)[h] : i[h],\n          d = u + f.offset,\n          m = Na(e);\n    if (m.data.length <= d) throw new Error(`${m.data.length} <= ${d}`);\n    const g = m.data[d];\n    l |= g << f.shift;\n  }\n\n  return l;\n}\n\nfunction gg(e, t, n) {\n  let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n  const r = n.width,\n        i = Ni(e) * (r - 1),\n        o = Math.round(i),\n        a = n.height,\n        c = Ni(t) * (a - 1),\n        u = Math.round(c),\n        l = n.components ? n.components : s;\n  return (u * r + o) * l;\n}\n\nfunction Xa(e, t, n, s, r) {\n  const i = [];\n\n  for (let o = 0; o < t; o++) {\n    const a = n[o],\n          c = n[o + 1] - n[o];\n    if (c + a > s) break;\n    const u = a / r,\n          l = c / r;\n    i.push(e.slice(u, u + l));\n  }\n\n  return i;\n}\n\nfunction Qa(e, t, n) {\n  const s = [];\n\n  for (let r = 0; r < t; r++) {\n    const i = r * n;\n    s.push(e.slice(i, i + n));\n  }\n\n  return s;\n}\n\nfunction qa(e, t, n, s) {\n  if (n) throw new Error(\"Not implemented - arrayOffsets for strings is specified\");\n\n  if (s) {\n    const r = [],\n          i = new TextDecoder(\"utf8\");\n    let o = 0;\n\n    for (let a = 0; a < e; a++) {\n      const c = s[a + 1] - s[a];\n\n      if (c + o <= t.length) {\n        const u = t.subarray(o, c + o),\n              l = i.decode(u);\n        r.push(l), o += c;\n      }\n    }\n\n    return r;\n  }\n\n  return [];\n}\n\nconst Ya = \"EXT_mesh_features\",\n      Ag = Ya;\n\nasync function pg(e, t) {\n  const n = new ot(e);\n  yg(n, t);\n}\n\nfunction yg(e, t) {\n  const n = e.gltf.json;\n  if (n.meshes) for (const s of n.meshes) for (const r of s.primitives) Bg(e, r, t);\n}\n\nfunction Bg(e, t, n) {\n  var s, r;\n  if (!(n != null && (s = n.gltf) !== null && s !== void 0 && s.loadBuffers)) return;\n  const i = (r = t.extensions) === null || r === void 0 ? void 0 : r[Ya],\n        o = i == null ? void 0 : i.featureIds;\n  if (o) for (const c of o) {\n    var a;\n    let u;\n\n    if (typeof c.attribute < \"u\") {\n      const l = `_FEATURE_ID_${c.attribute}`,\n            h = t.attributes[l];\n      u = e.getTypedArrayForAccessor(h);\n    } else typeof c.texture < \"u\" && n !== null && n !== void 0 && (a = n.gltf) !== null && a !== void 0 && a.loadImages ? u = vr(e, c.texture, t) : u = [];\n\n    c.data = u;\n  }\n}\n\nconst Cg = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  decode: pg,\n  name: Ag\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      Or = \"EXT_structural_metadata\",\n      Eg = Or;\n\nasync function Tg(e, t) {\n  const n = new ot(e);\n  bg(n, t);\n}\n\nfunction bg(e, t) {\n  var n, s;\n  if (!((n = t.gltf) !== null && n !== void 0 && n.loadBuffers)) return;\n  const r = e.getExtension(Or);\n  r && ((s = t.gltf) !== null && s !== void 0 && s.loadImages && _g(e, r), wg(e, r));\n}\n\nfunction _g(e, t) {\n  const n = t.propertyTextures,\n        s = e.gltf.json;\n  if (n && s.meshes) for (const r of s.meshes) for (const i of r.primitives) Mg(e, n, i, t);\n}\n\nfunction wg(e, t) {\n  const n = t.schema;\n  if (!n) return;\n  const s = n.classes,\n        r = t.propertyTables;\n  if (s && r) for (const i in s) {\n    const o = Rg(r, i);\n    o && Ig(e, n, o);\n  }\n}\n\nfunction Rg(e, t) {\n  for (const n of e) if (n.class === t) return n;\n\n  return null;\n}\n\nfunction Mg(e, t, n, s) {\n  var r;\n  if (!t) return;\n  const i = (r = n.extensions) === null || r === void 0 ? void 0 : r[Or],\n        o = i == null ? void 0 : i.propertyTextures;\n  if (o) for (const a of o) {\n    const c = t[a];\n    Sg(e, c, n, s);\n  }\n}\n\nfunction Sg(e, t, n, s) {\n  if (!t.properties) return;\n  s.dataAttributeNames || (s.dataAttributeNames = []);\n  const r = t.class;\n\n  for (const o in t.properties) {\n    var i;\n    const a = `${r}_${o}`,\n          c = (i = t.properties) === null || i === void 0 ? void 0 : i[o];\n    if (!c) continue;\n    c.data || (c.data = []);\n    const u = c.data,\n          l = vr(e, c, n);\n    l !== null && (Wa(e, a, l, u, n), c.data = u, s.dataAttributeNames.push(a));\n  }\n}\n\nfunction Ig(e, t, n) {\n  var s;\n  const r = (s = t.classes) === null || s === void 0 ? void 0 : s[n.class];\n  if (!r) throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${n.class}`);\n  const i = n.count;\n\n  for (const a in r.properties) {\n    var o;\n    const c = r.properties[a],\n          u = (o = n.properties) === null || o === void 0 ? void 0 : o[a];\n\n    if (u) {\n      const l = xg(e, t, c, i, u);\n      u.data = l;\n    }\n  }\n}\n\nfunction xg(e, t, n, s, r) {\n  let i = [];\n  const o = r.values,\n        a = e.getTypedArrayForBufferView(o),\n        c = vg(e, n, r, s),\n        u = Og(e, r, s);\n\n  switch (n.type) {\n    case \"SCALAR\":\n    case \"VEC2\":\n    case \"VEC3\":\n    case \"VEC4\":\n    case \"MAT2\":\n    case \"MAT3\":\n    case \"MAT4\":\n      {\n        i = Fg(n, s, a, c);\n        break;\n      }\n\n    case \"BOOLEAN\":\n      throw new Error(`Not implemented - classProperty.type=${n.type}`);\n\n    case \"STRING\":\n      {\n        i = qa(s, a, c, u);\n        break;\n      }\n\n    case \"ENUM\":\n      {\n        i = Dg(t, n, s, a, c);\n        break;\n      }\n\n    default:\n      throw new Error(`Unknown classProperty type ${n.type}`);\n  }\n\n  return i;\n}\n\nfunction vg(e, t, n, s) {\n  return t.array && typeof t.count > \"u\" && typeof n.arrayOffsets < \"u\" ? Yn(e, n.arrayOffsets, n.arrayOffsetType || \"UINT32\", s) : null;\n}\n\nfunction Og(e, t, n) {\n  return typeof t.stringOffsets < \"u\" ? Yn(e, t.stringOffsets, t.stringOffsetType || \"UINT32\", n) : null;\n}\n\nfunction Fg(e, t, n, s) {\n  const r = e.array,\n        i = e.count,\n        o = xr(e.type, e.componentType),\n        a = n.byteLength / o;\n  let c;\n  return e.componentType ? c = $n(n, e.type, e.componentType, a) : c = n, r ? s ? Xa(c, t, s, n.length, o) : i ? Qa(c, t, i) : [] : c;\n}\n\nfunction Dg(e, t, n, s, r) {\n  var i;\n  const o = t.enumType;\n  if (!o) throw new Error(\"Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM\");\n  const a = (i = e.enums) === null || i === void 0 ? void 0 : i[o];\n  if (!a) throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${o}`);\n  const c = a.valueType || \"UINT16\",\n        u = xr(t.type, c),\n        l = s.byteLength / u;\n  let h = $n(s, t.type, c, l);\n\n  if (h || (h = s), t.array) {\n    if (r) return Lg({\n      valuesData: h,\n      numberOfElements: n,\n      arrayOffsets: r,\n      valuesDataBytesLength: s.length,\n      elementSize: u,\n      enumEntry: a\n    });\n    const f = t.count;\n    return f ? Pg(h, n, f, a) : [];\n  }\n\n  return Fr(h, 0, n, a);\n}\n\nfunction Lg(e) {\n  const {\n    valuesData: t,\n    numberOfElements: n,\n    arrayOffsets: s,\n    valuesDataBytesLength: r,\n    elementSize: i,\n    enumEntry: o\n  } = e,\n        a = [];\n\n  for (let c = 0; c < n; c++) {\n    const u = s[c],\n          l = s[c + 1] - s[c];\n    if (l + u > r) break;\n    const h = u / i,\n          f = l / i,\n          d = Fr(t, h, f, o);\n    a.push(d);\n  }\n\n  return a;\n}\n\nfunction Pg(e, t, n, s) {\n  const r = [];\n\n  for (let i = 0; i < t; i++) {\n    const o = n * i,\n          a = Fr(e, o, n, s);\n    r.push(a);\n  }\n\n  return r;\n}\n\nfunction Fr(e, t, n, s) {\n  const r = [];\n\n  for (let i = 0; i < n; i++) if (e instanceof BigInt64Array || e instanceof BigUint64Array) r.push(\"\");else {\n    const o = e[t + i],\n          a = Gg(s, o);\n    a ? r.push(a.name) : r.push(\"\");\n  }\n\n  return r;\n}\n\nfunction Gg(e, t) {\n  for (const n of e.values) if (n.value === t) return n;\n\n  return null;\n}\n\nconst Ng = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  decode: Tg,\n  name: Eg\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      $a = \"EXT_feature_metadata\",\n      Ug = $a;\n\nasync function Hg(e, t) {\n  const n = new ot(e);\n  Jg(n, t);\n}\n\nfunction Jg(e, t) {\n  var n, s;\n  if (!((n = t.gltf) !== null && n !== void 0 && n.loadBuffers)) return;\n  const r = e.getExtension($a);\n  r && ((s = t.gltf) !== null && s !== void 0 && s.loadImages && Vg(e, r), jg(e, r));\n}\n\nfunction Vg(e, t) {\n  const n = t.schema;\n  if (!n) return;\n  const s = n.classes,\n        {\n    featureTextures: r\n  } = t;\n  if (s && r) for (const i in s) {\n    const o = s[i],\n          a = Kg(r, i);\n    a && Wg(e, a, o);\n  }\n}\n\nfunction jg(e, t) {\n  const n = t.schema;\n  if (!n) return;\n  const s = n.classes,\n        r = t.featureTables;\n  if (s && r) for (const i in s) {\n    const o = kg(r, i);\n    o && zg(e, n, o);\n  }\n}\n\nfunction kg(e, t) {\n  for (const n in e) {\n    const s = e[n];\n    if (s.class === t) return s;\n  }\n\n  return null;\n}\n\nfunction Kg(e, t) {\n  for (const n in e) {\n    const s = e[n];\n    if (s.class === t) return s;\n  }\n\n  return null;\n}\n\nfunction zg(e, t, n) {\n  var s;\n  if (!n.class) return;\n  const r = (s = t.classes) === null || s === void 0 ? void 0 : s[n.class];\n  if (!r) throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${n.class}`);\n  const i = n.count;\n\n  for (const a in r.properties) {\n    var o;\n    const c = r.properties[a],\n          u = (o = n.properties) === null || o === void 0 ? void 0 : o[a];\n\n    if (u) {\n      const l = Xg(e, t, c, i, u);\n      u.data = l;\n    }\n  }\n}\n\nfunction Wg(e, t, n) {\n  const s = t.class;\n\n  for (const i in n.properties) {\n    var r;\n    const o = t == null || (r = t.properties) === null || r === void 0 ? void 0 : r[i];\n\n    if (o) {\n      const a = Zg(e, o, s);\n      o.data = a;\n    }\n  }\n}\n\nfunction Xg(e, t, n, s, r) {\n  let i = [];\n  const o = r.bufferView,\n        a = e.getTypedArrayForBufferView(o),\n        c = Qg(e, n, r, s),\n        u = qg(e, n, r, s);\n  return n.type === \"STRING\" || n.componentType === \"STRING\" ? i = qa(s, a, c, u) : Yg(n) && (i = $g(n, s, a, c)), i;\n}\n\nfunction Qg(e, t, n, s) {\n  return t.type === \"ARRAY\" && typeof t.componentCount > \"u\" && typeof n.arrayOffsetBufferView < \"u\" ? Yn(e, n.arrayOffsetBufferView, n.offsetType || \"UINT32\", s) : null;\n}\n\nfunction qg(e, t, n, s) {\n  return typeof n.stringOffsetBufferView < \"u\" ? Yn(e, n.stringOffsetBufferView, n.offsetType || \"UINT32\", s) : null;\n}\n\nfunction Yg(e) {\n  const t = [\"UINT8\", \"INT16\", \"UINT16\", \"INT32\", \"UINT32\", \"INT64\", \"UINT64\", \"FLOAT32\", \"FLOAT64\"];\n  return t.includes(e.type) || typeof e.componentType < \"u\" && t.includes(e.componentType);\n}\n\nfunction $g(e, t, n, s) {\n  const r = e.type === \"ARRAY\",\n        i = e.componentCount,\n        o = \"SCALAR\",\n        a = e.componentType || e.type,\n        c = xr(o, a),\n        u = n.byteLength / c,\n        l = $n(n, o, a, u);\n  return r ? s ? Xa(l, t, s, n.length, c) : i ? Qa(l, t, i) : [] : l;\n}\n\nfunction Zg(e, t, n) {\n  const s = e.gltf.json;\n  if (!s.meshes) return [];\n  const r = [];\n\n  for (const i of s.meshes) for (const o of i.primitives) t0(e, n, t, r, o);\n\n  return r;\n}\n\nfunction t0(e, t, n, s, r) {\n  const i = {\n    channels: n.channels,\n    ...n.texture\n  },\n        o = vr(e, i, r);\n  o && Wa(e, t, o, s, r);\n}\n\nconst e0 = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  decode: Hg,\n  name: Ug\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      n0 = \"4.1.1\",\n      s0 = \"4.1.1\",\n      Ln = {\n  TRANSCODER: \"basis_transcoder.js\",\n  TRANSCODER_WASM: \"basis_transcoder.wasm\",\n  ENCODER: \"basis_encoder.js\",\n  ENCODER_WASM: \"basis_encoder.wasm\"\n};\nlet bs;\n\nasync function Ui(e) {\n  const t = e.modules || {};\n  return t.basis ? t.basis : (bs = bs || r0(e), await bs);\n}\n\nasync function r0(e) {\n  let t = null,\n      n = null;\n  return [t, n] = await Promise.all([await Zt(Ln.TRANSCODER, \"textures\", e), await Zt(Ln.TRANSCODER_WASM, \"textures\", e)]), t = t || globalThis.BASIS, await i0(t, n);\n}\n\nfunction i0(e, t) {\n  const n = {};\n  return t && (n.wasmBinary = t), new Promise(s => {\n    e(n).then(r => {\n      const {\n        BasisFile: i,\n        initializeBasis: o\n      } = r;\n      o(), s({\n        BasisFile: i\n      });\n    });\n  });\n}\n\nlet _s;\n\nasync function Hi(e) {\n  const t = e.modules || {};\n  return t.basisEncoder ? t.basisEncoder : (_s = _s || o0(e), await _s);\n}\n\nasync function o0(e) {\n  let t = null,\n      n = null;\n  return [t, n] = await Promise.all([await Zt(Ln.ENCODER, \"textures\", e), await Zt(Ln.ENCODER_WASM, \"textures\", e)]), t = t || globalThis.BASIS, await a0(t, n);\n}\n\nfunction a0(e, t) {\n  const n = {};\n  return t && (n.wasmBinary = t), new Promise(s => {\n    e(n).then(r => {\n      const {\n        BasisFile: i,\n        KTX2File: o,\n        initializeBasis: a,\n        BasisEncoder: c\n      } = r;\n      a(), s({\n        BasisFile: i,\n        KTX2File: o,\n        BasisEncoder: c\n      });\n    });\n  });\n}\n\nconst he = {\n  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,\n  COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,\n  COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,\n  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,\n  COMPRESSED_R11_EAC: 37488,\n  COMPRESSED_SIGNED_R11_EAC: 37489,\n  COMPRESSED_RG11_EAC: 37490,\n  COMPRESSED_SIGNED_RG11_EAC: 37491,\n  COMPRESSED_RGB8_ETC2: 37492,\n  COMPRESSED_RGBA8_ETC2_EAC: 37493,\n  COMPRESSED_SRGB8_ETC2: 37494,\n  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,\n  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,\n  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,\n  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,\n  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,\n  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,\n  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,\n  COMPRESSED_RGB_ETC1_WEBGL: 36196,\n  COMPRESSED_RGB_ATC_WEBGL: 35986,\n  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,\n  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,\n  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,\n  COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,\n  COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,\n  COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,\n  COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,\n  COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,\n  COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,\n  COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,\n  COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,\n  COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,\n  COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,\n  COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,\n  COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,\n  COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,\n  COMPRESSED_RED_RGTC1_EXT: 36283,\n  COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,\n  COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,\n  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,\n  COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919\n},\n      c0 = [\"\", \"WEBKIT_\", \"MOZ_\"],\n      Ji = {\n  WEBGL_compressed_texture_s3tc: \"dxt\",\n  WEBGL_compressed_texture_s3tc_srgb: \"dxt-srgb\",\n  WEBGL_compressed_texture_etc1: \"etc1\",\n  WEBGL_compressed_texture_etc: \"etc2\",\n  WEBGL_compressed_texture_pvrtc: \"pvrtc\",\n  WEBGL_compressed_texture_atc: \"atc\",\n  WEBGL_compressed_texture_astc: \"astc\",\n  EXT_texture_compression_rgtc: \"rgtc\"\n};\nlet gn = null;\n\nfunction u0(e) {\n  if (!gn) {\n    e = e || l0() || void 0, gn = /* @__PURE__ */new Set();\n\n    for (const t of c0) for (const n in Ji) if (e && e.getExtension(`${t}${n}`)) {\n      const s = Ji[n];\n      gn.add(s);\n    }\n  }\n\n  return gn;\n}\n\nfunction l0() {\n  try {\n    return document.createElement(\"canvas\").getContext(\"webgl\");\n  } catch {\n    return null;\n  }\n}\n\nvar Vi, ji, ki, Ki, zi, Wi, Xi, Qi;\n(function (e) {\n  e[e.NONE = 0] = \"NONE\", e[e.BASISLZ = 1] = \"BASISLZ\", e[e.ZSTD = 2] = \"ZSTD\", e[e.ZLIB = 3] = \"ZLIB\";\n})(Vi || (Vi = {})), function (e) {\n  e[e.BASICFORMAT = 0] = \"BASICFORMAT\";\n}(ji || (ji = {})), function (e) {\n  e[e.UNSPECIFIED = 0] = \"UNSPECIFIED\", e[e.ETC1S = 163] = \"ETC1S\", e[e.UASTC = 166] = \"UASTC\";\n}(ki || (ki = {})), function (e) {\n  e[e.UNSPECIFIED = 0] = \"UNSPECIFIED\", e[e.SRGB = 1] = \"SRGB\";\n}(Ki || (Ki = {})), function (e) {\n  e[e.UNSPECIFIED = 0] = \"UNSPECIFIED\", e[e.LINEAR = 1] = \"LINEAR\", e[e.SRGB = 2] = \"SRGB\", e[e.ITU = 3] = \"ITU\", e[e.NTSC = 4] = \"NTSC\", e[e.SLOG = 5] = \"SLOG\", e[e.SLOG2 = 6] = \"SLOG2\";\n}(zi || (zi = {})), function (e) {\n  e[e.ALPHA_STRAIGHT = 0] = \"ALPHA_STRAIGHT\", e[e.ALPHA_PREMULTIPLIED = 1] = \"ALPHA_PREMULTIPLIED\";\n}(Wi || (Wi = {})), function (e) {\n  e[e.RGB = 0] = \"RGB\", e[e.RRR = 3] = \"RRR\", e[e.GGG = 4] = \"GGG\", e[e.AAA = 15] = \"AAA\";\n}(Xi || (Xi = {})), function (e) {\n  e[e.RGB = 0] = \"RGB\", e[e.RGBA = 3] = \"RGBA\", e[e.RRR = 4] = \"RRR\", e[e.RRRG = 5] = \"RRRG\";\n}(Qi || (Qi = {}));\nconst gt = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];\n\nfunction h0(e) {\n  const t = new Uint8Array(e);\n  return !(t.byteLength < gt.length || t[0] !== gt[0] || t[1] !== gt[1] || t[2] !== gt[2] || t[3] !== gt[3] || t[4] !== gt[4] || t[5] !== gt[5] || t[6] !== gt[6] || t[7] !== gt[7] || t[8] !== gt[8] || t[9] !== gt[9] || t[10] !== gt[10] || t[11] !== gt[11]);\n}\n\nconst f0 = {\n  etc1: {\n    basisFormat: 0,\n    compressed: !0,\n    format: he.COMPRESSED_RGB_ETC1_WEBGL\n  },\n  etc2: {\n    basisFormat: 1,\n    compressed: !0\n  },\n  bc1: {\n    basisFormat: 2,\n    compressed: !0,\n    format: he.COMPRESSED_RGB_S3TC_DXT1_EXT\n  },\n  bc3: {\n    basisFormat: 3,\n    compressed: !0,\n    format: he.COMPRESSED_RGBA_S3TC_DXT5_EXT\n  },\n  bc4: {\n    basisFormat: 4,\n    compressed: !0\n  },\n  bc5: {\n    basisFormat: 5,\n    compressed: !0\n  },\n  \"bc7-m6-opaque-only\": {\n    basisFormat: 6,\n    compressed: !0\n  },\n  \"bc7-m5\": {\n    basisFormat: 7,\n    compressed: !0\n  },\n  \"pvrtc1-4-rgb\": {\n    basisFormat: 8,\n    compressed: !0,\n    format: he.COMPRESSED_RGB_PVRTC_4BPPV1_IMG\n  },\n  \"pvrtc1-4-rgba\": {\n    basisFormat: 9,\n    compressed: !0,\n    format: he.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\n  },\n  \"astc-4x4\": {\n    basisFormat: 10,\n    compressed: !0,\n    format: he.COMPRESSED_RGBA_ASTC_4X4_KHR\n  },\n  \"atc-rgb\": {\n    basisFormat: 11,\n    compressed: !0\n  },\n  \"atc-rgba-interpolated-alpha\": {\n    basisFormat: 12,\n    compressed: !0\n  },\n  rgba32: {\n    basisFormat: 13,\n    compressed: !1\n  },\n  rgb565: {\n    basisFormat: 14,\n    compressed: !1\n  },\n  bgr565: {\n    basisFormat: 15,\n    compressed: !1\n  },\n  rgba4444: {\n    basisFormat: 16,\n    compressed: !1\n  }\n};\n\nasync function d0(e, t) {\n  if (t.basis.containerFormat === \"auto\") {\n    if (h0(e)) {\n      const s = await Hi(t);\n      return qi(s.KTX2File, e, t);\n    }\n\n    const {\n      BasisFile: n\n    } = await Ui(t);\n    return ws(n, e, t);\n  }\n\n  switch (t.basis.module) {\n    case \"encoder\":\n      const n = await Hi(t);\n\n      switch (t.basis.containerFormat) {\n        case \"ktx2\":\n          return qi(n.KTX2File, e, t);\n\n        case \"basis\":\n        default:\n          return ws(n.BasisFile, e, t);\n      }\n\n    case \"transcoder\":\n    default:\n      const {\n        BasisFile: s\n      } = await Ui(t);\n      return ws(s, e, t);\n  }\n}\n\nfunction ws(e, t, n) {\n  const s = new e(new Uint8Array(t));\n\n  try {\n    if (!s.startTranscoding()) throw new Error(\"Failed to start basis transcoding\");\n    const r = s.getNumImages(),\n          i = [];\n\n    for (let o = 0; o < r; o++) {\n      const a = s.getNumLevels(o),\n            c = [];\n\n      for (let u = 0; u < a; u++) c.push(m0(s, o, u, n));\n\n      i.push(c);\n    }\n\n    return i;\n  } finally {\n    s.close(), s.delete();\n  }\n}\n\nfunction m0(e, t, n, s) {\n  const r = e.getImageWidth(t, n),\n        i = e.getImageHeight(t, n),\n        o = e.getHasAlpha(),\n        {\n    compressed: a,\n    format: c,\n    basisFormat: u\n  } = Za(s, o),\n        l = e.getImageTranscodedSizeInBytes(t, n, u),\n        h = new Uint8Array(l);\n  if (!e.transcodeImage(h, t, n, u, 0, 0)) throw new Error(\"failed to start Basis transcoding\");\n  return {\n    width: r,\n    height: i,\n    data: h,\n    compressed: a,\n    format: c,\n    hasAlpha: o\n  };\n}\n\nfunction qi(e, t, n) {\n  const s = new e(new Uint8Array(t));\n\n  try {\n    if (!s.startTranscoding()) throw new Error(\"failed to start KTX2 transcoding\");\n    const r = s.getLevels(),\n          i = [];\n\n    for (let o = 0; o < r; o++) {\n      i.push(g0(s, o, n));\n      break;\n    }\n\n    return [i];\n  } finally {\n    s.close(), s.delete();\n  }\n}\n\nfunction g0(e, t, n) {\n  const {\n    alphaFlag: s,\n    height: r,\n    width: i\n  } = e.getImageLevelInfo(t, 0, 0),\n        {\n    compressed: o,\n    format: a,\n    basisFormat: c\n  } = Za(n, s),\n        u = e.getImageTranscodedSizeInBytes(t, 0, 0, c),\n        l = new Uint8Array(u);\n  if (!e.transcodeImage(l, t, 0, 0, c, 0, -1, -1)) throw new Error(\"Failed to transcode KTX2 image\");\n  return {\n    width: i,\n    height: r,\n    data: l,\n    compressed: o,\n    levelSize: u,\n    hasAlpha: s,\n    format: a\n  };\n}\n\nfunction Za(e, t) {\n  let n = e && e.basis && e.basis.format;\n  return n === \"auto\" && (n = tc()), typeof n == \"object\" && (n = t ? n.alpha : n.noAlpha), n = n.toLowerCase(), f0[n];\n}\n\nfunction tc() {\n  const e = u0();\n  return e.has(\"astc\") ? \"astc-4x4\" : e.has(\"dxt\") ? {\n    alpha: \"bc3\",\n    noAlpha: \"bc1\"\n  } : e.has(\"pvrtc\") ? {\n    alpha: \"pvrtc1-4-rgba\",\n    noAlpha: \"pvrtc1-4-rgb\"\n  } : e.has(\"etc1\") ? \"etc1\" : e.has(\"etc2\") ? \"etc2\" : \"rgb565\";\n}\n\nconst A0 = {\n  name: \"Basis\",\n  id: \"basis\",\n  module: \"textures\",\n  version: s0,\n  worker: !0,\n  extensions: [\"basis\", \"ktx2\"],\n  mimeTypes: [\"application/octet-stream\", \"image/ktx2\"],\n  tests: [\"sB\"],\n  binary: !0,\n  options: {\n    basis: {\n      format: \"auto\",\n      libraryPath: \"libs/\",\n      containerFormat: \"auto\",\n      module: \"transcoder\"\n    }\n  }\n},\n      p0 = { ...A0,\n  parse: d0\n},\n      pe = !0,\n      Yi = 1735152710,\n      Dr = 12,\n      Pn = 8,\n      y0 = 1313821514,\n      B0 = 5130562,\n      C0 = 0,\n      E0 = 0,\n      T0 = 1;\n\nfunction b0(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n  return `${String.fromCharCode(e.getUint8(t + 0))}${String.fromCharCode(e.getUint8(t + 1))}${String.fromCharCode(e.getUint8(t + 2))}${String.fromCharCode(e.getUint8(t + 3))}`;\n}\n\nfunction _0(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,\n      n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n  const s = new DataView(e),\n        {\n    magic: r = Yi\n  } = n,\n        i = s.getUint32(t, !1);\n  return i === r || i === Yi;\n}\n\nfunction w0(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  const s = new DataView(t),\n        r = b0(s, n + 0),\n        i = s.getUint32(n + 4, pe),\n        o = s.getUint32(n + 8, pe);\n\n  switch (Object.assign(e, {\n    header: {\n      byteOffset: n,\n      byteLength: o,\n      hasBinChunk: !1\n    },\n    type: r,\n    version: i,\n    json: {},\n    binChunks: []\n  }), n += Dr, e.version) {\n    case 1:\n      return R0(e, s, n);\n\n    case 2:\n      return M0(e, s, n, {});\n\n    default:\n      throw new Error(`Invalid GLB version ${e.version}. Only supports version 1 and 2.`);\n  }\n}\n\nfunction R0(e, t, n) {\n  z(e.header.byteLength > Dr + Pn);\n  const s = t.getUint32(n + 0, pe),\n        r = t.getUint32(n + 4, pe);\n  return n += Pn, z(r === C0), Ys(e, t, n, s), n += s, n += $s(e, t, n, e.header.byteLength), n;\n}\n\nfunction M0(e, t, n, s) {\n  return z(e.header.byteLength > Dr + Pn), S0(e, t, n, s), n + e.header.byteLength;\n}\n\nfunction S0(e, t, n, s) {\n  for (; n + 8 <= e.header.byteLength;) {\n    const r = t.getUint32(n + 0, pe),\n          i = t.getUint32(n + 4, pe);\n\n    switch (n += Pn, i) {\n      case y0:\n        Ys(e, t, n, r);\n        break;\n\n      case B0:\n        $s(e, t, n, r);\n        break;\n\n      case E0:\n        s.strict || Ys(e, t, n, r);\n        break;\n\n      case T0:\n        s.strict || $s(e, t, n, r);\n        break;\n    }\n\n    n += ze(r, 4);\n  }\n\n  return n;\n}\n\nfunction Ys(e, t, n, s) {\n  const r = new Uint8Array(t.buffer, n, s),\n        o = new TextDecoder(\"utf8\").decode(r);\n  return e.json = JSON.parse(o), ze(s, 4);\n}\n\nfunction $s(e, t, n, s) {\n  return e.header.hasBinChunk = !0, e.binChunks.push({\n    byteOffset: n,\n    byteLength: s,\n    arrayBuffer: t.buffer\n  }), ze(s, 4);\n}\n\nfunction ec(e, t) {\n  if (e.startsWith(\"data:\") || e.startsWith(\"http:\") || e.startsWith(\"https:\")) return e;\n  const s = t.baseUri || t.uri;\n  if (!s) throw new Error(`'baseUri' must be provided to resolve relative url ${e}`);\n  return s.substr(0, s.lastIndexOf(\"/\") + 1) + e;\n}\n\nconst I0 = \"B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB\",\n      x0 = \"B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB\",\n      v0 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]),\n      O0 = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]),\n      F0 = {\n  0: \"\",\n  1: \"meshopt_decodeFilterOct\",\n  2: \"meshopt_decodeFilterQuat\",\n  3: \"meshopt_decodeFilterExp\",\n  NONE: \"\",\n  OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n  QUATERNION: \"meshopt_decodeFilterQuat\",\n  EXPONENTIAL: \"meshopt_decodeFilterExp\"\n},\n      D0 = {\n  0: \"meshopt_decodeVertexBuffer\",\n  1: \"meshopt_decodeIndexBuffer\",\n  2: \"meshopt_decodeIndexSequence\",\n  ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n  TRIANGLES: \"meshopt_decodeIndexBuffer\",\n  INDICES: \"meshopt_decodeIndexSequence\"\n};\n\nasync function L0(e, t, n, s, r) {\n  let i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"NONE\";\n  const o = await P0();\n  U0(o, o.exports[D0[r]], e, t, n, s, o.exports[F0[i || \"NONE\"]]);\n}\n\nlet Rs;\n\nasync function P0() {\n  return Rs || (Rs = G0()), Rs;\n}\n\nasync function G0() {\n  let e = I0;\n  WebAssembly.validate(v0) && (e = x0, console.log(\"Warning: meshopt_decoder is using experimental SIMD support\"));\n  const t = await WebAssembly.instantiate(N0(e), {});\n  return await t.instance.exports.__wasm_call_ctors(), t.instance;\n}\n\nfunction N0(e) {\n  const t = new Uint8Array(e.length);\n\n  for (let s = 0; s < e.length; ++s) {\n    const r = e.charCodeAt(s);\n    t[s] = r > 96 ? r - 71 : r > 64 ? r - 65 : r > 47 ? r + 4 : r > 46 ? 63 : 62;\n  }\n\n  let n = 0;\n\n  for (let s = 0; s < e.length; ++s) t[n++] = t[s] < 60 ? O0[t[s]] : (t[s] - 60) * 64 + t[++s];\n\n  return t.buffer.slice(0, n);\n}\n\nfunction U0(e, t, n, s, r, i, o) {\n  const a = e.exports.sbrk,\n        c = s + 3 & -4,\n        u = a(c * r),\n        l = a(i.length),\n        h = new Uint8Array(e.exports.memory.buffer);\n  h.set(i, l);\n  const f = t(u, s, r, l, i.length);\n  if (f === 0 && o && o(u, c, r), n.set(h.subarray(u, u + s * r)), a(u - a(0)), f !== 0) throw new Error(`Malformed buffer data: ${f}`);\n}\n\nconst Gn = \"EXT_meshopt_compression\",\n      H0 = Gn;\n\nasync function J0(e, t) {\n  var n, s;\n  const r = new ot(e);\n  if (!(t != null && (n = t.gltf) !== null && n !== void 0 && n.decompressMeshes) || !((s = t.gltf) !== null && s !== void 0 && s.loadBuffers)) return;\n  const i = [];\n\n  for (const o of e.json.bufferViews || []) i.push(V0(r, o));\n\n  await Promise.all(i), r.removeExtension(Gn);\n}\n\nasync function V0(e, t) {\n  const n = e.getObjectExtension(t, Gn);\n\n  if (n) {\n    const {\n      byteOffset: s = 0,\n      byteLength: r = 0,\n      byteStride: i,\n      count: o,\n      mode: a,\n      filter: c = \"NONE\",\n      buffer: u\n    } = n,\n          l = e.gltf.buffers[u],\n          h = new Uint8Array(l.arrayBuffer, l.byteOffset + s, r),\n          f = new Uint8Array(e.gltf.buffers[t.buffer].arrayBuffer, t.byteOffset, t.byteLength);\n    await L0(f, o, i, h, a, c), e.removeObjectExtension(t, Gn);\n  }\n}\n\nconst j0 = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  decode: J0,\n  name: H0\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      fe = \"EXT_texture_webp\",\n      k0 = fe;\n\nfunction K0(e, t) {\n  const n = new ot(e);\n\n  if (!tg(\"image/webp\")) {\n    if (n.getRequiredExtensions().includes(fe)) throw new Error(`gltf: Required extension ${fe} not supported by browser`);\n    return;\n  }\n\n  const {\n    json: s\n  } = n;\n\n  for (const r of s.textures || []) {\n    const i = n.getObjectExtension(r, fe);\n    i && (r.source = i.source), n.removeObjectExtension(r, fe);\n  }\n\n  n.removeExtension(fe);\n}\n\nconst z0 = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  name: k0,\n  preprocess: K0\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      _n = \"KHR_texture_basisu\",\n      W0 = _n;\n\nfunction X0(e, t) {\n  const n = new ot(e),\n        {\n    json: s\n  } = n;\n\n  for (const r of s.textures || []) {\n    const i = n.getObjectExtension(r, _n);\n    i && (r.source = i.source, n.removeObjectExtension(r, _n));\n  }\n\n  n.removeExtension(_n);\n}\n\nconst Q0 = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  name: W0,\n  preprocess: X0\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\n\nfunction q0(e) {\n  const t = {};\n\n  for (const n in e) {\n    const s = e[n];\n\n    if (n !== \"indices\") {\n      const r = nc(s);\n      t[n] = r;\n    }\n  }\n\n  return t;\n}\n\nfunction nc(e) {\n  const {\n    buffer: t,\n    size: n,\n    count: s\n  } = Y0(e);\n  return {\n    value: t,\n    size: n,\n    byteOffset: 0,\n    count: s,\n    type: ja(n),\n    componentType: Sr(t)\n  };\n}\n\nfunction Y0(e) {\n  let t = e,\n      n = 1,\n      s = 0;\n  return e && e.value && (t = e.value, n = e.size || 1), t && (ArrayBuffer.isView(t) || (t = $0(t, Float32Array)), s = t.length / n), {\n    buffer: t,\n    size: n,\n    count: s\n  };\n}\n\nfunction $0(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n  return e ? Array.isArray(e) ? new t(e) : n && !(e instanceof t) ? new t(e) : e : null;\n}\n\nconst zt = \"KHR_draco_mesh_compression\",\n      Z0 = zt;\n\nfunction tA(e, t, n) {\n  const s = new ot(e);\n\n  for (const r of sc(s)) s.getObjectExtension(r, zt);\n}\n\nasync function eA(e, t, n) {\n  var s;\n  if (!(t != null && (s = t.gltf) !== null && s !== void 0 && s.decompressMeshes)) return;\n  const r = new ot(e),\n        i = [];\n\n  for (const o of sc(r)) r.getObjectExtension(o, zt) && i.push(sA(r, o, t, n));\n\n  await Promise.all(i), r.removeExtension(zt);\n}\n\nfunction nA(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  const n = new ot(e);\n\n  for (const s of n.json.meshes || []) rA(s, t), n.addRequiredExtension(zt);\n}\n\nasync function sA(e, t, n, s) {\n  const r = e.getObjectExtension(t, zt);\n  if (!r) return;\n  const i = e.getTypedArrayForBufferView(r.bufferView),\n        o = dr(i.buffer, i.byteOffset),\n        a = { ...n\n  };\n  delete a[\"3d-tiles\"];\n  const c = await Ke(o, Da, a, s),\n        u = q0(c.attributes);\n\n  for (const [l, h] of Object.entries(u)) if (l in t.attributes) {\n    const f = t.attributes[l],\n          d = e.getAccessor(f);\n    d != null && d.min && d !== null && d !== void 0 && d.max && (h.min = d.min, h.max = d.max);\n  }\n\n  t.attributes = u, c.indices && (t.indices = nc(c.indices)), e.removeObjectExtension(t, zt), iA(t);\n}\n\nfunction rA(e, t) {\n  var n;\n  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 4,\n      r = arguments.length > 3 ? arguments[3] : void 0,\n      i = arguments.length > 4 ? arguments[4] : void 0;\n  if (!r.DracoWriter) throw new Error(\"options.gltf.DracoWriter not provided\");\n\n  const o = r.DracoWriter.encodeSync({\n    attributes: e\n  }),\n        a = i == null || (n = i.parseSync) === null || n === void 0 ? void 0 : n.call(i, {\n    attributes: e\n  }),\n        c = r._addFauxAttributes(a.attributes),\n        u = r.addBufferView(o);\n\n  return {\n    primitives: [{\n      attributes: c,\n      mode: s,\n      extensions: {\n        [zt]: {\n          bufferView: u,\n          attributes: c\n        }\n      }\n    }]\n  };\n}\n\nfunction iA(e) {\n  if (!e.attributes && Object.keys(e.attributes).length > 0) throw new Error(\"glTF: Empty primitive detected: Draco decompression failure?\");\n}\n\nfunction* sc(e) {\n  for (const t of e.json.meshes || []) for (const n of t.primitives) yield n;\n}\n\nconst oA = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  decode: eA,\n  encode: nA,\n  name: Z0,\n  preprocess: tA\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      Lr = \"KHR_texture_transform\",\n      aA = Lr,\n      An = new A(),\n      cA = new X(),\n      uA = new X();\n\nasync function lA(e, t) {\n  var n;\n  if (!new ot(e).hasExtension(Lr) || !((n = t.gltf) !== null && n !== void 0 && n.loadBuffers)) return;\n  const i = e.json.materials || [];\n\n  for (let o = 0; o < i.length; o++) hA(o, e);\n}\n\nfunction hA(e, t) {\n  var n, s, r;\n  const i = [],\n        o = (n = t.json.materials) === null || n === void 0 ? void 0 : n[e],\n        a = o == null || (s = o.pbrMetallicRoughness) === null || s === void 0 ? void 0 : s.baseColorTexture;\n  a && Me(t, e, a, i);\n  const c = o == null ? void 0 : o.emissiveTexture;\n  c && Me(t, e, c, i);\n  const u = o == null ? void 0 : o.normalTexture;\n  u && Me(t, e, u, i);\n  const l = o == null ? void 0 : o.occlusionTexture;\n  l && Me(t, e, l, i);\n  const h = o == null || (r = o.pbrMetallicRoughness) === null || r === void 0 ? void 0 : r.metallicRoughnessTexture;\n  h && Me(t, e, h, i);\n}\n\nfunction Me(e, t, n, s) {\n  const r = fA(n, s);\n  if (!r) return;\n  const i = e.json.meshes || [];\n\n  for (const o of i) for (const a of o.primitives) {\n    const c = a.material;\n    Number.isFinite(c) && t === c && dA(e, a, r);\n  }\n}\n\nfunction fA(e, t) {\n  var n;\n  const s = (n = e.extensions) === null || n === void 0 ? void 0 : n[Lr],\n        {\n    texCoord: r = 0\n  } = e,\n        {\n    texCoord: i = r\n  } = s;\n\n  if (!(t.findIndex(a => {\n    let [c, u] = a;\n    return c === r && u === i;\n  }) !== -1)) {\n    const a = AA(s);\n    return r !== i && (e.texCoord = i), t.push([r, i]), {\n      originalTexCoord: r,\n      texCoord: i,\n      matrix: a\n    };\n  }\n\n  return null;\n}\n\nfunction dA(e, t, n) {\n  const {\n    originalTexCoord: s,\n    texCoord: r,\n    matrix: i\n  } = n,\n        o = t.attributes[`TEXCOORD_${s}`];\n\n  if (Number.isFinite(o)) {\n    var a;\n    const u = (a = e.json.accessors) === null || a === void 0 ? void 0 : a[o];\n\n    if (u && u.bufferView) {\n      var c;\n      const l = (c = e.json.bufferViews) === null || c === void 0 ? void 0 : c[u.bufferView];\n\n      if (l) {\n        const {\n          arrayBuffer: h,\n          byteOffset: f\n        } = e.buffers[l.buffer],\n              d = (f || 0) + (u.byteOffset || 0) + (l.byteOffset || 0),\n              {\n          ArrayType: m,\n          length: g\n        } = Ir(u, l),\n              y = Va[u.componentType],\n              E = Ja[u.type],\n              R = l.byteStride || y * E,\n              B = new Float32Array(g);\n\n        for (let C = 0; C < u.count; C++) {\n          const M = new m(h, d + C * R, 2);\n          An.set(M[0], M[1], 1), An.transformByMatrix3(i), B.set([An[0], An[1]], C * E);\n        }\n\n        s === r ? mA(u, l, e.buffers, B) : gA(r, u, t, e, B);\n      }\n    }\n  }\n}\n\nfunction mA(e, t, n, s) {\n  e.componentType = 5126, n.push({\n    arrayBuffer: s.buffer,\n    byteOffset: 0,\n    byteLength: s.buffer.byteLength\n  }), t.buffer = n.length - 1, t.byteLength = s.buffer.byteLength, t.byteOffset = 0, delete t.byteStride;\n}\n\nfunction gA(e, t, n, s, r) {\n  s.buffers.push({\n    arrayBuffer: r.buffer,\n    byteOffset: 0,\n    byteLength: r.buffer.byteLength\n  });\n  const i = s.json.bufferViews;\n  if (!i) return;\n  i.push({\n    buffer: s.buffers.length - 1,\n    byteLength: r.buffer.byteLength,\n    byteOffset: 0\n  });\n  const o = s.json.accessors;\n  o && (o.push({\n    bufferView: (i == null ? void 0 : i.length) - 1,\n    byteOffset: 0,\n    componentType: 5126,\n    count: t.count,\n    type: \"VEC2\"\n  }), n.attributes[`TEXCOORD_${e}`] = o.length - 1);\n}\n\nfunction AA(e) {\n  const {\n    offset: t = [0, 0],\n    rotation: n = 0,\n    scale: s = [1, 1]\n  } = e,\n        r = new X().set(1, 0, 0, 0, 1, 0, t[0], t[1], 1),\n        i = cA.set(Math.cos(n), Math.sin(n), 0, -Math.sin(n), Math.cos(n), 0, 0, 0, 1),\n        o = uA.set(s[0], 0, 0, 0, s[1], 0, 0, 0, 1);\n  return r.multiplyRight(i).multiplyRight(o);\n}\n\nconst pA = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  decode: lA,\n  name: aA\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      Yt = \"KHR_lights_punctual\",\n      yA = Yt;\n\nasync function BA(e) {\n  const t = new ot(e),\n        {\n    json: n\n  } = t,\n        s = t.getExtension(Yt);\n  s && (t.json.lights = s.lights, t.removeExtension(Yt));\n\n  for (const r of n.nodes || []) {\n    const i = t.getObjectExtension(r, Yt);\n    i && (r.light = i.light), t.removeObjectExtension(r, Yt);\n  }\n}\n\nasync function CA(e) {\n  const t = new ot(e),\n        {\n    json: n\n  } = t;\n\n  if (n.lights) {\n    const s = t.addExtension(Yt);\n    yt(!s.lights), s.lights = n.lights, delete n.lights;\n  }\n\n  if (t.json.lights) {\n    for (const s of t.json.lights) {\n      const r = s.node;\n      t.addObjectExtension(r, Yt, s);\n    }\n\n    delete t.json.lights;\n  }\n}\n\nconst EA = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  decode: BA,\n  encode: CA,\n  name: yA\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      Ue = \"KHR_materials_unlit\",\n      TA = Ue;\n\nasync function bA(e) {\n  const t = new ot(e),\n        {\n    json: n\n  } = t;\n\n  for (const s of n.materials || []) s.extensions && s.extensions.KHR_materials_unlit && (s.unlit = !0), t.removeObjectExtension(s, Ue);\n\n  t.removeExtension(Ue);\n}\n\nfunction _A(e) {\n  const t = new ot(e),\n        {\n    json: n\n  } = t;\n  if (t.materials) for (const s of n.materials || []) s.unlit && (delete s.unlit, t.addObjectExtension(s, Ue, {}), t.addExtension(Ue));\n}\n\nconst wA = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  decode: bA,\n  encode: _A,\n  name: TA\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      xe = \"KHR_techniques_webgl\",\n      RA = xe;\n\nasync function MA(e) {\n  const t = new ot(e),\n        {\n    json: n\n  } = t,\n        s = t.getExtension(xe);\n\n  if (s) {\n    const r = IA(s, t);\n\n    for (const i of n.materials || []) {\n      const o = t.getObjectExtension(i, xe);\n      o && (i.technique = Object.assign({}, o, r[o.technique]), i.technique.values = xA(i.technique, t)), t.removeObjectExtension(i, xe);\n    }\n\n    t.removeExtension(xe);\n  }\n}\n\nasync function SA(e, t) {}\n\nfunction IA(e, t) {\n  const {\n    programs: n = [],\n    shaders: s = [],\n    techniques: r = []\n  } = e,\n        i = new TextDecoder();\n  return s.forEach(o => {\n    if (Number.isFinite(o.bufferView)) o.code = i.decode(t.getTypedArrayForBufferView(o.bufferView));else throw new Error(\"KHR_techniques_webgl: no shader code\");\n  }), n.forEach(o => {\n    o.fragmentShader = s[o.fragmentShader], o.vertexShader = s[o.vertexShader];\n  }), r.forEach(o => {\n    o.program = n[o.program];\n  }), r;\n}\n\nfunction xA(e, t) {\n  const n = Object.assign({}, e.values);\n  return Object.keys(e.uniforms || {}).forEach(s => {\n    e.uniforms[s].value && !(s in n) && (n[s] = e.uniforms[s].value);\n  }), Object.keys(n).forEach(s => {\n    typeof n[s] == \"object\" && n[s].index !== void 0 && (n[s].texture = t.getTexture(n[s].index));\n  }), n;\n}\n\nconst vA = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  decode: MA,\n  encode: SA,\n  name: RA\n}, Symbol.toStringTag, {\n  value: \"Module\"\n})),\n      rc = [Ng, Cg, j0, z0, Q0, oA, EA, wA, vA, pA, e0];\n\nfunction OA(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},\n      n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = rc.filter(i => ic(i.name, t));\n\n  for (const i of s) {\n    var r;\n    (r = i.preprocess) === null || r === void 0 || r.call(i, e, t, n);\n  }\n}\n\nasync function FA(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},\n      n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = rc.filter(i => ic(i.name, t));\n\n  for (const i of s) {\n    var r;\n    await ((r = i.decode) === null || r === void 0 ? void 0 : r.call(i, e, t, n));\n  }\n}\n\nfunction ic(e, t) {\n  var n;\n  const s = (t == null || (n = t.gltf) === null || n === void 0 ? void 0 : n.excludeExtensions) || {};\n  return !(e in s && !s[e]);\n}\n\nconst Ms = \"KHR_binary_glTF\";\n\nfunction DA(e) {\n  const t = new ot(e),\n        {\n    json: n\n  } = t;\n\n  for (const s of n.images || []) {\n    const r = t.getObjectExtension(s, Ms);\n    r && Object.assign(s, r), t.removeObjectExtension(s, Ms);\n  }\n\n  n.buffers && n.buffers[0] && delete n.buffers[0].uri, t.removeExtension(Ms);\n}\n\nconst $i = {\n  accessors: \"accessor\",\n  animations: \"animation\",\n  buffers: \"buffer\",\n  bufferViews: \"bufferView\",\n  images: \"image\",\n  materials: \"material\",\n  meshes: \"mesh\",\n  nodes: \"node\",\n  samplers: \"sampler\",\n  scenes: \"scene\",\n  skins: \"skin\",\n  textures: \"texture\"\n},\n      LA = {\n  accessor: \"accessors\",\n  animations: \"animation\",\n  buffer: \"buffers\",\n  bufferView: \"bufferViews\",\n  image: \"images\",\n  material: \"materials\",\n  mesh: \"meshes\",\n  node: \"nodes\",\n  sampler: \"samplers\",\n  scene: \"scenes\",\n  skin: \"skins\",\n  texture: \"textures\"\n};\n\nclass PA {\n  constructor() {\n    this.idToIndexMap = {\n      animations: {},\n      accessors: {},\n      buffers: {},\n      bufferViews: {},\n      images: {},\n      materials: {},\n      meshes: {},\n      nodes: {},\n      samplers: {},\n      scenes: {},\n      skins: {},\n      textures: {}\n    }, this.json = void 0;\n  }\n\n  normalize(t, n) {\n    this.json = t.json;\n    const s = t.json;\n\n    switch (s.asset && s.asset.version) {\n      case \"2.0\":\n        return;\n\n      case void 0:\n      case \"1.0\":\n        break;\n\n      default:\n        console.warn(`glTF: Unknown version ${s.asset.version}`);\n        return;\n    }\n\n    if (!n.normalize) throw new Error(\"glTF v1 is not supported.\");\n    console.warn(\"Converting glTF v1 to glTF v2 format. This is experimental and may fail.\"), this._addAsset(s), this._convertTopLevelObjectsToArrays(s), DA(t), this._convertObjectIdsToArrayIndices(s), this._updateObjects(s), this._updateMaterial(s);\n  }\n\n  _addAsset(t) {\n    t.asset = t.asset || {}, t.asset.version = \"2.0\", t.asset.generator = t.asset.generator || \"Normalized to glTF 2.0 by loaders.gl\";\n  }\n\n  _convertTopLevelObjectsToArrays(t) {\n    for (const n in $i) this._convertTopLevelObjectToArray(t, n);\n  }\n\n  _convertTopLevelObjectToArray(t, n) {\n    const s = t[n];\n\n    if (!(!s || Array.isArray(s))) {\n      t[n] = [];\n\n      for (const r in s) {\n        const i = s[r];\n        i.id = i.id || r;\n        const o = t[n].length;\n        t[n].push(i), this.idToIndexMap[n][r] = o;\n      }\n    }\n  }\n\n  _convertObjectIdsToArrayIndices(t) {\n    for (const n in $i) this._convertIdsToIndices(t, n);\n\n    \"scene\" in t && (t.scene = this._convertIdToIndex(t.scene, \"scene\"));\n\n    for (const n of t.textures) this._convertTextureIds(n);\n\n    for (const n of t.meshes) this._convertMeshIds(n);\n\n    for (const n of t.nodes) this._convertNodeIds(n);\n\n    for (const n of t.scenes) this._convertSceneIds(n);\n  }\n\n  _convertTextureIds(t) {\n    t.source && (t.source = this._convertIdToIndex(t.source, \"image\"));\n  }\n\n  _convertMeshIds(t) {\n    for (const n of t.primitives) {\n      const {\n        attributes: s,\n        indices: r,\n        material: i\n      } = n;\n\n      for (const o in s) s[o] = this._convertIdToIndex(s[o], \"accessor\");\n\n      r && (n.indices = this._convertIdToIndex(r, \"accessor\")), i && (n.material = this._convertIdToIndex(i, \"material\"));\n    }\n  }\n\n  _convertNodeIds(t) {\n    t.children && (t.children = t.children.map(n => this._convertIdToIndex(n, \"node\"))), t.meshes && (t.meshes = t.meshes.map(n => this._convertIdToIndex(n, \"mesh\")));\n  }\n\n  _convertSceneIds(t) {\n    t.nodes && (t.nodes = t.nodes.map(n => this._convertIdToIndex(n, \"node\")));\n  }\n\n  _convertIdsToIndices(t, n) {\n    t[n] || (console.warn(`gltf v1: json doesn't contain attribute ${n}`), t[n] = []);\n\n    for (const s of t[n]) for (const r in s) {\n      const i = s[r],\n            o = this._convertIdToIndex(i, r);\n\n      s[r] = o;\n    }\n  }\n\n  _convertIdToIndex(t, n) {\n    const s = LA[n];\n\n    if (s in this.idToIndexMap) {\n      const r = this.idToIndexMap[s][t];\n      if (!Number.isFinite(r)) throw new Error(`gltf v1: failed to resolve ${n} with id ${t}`);\n      return r;\n    }\n\n    return t;\n  }\n\n  _updateObjects(t) {\n    for (const n of this.json.buffers) delete n.type;\n  }\n\n  _updateMaterial(t) {\n    for (const i of t.materials) {\n      var n, s, r;\n      i.pbrMetallicRoughness = {\n        baseColorFactor: [1, 1, 1, 1],\n        metallicFactor: 1,\n        roughnessFactor: 1\n      };\n      const o = ((n = i.values) === null || n === void 0 ? void 0 : n.tex) || ((s = i.values) === null || s === void 0 ? void 0 : s.texture2d_0) || ((r = i.values) === null || r === void 0 ? void 0 : r.diffuseTex),\n            a = t.textures.findIndex(c => c.id === o);\n      a !== -1 && (i.pbrMetallicRoughness.baseColorTexture = {\n        index: a\n      });\n    }\n  }\n\n}\n\nfunction GA(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  return new PA().normalize(e, t);\n}\n\nasync function NA(e, t) {\n  var n, s, r;\n  let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,\n      o = arguments.length > 3 ? arguments[3] : void 0,\n      a = arguments.length > 4 ? arguments[4] : void 0;\n  return UA(e, t, i, o), GA(e, {\n    normalize: o == null || (n = o.gltf) === null || n === void 0 ? void 0 : n.normalize\n  }), OA(e, o, a), o != null && (s = o.gltf) !== null && s !== void 0 && s.loadBuffers && e.json.buffers && (await HA(e, o, a)), o != null && (r = o.gltf) !== null && r !== void 0 && r.loadImages && (await JA(e, o, a)), await FA(e, o, a), e;\n}\n\nfunction UA(e, t, n, s) {\n  if (s.uri && (e.baseUri = s.uri), t instanceof ArrayBuffer && !_0(t, n, s) && (t = new TextDecoder().decode(t)), typeof t == \"string\") e.json = Du(t);else if (t instanceof ArrayBuffer) {\n    const o = {};\n    n = w0(o, t, n, s.glb), yt(o.type === \"glTF\", `Invalid GLB magic string ${o.type}`), e._glb = o, e.json = o.json;\n  } else yt(!1, \"GLTF: must be ArrayBuffer or string\");\n  const r = e.json.buffers || [];\n\n  if (e.buffers = new Array(r.length).fill(null), e._glb && e._glb.header.hasBinChunk) {\n    const {\n      binChunks: o\n    } = e._glb;\n    e.buffers[0] = {\n      arrayBuffer: o[0].arrayBuffer,\n      byteOffset: o[0].byteOffset,\n      byteLength: o[0].byteLength\n    };\n  }\n\n  const i = e.json.images || [];\n  e.images = new Array(i.length).fill({});\n}\n\nasync function HA(e, t, n) {\n  const s = e.json.buffers || [];\n\n  for (let o = 0; o < s.length; ++o) {\n    const a = s[o];\n\n    if (a.uri) {\n      var r, i;\n      const {\n        fetch: c\n      } = n;\n      yt(c);\n      const u = ec(a.uri, t),\n            l = await (n == null || (r = n.fetch) === null || r === void 0 ? void 0 : r.call(n, u)),\n            h = await (l == null || (i = l.arrayBuffer) === null || i === void 0 ? void 0 : i.call(l));\n      e.buffers[o] = {\n        arrayBuffer: h,\n        byteOffset: 0,\n        byteLength: h.byteLength\n      }, delete a.uri;\n    } else e.buffers[o] === null && (e.buffers[o] = {\n      arrayBuffer: new ArrayBuffer(a.byteLength),\n      byteOffset: 0,\n      byteLength: a.byteLength\n    });\n  }\n}\n\nasync function JA(e, t, n) {\n  const s = VA(e),\n        r = e.json.images || [],\n        i = [];\n\n  for (const o of s) i.push(jA(e, r[o], o, t, n));\n\n  return await Promise.all(i);\n}\n\nfunction VA(e) {\n  const t = /* @__PURE__ */new Set(),\n        n = e.json.textures || [];\n\n  for (const s of n) s.source !== void 0 && t.add(s.source);\n\n  return Array.from(t).sort();\n}\n\nasync function jA(e, t, n, s, r) {\n  let i;\n\n  if (t.uri && !t.hasOwnProperty(\"bufferView\")) {\n    const a = ec(t.uri, s),\n          {\n      fetch: c\n    } = r;\n    i = await (await c(a)).arrayBuffer(), t.bufferView = {\n      data: i\n    };\n  }\n\n  if (Number.isFinite(t.bufferView)) {\n    const a = lg(e.json, e.buffers, t.bufferView);\n    i = dr(a.buffer, a.byteOffset, a.byteLength);\n  }\n\n  yt(i, \"glTF image has no data\");\n  let o = await Ke(i, [Zm, p0], { ...s,\n    mimeType: t.mimeType,\n    basis: s.basis || {\n      format: tc()\n    }\n  }, r);\n  o && o[0] && (o = {\n    compressed: !0,\n    mipmaps: !1,\n    width: o[0].width,\n    height: o[0].height,\n    data: o[0]\n  }), e.images = e.images || [], e.images[n] = o;\n}\n\nconst Nn = {\n  name: \"glTF\",\n  id: \"gltf\",\n  module: \"gltf\",\n  version: n0,\n  extensions: [\"gltf\", \"glb\"],\n  mimeTypes: [\"model/gltf+json\", \"model/gltf-binary\"],\n  text: !0,\n  binary: !0,\n  tests: [\"glTF\"],\n  parse: kA,\n  options: {\n    gltf: {\n      normalize: !0,\n      loadBuffers: !0,\n      loadImages: !0,\n      decompressMeshes: !0\n    },\n    log: console\n  }\n};\n\nasync function kA(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},\n      n = arguments.length > 2 ? arguments[2] : void 0;\n  t = { ...Nn.options,\n    ...t\n  }, t.gltf = { ...Nn.options.gltf,\n    ...t.gltf\n  };\n  const {\n    byteOffset: s = 0\n  } = t;\n  return await NA({}, e, s, t, n);\n}\n\nconst KA = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n},\n      zA = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n},\n      Bt = {\n  TEXTURE_MAG_FILTER: 10240,\n  TEXTURE_MIN_FILTER: 10241,\n  TEXTURE_WRAP_S: 10242,\n  TEXTURE_WRAP_T: 10243,\n  REPEAT: 10497,\n  LINEAR: 9729,\n  NEAREST_MIPMAP_LINEAR: 9986\n},\n      WA = {\n  magFilter: Bt.TEXTURE_MAG_FILTER,\n  minFilter: Bt.TEXTURE_MIN_FILTER,\n  wrapS: Bt.TEXTURE_WRAP_S,\n  wrapT: Bt.TEXTURE_WRAP_T\n},\n      XA = {\n  [Bt.TEXTURE_MAG_FILTER]: Bt.LINEAR,\n  [Bt.TEXTURE_MIN_FILTER]: Bt.NEAREST_MIPMAP_LINEAR,\n  [Bt.TEXTURE_WRAP_S]: Bt.REPEAT,\n  [Bt.TEXTURE_WRAP_T]: Bt.REPEAT\n};\n\nfunction QA() {\n  return {\n    id: \"default-sampler\",\n    parameters: XA\n  };\n}\n\nfunction qA(e) {\n  return zA[e];\n}\n\nfunction YA(e) {\n  return KA[e];\n}\n\nclass $A {\n  constructor() {\n    this.baseUri = \"\", this.jsonUnprocessed = void 0, this.json = void 0, this.buffers = [], this.images = [];\n  }\n\n  postProcess(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const {\n      json: s,\n      buffers: r = [],\n      images: i = []\n    } = t,\n          {\n      baseUri: o = \"\"\n    } = t;\n    return yt(s), this.baseUri = o, this.buffers = r, this.images = i, this.jsonUnprocessed = s, this.json = this._resolveTree(t.json, n), this.json;\n  }\n\n  _resolveTree(t) {\n    const n = { ...t\n    };\n    return this.json = n, t.bufferViews && (n.bufferViews = t.bufferViews.map((s, r) => this._resolveBufferView(s, r))), t.images && (n.images = t.images.map((s, r) => this._resolveImage(s, r))), t.samplers && (n.samplers = t.samplers.map((s, r) => this._resolveSampler(s, r))), t.textures && (n.textures = t.textures.map((s, r) => this._resolveTexture(s, r))), t.accessors && (n.accessors = t.accessors.map((s, r) => this._resolveAccessor(s, r))), t.materials && (n.materials = t.materials.map((s, r) => this._resolveMaterial(s, r))), t.meshes && (n.meshes = t.meshes.map((s, r) => this._resolveMesh(s, r))), t.nodes && (n.nodes = t.nodes.map((s, r) => this._resolveNode(s, r)), n.nodes = n.nodes.map((s, r) => this._resolveNodeChildren(s))), t.skins && (n.skins = t.skins.map((s, r) => this._resolveSkin(s, r))), t.scenes && (n.scenes = t.scenes.map((s, r) => this._resolveScene(s, r))), typeof this.json.scene == \"number\" && n.scenes && (n.scene = n.scenes[this.json.scene]), n;\n  }\n\n  getScene(t) {\n    return this._get(this.json.scenes, t);\n  }\n\n  getNode(t) {\n    return this._get(this.json.nodes, t);\n  }\n\n  getSkin(t) {\n    return this._get(this.json.skins, t);\n  }\n\n  getMesh(t) {\n    return this._get(this.json.meshes, t);\n  }\n\n  getMaterial(t) {\n    return this._get(this.json.materials, t);\n  }\n\n  getAccessor(t) {\n    return this._get(this.json.accessors, t);\n  }\n\n  getCamera(t) {\n    return this._get(this.json.cameras, t);\n  }\n\n  getTexture(t) {\n    return this._get(this.json.textures, t);\n  }\n\n  getSampler(t) {\n    return this._get(this.json.samplers, t);\n  }\n\n  getImage(t) {\n    return this._get(this.json.images, t);\n  }\n\n  getBufferView(t) {\n    return this._get(this.json.bufferViews, t);\n  }\n\n  getBuffer(t) {\n    return this._get(this.json.buffers, t);\n  }\n\n  _get(t, n) {\n    if (typeof n == \"object\") return n;\n    const s = t && t[n];\n    return s || console.warn(`glTF file error: Could not find ${t}[${n}]`), s;\n  }\n\n  _resolveScene(t, n) {\n    return { ...t,\n      id: t.id || `scene-${n}`,\n      nodes: (t.nodes || []).map(s => this.getNode(s))\n    };\n  }\n\n  _resolveNode(t, n) {\n    const s = { ...t,\n      id: (t == null ? void 0 : t.id) || `node-${n}`\n    };\n    return t.mesh !== void 0 && (s.mesh = this.getMesh(t.mesh)), t.camera !== void 0 && (s.camera = this.getCamera(t.camera)), t.skin !== void 0 && (s.skin = this.getSkin(t.skin)), t.meshes !== void 0 && t.meshes.length && (s.mesh = t.meshes.reduce((r, i) => {\n      const o = this.getMesh(i);\n      return r.id = o.id, r.primitives = r.primitives.concat(o.primitives), r;\n    }, {\n      primitives: []\n    })), s;\n  }\n\n  _resolveNodeChildren(t) {\n    return t.children && (t.children = t.children.map(n => this.getNode(n))), t;\n  }\n\n  _resolveSkin(t, n) {\n    const s = typeof t.inverseBindMatrices == \"number\" ? this.getAccessor(t.inverseBindMatrices) : void 0;\n    return { ...t,\n      id: t.id || `skin-${n}`,\n      inverseBindMatrices: s\n    };\n  }\n\n  _resolveMesh(t, n) {\n    const s = { ...t,\n      id: t.id || `mesh-${n}`,\n      primitives: []\n    };\n    return t.primitives && (s.primitives = t.primitives.map(r => {\n      const i = { ...r,\n        attributes: {},\n        indices: void 0,\n        material: void 0\n      },\n            o = r.attributes;\n\n      for (const a in o) i.attributes[a] = this.getAccessor(o[a]);\n\n      return r.indices !== void 0 && (i.indices = this.getAccessor(r.indices)), r.material !== void 0 && (i.material = this.getMaterial(r.material)), i;\n    })), s;\n  }\n\n  _resolveMaterial(t, n) {\n    const s = { ...t,\n      id: t.id || `material-${n}`\n    };\n\n    if (s.normalTexture && (s.normalTexture = { ...s.normalTexture\n    }, s.normalTexture.texture = this.getTexture(s.normalTexture.index)), s.occlusionTexture && (s.occlusionTexture = { ...s.occlusionTexture\n    }, s.occlusionTexture.texture = this.getTexture(s.occlusionTexture.index)), s.emissiveTexture && (s.emissiveTexture = { ...s.emissiveTexture\n    }, s.emissiveTexture.texture = this.getTexture(s.emissiveTexture.index)), s.emissiveFactor || (s.emissiveFactor = s.emissiveTexture ? [1, 1, 1] : [0, 0, 0]), s.pbrMetallicRoughness) {\n      s.pbrMetallicRoughness = { ...s.pbrMetallicRoughness\n      };\n      const r = s.pbrMetallicRoughness;\n      r.baseColorTexture && (r.baseColorTexture = { ...r.baseColorTexture\n      }, r.baseColorTexture.texture = this.getTexture(r.baseColorTexture.index)), r.metallicRoughnessTexture && (r.metallicRoughnessTexture = { ...r.metallicRoughnessTexture\n      }, r.metallicRoughnessTexture.texture = this.getTexture(r.metallicRoughnessTexture.index));\n    }\n\n    return s;\n  }\n\n  _resolveAccessor(t, n) {\n    const s = qA(t.componentType),\n          r = YA(t.type),\n          i = s * r,\n          o = { ...t,\n      id: t.id || `accessor-${n}`,\n      bytesPerComponent: s,\n      components: r,\n      bytesPerElement: i,\n      value: void 0,\n      bufferView: void 0,\n      sparse: void 0\n    };\n\n    if (t.bufferView !== void 0 && (o.bufferView = this.getBufferView(t.bufferView)), o.bufferView) {\n      const a = o.bufferView.buffer,\n            {\n        ArrayType: c,\n        byteLength: u\n      } = Ir(o, o.bufferView),\n            l = (o.bufferView.byteOffset || 0) + (o.byteOffset || 0) + a.byteOffset;\n      let h = a.arrayBuffer.slice(l, l + u);\n      o.bufferView.byteStride && (h = this._getValueFromInterleavedBuffer(a, l, o.bufferView.byteStride, o.bytesPerElement, o.count)), o.value = new c(h);\n    }\n\n    return o;\n  }\n\n  _getValueFromInterleavedBuffer(t, n, s, r, i) {\n    const o = new Uint8Array(i * r);\n\n    for (let a = 0; a < i; a++) {\n      const c = n + a * s;\n      o.set(new Uint8Array(t.arrayBuffer.slice(c, c + r)), a * r);\n    }\n\n    return o.buffer;\n  }\n\n  _resolveTexture(t, n) {\n    return { ...t,\n      id: t.id || `texture-${n}`,\n      sampler: typeof t.sampler == \"number\" ? this.getSampler(t.sampler) : QA(),\n      source: typeof t.source == \"number\" ? this.getImage(t.source) : void 0\n    };\n  }\n\n  _resolveSampler(t, n) {\n    const s = {\n      id: t.id || `sampler-${n}`,\n      ...t,\n      parameters: {}\n    };\n\n    for (const r in s) {\n      const i = this._enumSamplerParameter(r);\n\n      i !== void 0 && (s.parameters[i] = s[r]);\n    }\n\n    return s;\n  }\n\n  _enumSamplerParameter(t) {\n    return WA[t];\n  }\n\n  _resolveImage(t, n) {\n    const s = { ...t,\n      id: t.id || `image-${n}`,\n      image: null,\n      bufferView: t.bufferView !== void 0 ? this.getBufferView(t.bufferView) : void 0\n    },\n          r = this.images[n];\n    return r && (s.image = r), s;\n  }\n\n  _resolveBufferView(t, n) {\n    const s = t.buffer,\n          r = this.buffers[s].arrayBuffer;\n    let i = this.buffers[s].byteOffset || 0;\n    return t.byteOffset && (i += t.byteOffset), {\n      id: `bufferView-${n}`,\n      ...t,\n      buffer: this.buffers[s],\n      data: new Uint8Array(r, i, t.byteLength)\n    };\n  }\n\n  _resolveCamera(t, n) {\n    const s = { ...t,\n      id: t.id || `camera-${n}`\n    };\n    return s.perspective, s.orthographic, s;\n  }\n\n}\n\nfunction oc(e, t) {\n  return new $A().postProcess(e, t);\n}\n\nconst Zs = {\n  URI: 0,\n  EMBEDDED: 1\n};\n\nfunction ac(e, t, n, s) {\n  e.rotateYtoZ = !0;\n  const r = (e.byteOffset || 0) + (e.byteLength || 0) - n;\n  if (r === 0) throw new Error(\"glTF byte length must be greater than 0.\");\n  return e.gltfUpAxis = s != null && s[\"3d-tiles\"] && s[\"3d-tiles\"].assetGltfUpAxis ? s[\"3d-tiles\"].assetGltfUpAxis : \"Y\", e.gltfArrayBuffer = dr(t, n, r), e.gltfByteOffset = 0, e.gltfByteLength = r, n % 4 === 0 || console.warn(`${e.type}: embedded glb is not aligned to a 4-byte boundary.`), (e.byteOffset || 0) + (e.byteLength || 0);\n}\n\nasync function cc(e, t, n, s) {\n  const r = (n == null ? void 0 : n[\"3d-tiles\"]) || {};\n\n  if (ZA(e, t), r.loadGLTF) {\n    if (!s) return;\n\n    if (e.gltfUrl) {\n      const {\n        fetch: i\n      } = s,\n            o = await i(e.gltfUrl, n);\n      e.gltfArrayBuffer = await o.arrayBuffer(), e.gltfByteOffset = 0;\n    }\n\n    if (e.gltfArrayBuffer) {\n      const i = await Ke(e.gltfArrayBuffer, Nn, n, s);\n      e.gltf = oc(i), e.gpuMemoryUsageInBytes = ka(e.gltf), delete e.gltfArrayBuffer, delete e.gltfByteOffset, delete e.gltfByteLength;\n    }\n  }\n}\n\nfunction ZA(e, t, n) {\n  switch (t) {\n    case Zs.URI:\n      if (e.gltfArrayBuffer) {\n        const s = new Uint8Array(e.gltfArrayBuffer, e.gltfByteOffset),\n              i = new TextDecoder().decode(s);\n        e.gltfUrl = i.replace(/[\\s\\0]+$/, \"\");\n      }\n\n      delete e.gltfArrayBuffer, delete e.gltfByteOffset, delete e.gltfByteLength;\n      break;\n\n    case Zs.EMBEDDED:\n      break;\n\n    default:\n      throw new Error(\"b3dm: Illegal glTF format field\");\n  }\n}\n\nasync function tp(e, t, n, s, r) {\n  var i;\n  n = ep(e, t, n, s), await cc(e, Zs.EMBEDDED, s, r);\n  const o = e == null || (i = e.gltf) === null || i === void 0 ? void 0 : i.extensions;\n  return o && o.CESIUM_RTC && (e.rtcCenter = o.CESIUM_RTC.center), n;\n}\n\nfunction ep(e, t, n, s, r) {\n  n = qn(e, t, n), n = _r(e, t, n), n = wr(e, t, n), n = ac(e, t, n, s);\n  const i = new br(e.featureTableJson, e.featureTableBinary);\n  return e.rtcCenter = i.getGlobalProperty(\"RTC_CENTER\", G.FLOAT, 3), n;\n}\n\nasync function np(e, t, n, s, r) {\n  return n = sp(e, t, n, s), await cc(e, e.gltfFormat || 0, s, r), n;\n}\n\nfunction sp(e, t, n, s, r) {\n  var i;\n  if (n = qn(e, t, n), e.version !== 1) throw new Error(`Instanced 3D Model version ${e.version} is not supported`);\n  n = _r(e, t, n);\n  const o = new DataView(t);\n  if (e.gltfFormat = o.getUint32(n, !0), n += 4, n = wr(e, t, n), n = ac(e, t, n, s), !(e != null && (i = e.header) !== null && i !== void 0 && i.featureTableJsonByteLength) || e.header.featureTableJsonByteLength === 0) throw new Error(\"i3dm parser: featureTableJsonByteLength is zero.\");\n  const a = new br(e.featureTableJson, e.featureTableBinary),\n        c = a.getGlobalProperty(\"INSTANCES_LENGTH\");\n  if (a.featuresLength = c, !Number.isFinite(c)) throw new Error(\"i3dm parser: INSTANCES_LENGTH must be defined\");\n  e.eastNorthUp = a.getGlobalProperty(\"EAST_NORTH_UP\"), e.rtcCenter = a.getGlobalProperty(\"RTC_CENTER\", G.FLOAT, 3);\n  const u = new Pa(e.batchTableJson, e.batchTableBinary, c);\n  return rp(e, a, u, c), n;\n}\n\nfunction rp(e, t, n, s) {\n  const r = new Array(s),\n        i = new A();\n  new A(), new A(), new A();\n  const o = new X(),\n        a = new On(),\n        c = new A(),\n        u = {},\n        l = new V(),\n        h = [],\n        f = [],\n        d = [],\n        m = [];\n\n  for (let g = 0; g < s; g++) {\n    let y;\n    if (t.hasProperty(\"POSITION\")) y = t.getProperty(\"POSITION\", G.FLOAT, 3, g, i);else if (t.hasProperty(\"POSITION_QUANTIZED\")) {\n      y = t.getProperty(\"POSITION_QUANTIZED\", G.UNSIGNED_SHORT, 3, g, i);\n      const b = t.getGlobalProperty(\"QUANTIZED_VOLUME_OFFSET\", G.FLOAT, 3);\n      if (!b) throw new Error(\"i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\");\n      const O = t.getGlobalProperty(\"QUANTIZED_VOLUME_SCALE\", G.FLOAT, 3);\n      if (!O) throw new Error(\"i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\");\n      const F = 65535;\n\n      for (let v = 0; v < 3; v++) y[v] = y[v] / F * O[v] + b[v];\n    }\n    if (!y) throw new Error(\"i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.\");\n\n    if (i.copy(y), u.translation = i, e.normalUp = t.getProperty(\"NORMAL_UP\", G.FLOAT, 3, g, h), e.normalRight = t.getProperty(\"NORMAL_RIGHT\", G.FLOAT, 3, g, f), e.normalUp) {\n      if (!e.normalRight) throw new Error(\"i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.\");\n      e.hasCustomOrientation = !0;\n    } else {\n      if (e.octNormalUp = t.getProperty(\"NORMAL_UP_OCT32P\", G.UNSIGNED_SHORT, 2, g, h), e.octNormalRight = t.getProperty(\"NORMAL_RIGHT_OCT32P\", G.UNSIGNED_SHORT, 2, g, f), e.octNormalUp) throw e.octNormalRight ? new Error(\"i3dm: oct-encoded orientation not implemented\") : new Error(\"i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P\");\n      e.eastNorthUp ? (J.WGS84.eastNorthUpToFixedFrame(i, l), l.getRotationMatrix3(o)) : o.identity();\n    }\n\n    a.fromMatrix3(o), u.rotation = a, c.set(1, 1, 1);\n    const E = t.getProperty(\"SCALE\", G.FLOAT, 1, g, d);\n    Number.isFinite(E) && c.multiplyByScalar(E);\n    const R = t.getProperty(\"SCALE_NON_UNIFORM\", G.FLOAT, 3, g, h);\n    R && c.scale(R), u.scale = c;\n    let B = t.getProperty(\"BATCH_ID\", G.UNSIGNED_SHORT, 1, g, m);\n    B === void 0 && (B = g);\n    const C = new V().fromQuaternion(u.rotation);\n    l.identity(), l.translate(u.translation), l.multiplyRight(C), l.scale(u.scale);\n    const M = l.clone();\n    r[g] = {\n      modelMatrix: M,\n      batchId: B\n    };\n  }\n\n  e.instances = r;\n}\n\nasync function ip(e, t, n, s, r, i) {\n  n = qn(e, t, n);\n  const o = new DataView(t);\n\n  for (e.tilesLength = o.getUint32(n, !0), n += 4, e.tiles = []; e.tiles.length < e.tilesLength && (e.byteLength || 0) - n > 12;) {\n    const a = {\n      shape: \"tile3d\"\n    };\n    e.tiles.push(a), n = await i(t, n, s, r, a);\n  }\n\n  return n;\n}\n\nasync function op(e, t, n, s) {\n  var r, i;\n\n  if (e.rotateYtoZ = !0, e.gltfUpAxis = n != null && (r = n[\"3d-tiles\"]) !== null && r !== void 0 && r.assetGltfUpAxis ? n[\"3d-tiles\"].assetGltfUpAxis : \"Y\", n != null && (i = n[\"3d-tiles\"]) !== null && i !== void 0 && i.loadGLTF) {\n    if (!s) return t.byteLength;\n    const o = await Ke(t, Nn, n, s);\n    e.gltf = oc(o), e.gpuMemoryUsageInBytes = ka(e.gltf);\n  } else e.gltfArrayBuffer = t;\n\n  return t.byteLength;\n}\n\nasync function uc(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,\n      n = arguments.length > 2 ? arguments[2] : void 0,\n      s = arguments.length > 3 ? arguments[3] : void 0,\n      r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {\n    shape: \"tile3d\"\n  };\n\n  switch (r.byteOffset = t, r.type = Sd(e, t), r.type) {\n    case _e.COMPOSITE:\n      return await ip(r, e, t, n, s, uc);\n\n    case _e.BATCHED_3D_MODEL:\n      return await tp(r, e, t, n, s);\n\n    case _e.GLTF:\n      return await op(r, e, n, s);\n\n    case _e.INSTANCED_3D_MODEL:\n      return await np(r, e, t, n, s);\n\n    case _e.POINT_CLOUD:\n      return await fm(r, e, t, n, s);\n\n    default:\n      throw new Error(`3DTileLoader: unknown type ${r.type}`);\n  }\n}\n\nconst ap = 1952609651,\n      cp = 1;\n\nasync function up(e, t, n) {\n  if (new Uint32Array(e.slice(0, 4))[0] !== ap) throw new Error(\"Wrong subtree file magic number\");\n  if (new Uint32Array(e.slice(4, 8))[0] !== cp) throw new Error(\"Wrong subtree file verson, must be 1\");\n  const i = Zi(e.slice(8, 16)),\n        o = new Uint8Array(e, 24, i),\n        c = new TextDecoder(\"utf8\").decode(o),\n        u = JSON.parse(c),\n        l = Zi(e.slice(16, 24));\n  let h = new ArrayBuffer(0);\n  if (l && (h = e.slice(24 + i)), await pn(u, u.tileAvailability, h, n), Array.isArray(u.contentAvailability)) for (const f of u.contentAvailability) await pn(u, f, h, n);else await pn(u, u.contentAvailability, h, n);\n  return await pn(u, u.childSubtreeAvailability, h, n), u;\n}\n\nasync function pn(e, t, n, s) {\n  const r = Number.isFinite(t.bitstream) ? t.bitstream : t.bufferView;\n  if (typeof r != \"number\") return;\n  const i = e.bufferViews[r],\n        o = e.buffers[i.buffer];\n  if (!(s != null && s.baseUrl)) throw new Error(\"Url is not provided\");\n  if (!s.fetch) throw new Error(\"fetch is not provided\");\n\n  if (o.uri) {\n    const c = `${(s == null ? void 0 : s.baseUrl) || \"\"}/${o.uri}`,\n          l = await (await s.fetch(c)).arrayBuffer();\n    t.explicitBitstream = new Uint8Array(l, i.byteOffset, i.byteLength);\n    return;\n  }\n\n  const a = e.buffers.slice(0, i.buffer).reduce((c, u) => c + u.byteLength, 0);\n  t.explicitBitstream = new Uint8Array(n.slice(a, a + o.byteLength), i.byteOffset, i.byteLength);\n}\n\nfunction Zi(e) {\n  const t = new DataView(e),\n        n = t.getUint32(0, !0),\n        s = t.getUint32(4, !0);\n  return n + 2 ** 32 * s;\n}\n\nconst lc = {\n  id: \"3d-tiles-subtree\",\n  name: \"3D Tiles Subtree\",\n  module: \"3d-tiles\",\n  version: va,\n  extensions: [\"subtree\"],\n  mimeTypes: [\"application/octet-stream\"],\n  tests: [\"subtree\"],\n  parse: up,\n  options: {}\n};\n/**\n * @license\n * Copyright 2009 The Closure Library Authors\n * Copyright 2020 Daniel Wirtz / The long.js Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar Et = null;\n\ntry {\n  Et = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n} catch {}\n\nfunction H(e, t, n) {\n  this.low = e | 0, this.high = t | 0, this.unsigned = !!n;\n}\n\nH.prototype.__isLong__;\nObject.defineProperty(H.prototype, \"__isLong__\", {\n  value: !0\n});\n\nfunction at(e) {\n  return (e && e.__isLong__) === !0;\n}\n\nfunction to(e) {\n  var t = Math.clz32(e & -e);\n  return e ? 31 - t : t;\n}\n\nH.isLong = at;\nvar eo = {},\n    no = {};\n\nfunction ie(e, t) {\n  var n, s, r;\n  return t ? (e >>>= 0, (r = 0 <= e && e < 256) && (s = no[e], s) ? s : (n = N(e, 0, !0), r && (no[e] = n), n)) : (e |= 0, (r = -128 <= e && e < 128) && (s = eo[e], s) ? s : (n = N(e, e < 0 ? -1 : 0, !1), r && (eo[e] = n), n));\n}\n\nH.fromInt = ie;\n\nfunction Tt(e, t) {\n  if (isNaN(e)) return t ? Ut : St;\n\n  if (t) {\n    if (e < 0) return Ut;\n    if (e >= hc) return mc;\n  } else {\n    if (e <= -ro) return mt;\n    if (e + 1 >= ro) return dc;\n  }\n\n  return e < 0 ? Tt(-e, t).neg() : N(e % ye | 0, e / ye | 0, t);\n}\n\nH.fromNumber = Tt;\n\nfunction N(e, t, n) {\n  return new H(e, t, n);\n}\n\nH.fromBits = N;\nvar Un = Math.pow;\n\nfunction Pr(e, t, n) {\n  if (e.length === 0) throw Error(\"empty string\");\n  if (typeof t == \"number\" ? (n = t, t = !1) : t = !!t, e === \"NaN\" || e === \"Infinity\" || e === \"+Infinity\" || e === \"-Infinity\") return t ? Ut : St;\n  if (n = n || 10, n < 2 || 36 < n) throw RangeError(\"radix\");\n  var s;\n  if ((s = e.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n  if (s === 0) return Pr(e.substring(1), t, n).neg();\n\n  for (var r = Tt(Un(n, 8)), i = St, o = 0; o < e.length; o += 8) {\n    var a = Math.min(8, e.length - o),\n        c = parseInt(e.substring(o, o + a), n);\n\n    if (a < 8) {\n      var u = Tt(Un(n, a));\n      i = i.mul(u).add(Tt(c));\n    } else i = i.mul(r), i = i.add(Tt(c));\n  }\n\n  return i.unsigned = t, i;\n}\n\nH.fromString = Pr;\n\nfunction xt(e, t) {\n  return typeof e == \"number\" ? Tt(e, t) : typeof e == \"string\" ? Pr(e, t) : N(e.low, e.high, typeof t == \"boolean\" ? t : e.unsigned);\n}\n\nH.fromValue = xt;\nvar so = 65536,\n    lp = 1 << 24,\n    ye = so * so,\n    hc = ye * ye,\n    ro = hc / 2,\n    io = ie(lp),\n    St = ie(0);\nH.ZERO = St;\nvar Ut = ie(0, !0);\nH.UZERO = Ut;\nvar de = ie(1);\nH.ONE = de;\nvar fc = ie(1, !0);\nH.UONE = fc;\nvar tr = ie(-1);\nH.NEG_ONE = tr;\nvar dc = N(-1, 2147483647, !1);\nH.MAX_VALUE = dc;\nvar mc = N(-1, -1, !0);\nH.MAX_UNSIGNED_VALUE = mc;\nvar mt = N(0, -2147483648, !1);\nH.MIN_VALUE = mt;\nvar _ = H.prototype;\n\n_.toInt = function () {\n  return this.unsigned ? this.low >>> 0 : this.low;\n};\n\n_.toNumber = function () {\n  return this.unsigned ? (this.high >>> 0) * ye + (this.low >>> 0) : this.high * ye + (this.low >>> 0);\n};\n\n_.toString = function (t) {\n  if (t = t || 10, t < 2 || 36 < t) throw RangeError(\"radix\");\n  if (this.isZero()) return \"0\";\n  if (this.isNegative()) if (this.eq(mt)) {\n    var n = Tt(t),\n        s = this.div(n),\n        r = s.mul(n).sub(this);\n    return s.toString(t) + r.toInt().toString(t);\n  } else return \"-\" + this.neg().toString(t);\n\n  for (var i = Tt(Un(t, 6), this.unsigned), o = this, a = \"\";;) {\n    var c = o.div(i),\n        u = o.sub(c.mul(i)).toInt() >>> 0,\n        l = u.toString(t);\n    if (o = c, o.isZero()) return l + a;\n\n    for (; l.length < 6;) l = \"0\" + l;\n\n    a = \"\" + l + a;\n  }\n};\n\n_.getHighBits = function () {\n  return this.high;\n};\n\n_.getHighBitsUnsigned = function () {\n  return this.high >>> 0;\n};\n\n_.getLowBits = function () {\n  return this.low;\n};\n\n_.getLowBitsUnsigned = function () {\n  return this.low >>> 0;\n};\n\n_.getNumBitsAbs = function () {\n  if (this.isNegative()) return this.eq(mt) ? 64 : this.neg().getNumBitsAbs();\n\n  for (var t = this.high != 0 ? this.high : this.low, n = 31; n > 0 && !(t & 1 << n); n--);\n\n  return this.high != 0 ? n + 33 : n + 1;\n};\n\n_.isZero = function () {\n  return this.high === 0 && this.low === 0;\n};\n\n_.eqz = _.isZero;\n\n_.isNegative = function () {\n  return !this.unsigned && this.high < 0;\n};\n\n_.isPositive = function () {\n  return this.unsigned || this.high >= 0;\n};\n\n_.isOdd = function () {\n  return (this.low & 1) === 1;\n};\n\n_.isEven = function () {\n  return (this.low & 1) === 0;\n};\n\n_.equals = function (t) {\n  return at(t) || (t = xt(t)), this.unsigned !== t.unsigned && this.high >>> 31 === 1 && t.high >>> 31 === 1 ? !1 : this.high === t.high && this.low === t.low;\n};\n\n_.eq = _.equals;\n\n_.notEquals = function (t) {\n  return !this.eq(\n  /* validates */\n  t);\n};\n\n_.neq = _.notEquals;\n_.ne = _.notEquals;\n\n_.lessThan = function (t) {\n  return this.comp(\n  /* validates */\n  t) < 0;\n};\n\n_.lt = _.lessThan;\n\n_.lessThanOrEqual = function (t) {\n  return this.comp(\n  /* validates */\n  t) <= 0;\n};\n\n_.lte = _.lessThanOrEqual;\n_.le = _.lessThanOrEqual;\n\n_.greaterThan = function (t) {\n  return this.comp(\n  /* validates */\n  t) > 0;\n};\n\n_.gt = _.greaterThan;\n\n_.greaterThanOrEqual = function (t) {\n  return this.comp(\n  /* validates */\n  t) >= 0;\n};\n\n_.gte = _.greaterThanOrEqual;\n_.ge = _.greaterThanOrEqual;\n\n_.compare = function (t) {\n  if (at(t) || (t = xt(t)), this.eq(t)) return 0;\n  var n = this.isNegative(),\n      s = t.isNegative();\n  return n && !s ? -1 : !n && s ? 1 : this.unsigned ? t.high >>> 0 > this.high >>> 0 || t.high === this.high && t.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t).isNegative() ? -1 : 1;\n};\n\n_.comp = _.compare;\n\n_.negate = function () {\n  return !this.unsigned && this.eq(mt) ? mt : this.not().add(de);\n};\n\n_.neg = _.negate;\n\n_.add = function (t) {\n  at(t) || (t = xt(t));\n  var n = this.high >>> 16,\n      s = this.high & 65535,\n      r = this.low >>> 16,\n      i = this.low & 65535,\n      o = t.high >>> 16,\n      a = t.high & 65535,\n      c = t.low >>> 16,\n      u = t.low & 65535,\n      l = 0,\n      h = 0,\n      f = 0,\n      d = 0;\n  return d += i + u, f += d >>> 16, d &= 65535, f += r + c, h += f >>> 16, f &= 65535, h += s + a, l += h >>> 16, h &= 65535, l += n + o, l &= 65535, N(f << 16 | d, l << 16 | h, this.unsigned);\n};\n\n_.subtract = function (t) {\n  return at(t) || (t = xt(t)), this.add(t.neg());\n};\n\n_.sub = _.subtract;\n\n_.multiply = function (t) {\n  if (this.isZero()) return this;\n\n  if (at(t) || (t = xt(t)), Et) {\n    var n = Et.mul(this.low, this.high, t.low, t.high);\n    return N(n, Et.get_high(), this.unsigned);\n  }\n\n  if (t.isZero()) return this.unsigned ? Ut : St;\n  if (this.eq(mt)) return t.isOdd() ? mt : St;\n  if (t.eq(mt)) return this.isOdd() ? mt : St;\n  if (this.isNegative()) return t.isNegative() ? this.neg().mul(t.neg()) : this.neg().mul(t).neg();\n  if (t.isNegative()) return this.mul(t.neg()).neg();\n  if (this.lt(io) && t.lt(io)) return Tt(this.toNumber() * t.toNumber(), this.unsigned);\n  var s = this.high >>> 16,\n      r = this.high & 65535,\n      i = this.low >>> 16,\n      o = this.low & 65535,\n      a = t.high >>> 16,\n      c = t.high & 65535,\n      u = t.low >>> 16,\n      l = t.low & 65535,\n      h = 0,\n      f = 0,\n      d = 0,\n      m = 0;\n  return m += o * l, d += m >>> 16, m &= 65535, d += i * l, f += d >>> 16, d &= 65535, d += o * u, f += d >>> 16, d &= 65535, f += r * l, h += f >>> 16, f &= 65535, f += i * u, h += f >>> 16, f &= 65535, f += o * c, h += f >>> 16, f &= 65535, h += s * l + r * u + i * c + o * a, h &= 65535, N(d << 16 | m, h << 16 | f, this.unsigned);\n};\n\n_.mul = _.multiply;\n\n_.divide = function (t) {\n  if (at(t) || (t = xt(t)), t.isZero()) throw Error(\"division by zero\");\n\n  if (Et) {\n    if (!this.unsigned && this.high === -2147483648 && t.low === -1 && t.high === -1) return this;\n    var n = (this.unsigned ? Et.div_u : Et.div_s)(this.low, this.high, t.low, t.high);\n    return N(n, Et.get_high(), this.unsigned);\n  }\n\n  if (this.isZero()) return this.unsigned ? Ut : St;\n  var s, r, i;\n\n  if (this.unsigned) {\n    if (t.unsigned || (t = t.toUnsigned()), t.gt(this)) return Ut;\n    if (t.gt(this.shru(1))) return fc;\n    i = Ut;\n  } else {\n    if (this.eq(mt)) {\n      if (t.eq(de) || t.eq(tr)) return mt;\n      if (t.eq(mt)) return de;\n      var o = this.shr(1);\n      return s = o.div(t).shl(1), s.eq(St) ? t.isNegative() ? de : tr : (r = this.sub(t.mul(s)), i = s.add(r.div(t)), i);\n    } else if (t.eq(mt)) return this.unsigned ? Ut : St;\n\n    if (this.isNegative()) return t.isNegative() ? this.neg().div(t.neg()) : this.neg().div(t).neg();\n    if (t.isNegative()) return this.div(t.neg()).neg();\n    i = St;\n  }\n\n  for (r = this; r.gte(t);) {\n    s = Math.max(1, Math.floor(r.toNumber() / t.toNumber()));\n\n    for (var a = Math.ceil(Math.log(s) / Math.LN2), c = a <= 48 ? 1 : Un(2, a - 48), u = Tt(s), l = u.mul(t); l.isNegative() || l.gt(r);) s -= c, u = Tt(s, this.unsigned), l = u.mul(t);\n\n    u.isZero() && (u = de), i = i.add(u), r = r.sub(l);\n  }\n\n  return i;\n};\n\n_.div = _.divide;\n\n_.modulo = function (t) {\n  if (at(t) || (t = xt(t)), Et) {\n    var n = (this.unsigned ? Et.rem_u : Et.rem_s)(this.low, this.high, t.low, t.high);\n    return N(n, Et.get_high(), this.unsigned);\n  }\n\n  return this.sub(this.div(t).mul(t));\n};\n\n_.mod = _.modulo;\n_.rem = _.modulo;\n\n_.not = function () {\n  return N(~this.low, ~this.high, this.unsigned);\n};\n\n_.countLeadingZeros = function () {\n  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n};\n\n_.clz = _.countLeadingZeros;\n\n_.countTrailingZeros = function () {\n  return this.low ? to(this.low) : to(this.high) + 32;\n};\n\n_.ctz = _.countTrailingZeros;\n\n_.and = function (t) {\n  return at(t) || (t = xt(t)), N(this.low & t.low, this.high & t.high, this.unsigned);\n};\n\n_.or = function (t) {\n  return at(t) || (t = xt(t)), N(this.low | t.low, this.high | t.high, this.unsigned);\n};\n\n_.xor = function (t) {\n  return at(t) || (t = xt(t)), N(this.low ^ t.low, this.high ^ t.high, this.unsigned);\n};\n\n_.shiftLeft = function (t) {\n  return at(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? N(this.low << t, this.high << t | this.low >>> 32 - t, this.unsigned) : N(0, this.low << t - 32, this.unsigned);\n};\n\n_.shl = _.shiftLeft;\n\n_.shiftRight = function (t) {\n  return at(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? N(this.low >>> t | this.high << 32 - t, this.high >> t, this.unsigned) : N(this.high >> t - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n};\n\n_.shr = _.shiftRight;\n\n_.shiftRightUnsigned = function (t) {\n  return at(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? N(this.low >>> t | this.high << 32 - t, this.high >>> t, this.unsigned) : t === 32 ? N(this.high, 0, this.unsigned) : N(this.high >>> t - 32, 0, this.unsigned);\n};\n\n_.shru = _.shiftRightUnsigned;\n_.shr_u = _.shiftRightUnsigned;\n\n_.rotateLeft = function (t) {\n  var n;\n  return at(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t === 32 ? N(this.high, this.low, this.unsigned) : t < 32 ? (n = 32 - t, N(this.low << t | this.high >>> n, this.high << t | this.low >>> n, this.unsigned)) : (t -= 32, n = 32 - t, N(this.high << t | this.low >>> n, this.low << t | this.high >>> n, this.unsigned));\n};\n\n_.rotl = _.rotateLeft;\n\n_.rotateRight = function (t) {\n  var n;\n  return at(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t === 32 ? N(this.high, this.low, this.unsigned) : t < 32 ? (n = 32 - t, N(this.high << n | this.low >>> t, this.low << n | this.high >>> t, this.unsigned)) : (t -= 32, n = 32 - t, N(this.low << n | this.high >>> t, this.high << n | this.low >>> t, this.unsigned));\n};\n\n_.rotr = _.rotateRight;\n\n_.toSigned = function () {\n  return this.unsigned ? N(this.low, this.high, !1) : this;\n};\n\n_.toUnsigned = function () {\n  return this.unsigned ? this : N(this.low, this.high, !0);\n};\n\n_.toBytes = function (t) {\n  return t ? this.toBytesLE() : this.toBytesBE();\n};\n\n_.toBytesLE = function () {\n  var t = this.high,\n      n = this.low;\n  return [n & 255, n >>> 8 & 255, n >>> 16 & 255, n >>> 24, t & 255, t >>> 8 & 255, t >>> 16 & 255, t >>> 24];\n};\n\n_.toBytesBE = function () {\n  var t = this.high,\n      n = this.low;\n  return [t >>> 24, t >>> 16 & 255, t >>> 8 & 255, t & 255, n >>> 24, n >>> 16 & 255, n >>> 8 & 255, n & 255];\n};\n\nH.fromBytes = function (t, n, s) {\n  return s ? H.fromBytesLE(t, n) : H.fromBytesBE(t, n);\n};\n\nH.fromBytesLE = function (t, n) {\n  return new H(t[0] | t[1] << 8 | t[2] << 16 | t[3] << 24, t[4] | t[5] << 8 | t[6] << 16 | t[7] << 24, n);\n};\n\nH.fromBytesBE = function (t, n) {\n  return new H(t[4] << 24 | t[5] << 16 | t[6] << 8 | t[7], t[0] << 24 | t[1] << 16 | t[2] << 8 | t[3], n);\n};\n\nconst hp = 16;\n\nfunction gc(e) {\n  e === \"X\" && (e = \"\");\n  const t = e.padEnd(hp, \"0\");\n  return H.fromString(t, !0, 16);\n}\n\nfunction fp(e) {\n  if (e.isZero()) return \"X\";\n  let t = e.countTrailingZeros();\n  const n = t % 4;\n  t = (t - n) / 4;\n  const s = t;\n  t *= 4;\n  const i = e.shiftRightUnsigned(t).toString(16).replace(/0+$/, \"\");\n  return Array(17 - s - i.length).join(\"0\") + i;\n}\n\nfunction dp(e, t) {\n  const n = mp(e).shiftRightUnsigned(2);\n  return e.add(H.fromNumber(2 * t + 1 - 4).multiply(n));\n}\n\nfunction mp(e) {\n  return e.and(e.not().add(1));\n}\n\nconst gp = 3,\n      Ap = 30,\n      pp = 2 * Ap + 1,\n      oo = 180 / Math.PI;\n\nfunction yp(e) {\n  if (e.length === 0) throw new Error(`Invalid Hilbert quad key ${e}`);\n  const t = e.split(\"/\"),\n        n = parseInt(t[0], 10),\n        s = t[1],\n        r = s.length;\n  let i = 0;\n  const o = [0, 0];\n\n  for (let a = r - 1; a >= 0; a--) {\n    i = r - a;\n    const c = s[a];\n    let u = 0,\n        l = 0;\n    c === \"1\" ? l = 1 : c === \"2\" ? (u = 1, l = 1) : c === \"3\" && (u = 1);\n    const h = Math.pow(2, i - 1);\n    Cp(h, o, u, l), o[0] += h * u, o[1] += h * l;\n  }\n\n  if (n % 2 === 1) {\n    const a = o[0];\n    o[0] = o[1], o[1] = a;\n  }\n\n  return {\n    face: n,\n    ij: o,\n    level: i\n  };\n}\n\nfunction Bp(e) {\n  if (e.isZero()) return \"\";\n  let t = e.toString(2);\n\n  for (; t.length < gp + pp;) t = \"0\" + t;\n\n  const n = t.lastIndexOf(\"1\"),\n        s = t.substring(0, 3),\n        r = t.substring(3, n),\n        i = r.length / 2,\n        o = H.fromString(s, !0, 2).toString(10);\n  let a = \"\";\n  if (i !== 0) for (a = H.fromString(r, !0, 2).toString(4); a.length < i;) a = \"0\" + a;\n  return `${o}/${a}`;\n}\n\nfunction Ac(e, t, n) {\n  const s = 1 << t;\n  return [(e[0] + n[0]) / s, (e[1] + n[1]) / s];\n}\n\nfunction ao(e) {\n  return e >= 0.5 ? 1 / 3 * (4 * e * e - 1) : 1 / 3 * (1 - 4 * (1 - e) * (1 - e));\n}\n\nfunction pc(e) {\n  return [ao(e[0]), ao(e[1])];\n}\n\nfunction yc(e, t) {\n  let [n, s] = t;\n\n  switch (e) {\n    case 0:\n      return [1, n, s];\n\n    case 1:\n      return [-n, 1, s];\n\n    case 2:\n      return [-n, -s, 1];\n\n    case 3:\n      return [-1, -s, -n];\n\n    case 4:\n      return [s, -1, -n];\n\n    case 5:\n      return [s, n, -1];\n\n    default:\n      throw new Error(\"Invalid face\");\n  }\n}\n\nfunction Bc(e) {\n  let [t, n, s] = e;\n  const r = Math.atan2(s, Math.sqrt(t * t + n * n));\n  return [Math.atan2(n, t) * oo, r * oo];\n}\n\nfunction Cp(e, t, n, s) {\n  if (s === 0) {\n    n === 1 && (t[0] = e - 1 - t[0], t[1] = e - 1 - t[1]);\n    const r = t[0];\n    t[0] = t[1], t[1] = r;\n  }\n}\n\nfunction Ep(e) {\n  const t = Ac(e.ij, e.level, [0.5, 0.5]),\n        n = pc(t),\n        s = yc(e.face, n);\n  return Bc(s);\n}\n\nconst Tp = 100;\n\nfunction co(e) {\n  const {\n    face: t,\n    ij: n,\n    level: s\n  } = e,\n        r = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]],\n        i = Math.max(1, Math.ceil(Tp * Math.pow(2, -s))),\n        o = new Float64Array(4 * i * 2 + 2);\n  let a = 0,\n      c = 0;\n\n  for (let u = 0; u < 4; u++) {\n    const l = r[u].slice(0),\n          h = r[u + 1],\n          f = (h[0] - l[0]) / i,\n          d = (h[1] - l[1]) / i;\n\n    for (let m = 0; m < i; m++) {\n      l[0] += f, l[1] += d;\n      const g = Ac(n, s, l),\n            y = pc(g),\n            E = yc(t, y),\n            R = Bc(E);\n      Math.abs(R[1]) > 89.999 && (R[0] = c);\n      const B = R[0] - c;\n      R[0] += B > 180 ? -360 : B < -180 ? 360 : 0, o[a++] = R[0], o[a++] = R[1], c = R[0];\n    }\n  }\n\n  return o[a++] = o[0], o[a++] = o[1], o;\n}\n\nfunction Gr(e) {\n  const t = bp(e);\n  return yp(t);\n}\n\nfunction bp(e) {\n  if (e.indexOf(\"/\") > 0) return e;\n  const t = gc(e);\n  return Bp(t);\n}\n\nfunction _p(e) {\n  const t = Gr(e);\n  return Ep(t);\n}\n\nfunction wp(e) {\n  let t;\n\n  if (e.face === 2 || e.face === 5) {\n    let n = null,\n        s = 0;\n\n    for (let r = 0; r < 4; r++) {\n      const i = `${e.face}/${r}`,\n            o = Gr(i),\n            a = co(o);\n      (typeof n > \"u\" || n === null) && (n = new Float64Array(4 * a.length)), n.set(a, s), s += a.length;\n    }\n\n    t = uo(n);\n  } else {\n    const n = co(e);\n    t = uo(n);\n  }\n\n  return t;\n}\n\nfunction uo(e) {\n  if (e.length % 2 !== 0) throw new Error(\"Invalid corners\");\n  const t = [],\n        n = [];\n\n  for (let s = 0; s < e.length; s += 2) t.push(e[s]), n.push(e[s + 1]);\n\n  return t.sort((s, r) => s - r), n.sort((s, r) => s - r), {\n    west: t[0],\n    east: t[t.length - 1],\n    north: n[n.length - 1],\n    south: n[0]\n  };\n}\n\nfunction Rp(e, t) {\n  const n = (t == null ? void 0 : t.minimumHeight) || 0,\n        s = (t == null ? void 0 : t.maximumHeight) || 0,\n        r = Gr(e),\n        i = wp(r),\n        o = i.west,\n        a = i.south,\n        c = i.east,\n        u = i.north,\n        l = [];\n  return l.push(new A(o, u, n)), l.push(new A(c, u, n)), l.push(new A(c, a, n)), l.push(new A(o, a, n)), l.push(new A(o, u, s)), l.push(new A(c, u, s)), l.push(new A(c, a, s)), l.push(new A(o, a, s)), l;\n}\n\nfunction Cc(e) {\n  const t = e.token,\n        n = {\n    minimumHeight: e.minimumHeight,\n    maximumHeight: e.maximumHeight\n  },\n        s = Rp(t, n),\n        r = _p(t),\n        i = r[0],\n        o = r[1],\n        a = J.WGS84.cartographicToCartesian([i, o, n.maximumHeight]),\n        c = new A(a[0], a[1], a[2]);\n\n  s.push(c);\n  const u = Rd(s);\n  return [...u.center, ...u.halfAxes];\n}\n\nconst Mp = 4,\n      Sp = 8,\n      Ip = {\n  QUADTREE: Mp,\n  OCTREE: Sp\n};\n\nfunction xp(e, t, n) {\n  if (e != null && e.box) {\n    const s = gc(e.s2VolumeInfo.token),\n          r = dp(s, t),\n          i = fp(r),\n          o = { ...e.s2VolumeInfo\n    };\n\n    switch (o.token = i, n) {\n      case \"OCTREE\":\n        const u = e.s2VolumeInfo,\n              l = u.maximumHeight - u.minimumHeight,\n              h = l / 2,\n              f = u.minimumHeight + l / 2;\n        u.minimumHeight = f - h, u.maximumHeight = f + h;\n        break;\n    }\n\n    return {\n      box: Cc(o),\n      s2VolumeInfo: o\n    };\n  }\n}\n\nasync function Ec(e) {\n  const {\n    implicitOptions: t,\n    parentData: n = {\n      mortonIndex: 0,\n      x: 0,\n      y: 0,\n      z: 0\n    },\n    childIndex: s = 0,\n    s2VolumeBox: r,\n    loaderOptions: i\n  } = e;\n  let {\n    subtree: o,\n    level: a = 0,\n    globalData: c = {\n      level: 0,\n      mortonIndex: 0,\n      x: 0,\n      y: 0,\n      z: 0\n    }\n  } = e;\n  const {\n    subdivisionScheme: u,\n    subtreeLevels: l,\n    maximumLevel: h,\n    contentUrlTemplate: f,\n    subtreesUriTemplate: d,\n    basePath: m\n  } = t,\n        g = {\n    children: [],\n    lodMetricValue: 0,\n    contentUrl: \"\"\n  };\n  if (!h) return aa.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${f} won't be loaded...`), g;\n  const y = a + c.level;\n  if (y > h) return g;\n  const E = Ip[u],\n        R = Math.log2(E),\n        B = s & 1,\n        C = s >> 1 & 1,\n        M = s >> 2 & 1,\n        b = (E ** a - 1) / (E - 1);\n  let O = Qt(n.mortonIndex, s, R),\n      F = b + O,\n      v = Qt(n.x, B, 1),\n      L = Qt(n.y, C, 1),\n      k = Qt(n.z, M, 1),\n      q = !1;\n  a >= l && (q = Ss(o.childSubtreeAvailability, O));\n  const Y = Qt(c.x, v, a),\n        P = Qt(c.y, L, a),\n        ct = Qt(c.z, k, a);\n\n  if (q) {\n    const st = `${m}/${d}`,\n          Pt = er(st, y, Y, P, ct);\n    o = await Ae(Pt, lc, i), c = {\n      mortonIndex: O,\n      x: v,\n      y: L,\n      z: k,\n      level: a\n    }, O = 0, F = 0, v = 0, L = 0, k = 0, a = 0;\n  }\n\n  if (!Ss(o.tileAvailability, F)) return g;\n  Ss(o.contentAvailability, F) && (g.contentUrl = er(f, y, Y, P, ct));\n  const Be = a + 1,\n        vt = {\n    mortonIndex: O,\n    x: v,\n    y: L,\n    z: k\n  };\n\n  for (let st = 0; st < E; st++) {\n    const Pt = xp(r, st, u),\n          Xt = await Ec({\n      subtree: o,\n      implicitOptions: t,\n      loaderOptions: i,\n      parentData: vt,\n      childIndex: st,\n      level: Be,\n      globalData: { ...c\n      },\n      s2VolumeBox: Pt\n    });\n\n    if (Xt.contentUrl || Xt.children.length) {\n      const Ce = y + 1,\n            es = vp(Xt, Ce, {\n        childTileX: v,\n        childTileY: L,\n        childTileZ: k\n      }, t, r);\n      g.children.push(es);\n    }\n  }\n\n  return g;\n}\n\nfunction Ss(e, t) {\n  let n;\n  return Array.isArray(e) ? (n = e[0], e.length > 1 && aa.once('Not supported extension \"3DTILES_multiple_contents\" has been detected')) : n = e, \"constant\" in n ? !!n.constant : n.explicitBitstream ? Dp(t, n.explicitBitstream) : !1;\n}\n\nfunction vp(e, t, n, s, r) {\n  const {\n    basePath: i,\n    refine: o,\n    getRefine: a,\n    lodMetricType: c,\n    getTileType: u,\n    rootLodMetricValue: l,\n    rootBoundingVolume: h\n  } = s,\n        f = e.contentUrl && e.contentUrl.replace(`${i}/`, \"\"),\n        d = l / 2 ** t,\n        m = r != null && r.box ? {\n    box: r.box\n  } : h,\n        g = Op(t, m, n);\n  return {\n    children: e.children,\n    contentUrl: e.contentUrl,\n    content: {\n      uri: f\n    },\n    id: e.contentUrl,\n    refine: a(o),\n    type: u(e),\n    lodMetricType: c,\n    lodMetricValue: d,\n    geometricError: d,\n    transform: e.transform,\n    boundingVolume: g\n  };\n}\n\nfunction Op(e, t, n) {\n  if (t.region) {\n    const {\n      childTileX: s,\n      childTileY: r,\n      childTileZ: i\n    } = n,\n          [o, a, c, u, l, h] = t.region,\n          f = 2 ** e,\n          d = (c - o) / f,\n          m = (u - a) / f,\n          g = (h - l) / f,\n          [y, E] = [o + d * s, o + d * (s + 1)],\n          [R, B] = [a + m * r, a + m * (r + 1)],\n          [C, M] = [l + g * i, l + g * (i + 1)];\n    return {\n      region: [y, R, E, B, C, M]\n    };\n  }\n\n  if (t.box) return t;\n  throw new Error(`Unsupported bounding volume type ${t}`);\n}\n\nfunction Qt(e, t, n) {\n  return (e << n) + t;\n}\n\nfunction er(e, t, n, s, r) {\n  const i = Fp({\n    level: t,\n    x: n,\n    y: s,\n    z: r\n  });\n  return e.replace(/{level}|{x}|{y}|{z}/gi, o => i[o]);\n}\n\nfunction Fp(e) {\n  const t = {};\n\n  for (const n in e) t[`{${n}}`] = e[n];\n\n  return t;\n}\n\nfunction Dp(e, t) {\n  const n = Math.floor(e / 8),\n        s = e % 8;\n  return (t[n] >> s & 1) === 1;\n}\n\nfunction Nr(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n  if (!t) return dn.EMPTY;\n  const s = t.split(\"?\")[0].split(\".\").pop();\n\n  switch (s) {\n    case \"pnts\":\n      return dn.POINTCLOUD;\n\n    case \"i3dm\":\n    case \"b3dm\":\n    case \"glb\":\n    case \"gltf\":\n      return dn.SCENEGRAPH;\n\n    default:\n      return s || dn.EMPTY;\n  }\n}\n\nfunction Ur(e) {\n  switch (e) {\n    case \"REPLACE\":\n    case \"replace\":\n      return Ii.REPLACE;\n\n    case \"ADD\":\n    case \"add\":\n      return Ii.ADD;\n\n    default:\n      return e;\n  }\n}\n\nfunction nr(e, t) {\n  if (/^[a-z][0-9a-z+.-]*:/i.test(t)) {\n    const s = new URL(e, `${t}/`);\n    return decodeURI(s.toString());\n  } else if (e.startsWith(\"/\")) return e;\n\n  return ku(t, e);\n}\n\nfunction lo(e, t) {\n  if (!e) return null;\n  let n;\n\n  if (e.content) {\n    var s;\n    const i = e.content.uri || ((s = e.content) === null || s === void 0 ? void 0 : s.url);\n    typeof i < \"u\" && (n = nr(i, t));\n  }\n\n  return { ...e,\n    id: n,\n    contentUrl: n,\n    lodMetricType: Qn.GEOMETRIC_ERROR,\n    lodMetricValue: e.geometricError,\n    transformMatrix: e.transform,\n    type: Nr(e, n),\n    refine: Ur(e.refine)\n  };\n}\n\nasync function Lp(e, t, n) {\n  let s = null;\n  const r = fo(e.root);\n  r && e.root ? s = await ho(e.root, e, t, r, n) : s = lo(e.root, t);\n  const i = [];\n\n  for (i.push(s); i.length > 0;) {\n    const o = i.pop() || {},\n          a = o.children || [],\n          c = [];\n\n    for (const u of a) {\n      const l = fo(u);\n      let h;\n      l ? h = await ho(u, e, t, l, n) : h = lo(u, t), h && (c.push(h), i.push(h));\n    }\n\n    o.children = c;\n  }\n\n  return s;\n}\n\nasync function ho(e, t, n, s, r) {\n  var i, o, a;\n  const {\n    subdivisionScheme: c,\n    maximumLevel: u,\n    availableLevels: l,\n    subtreeLevels: h,\n    subtrees: {\n      uri: f\n    }\n  } = s,\n        d = er(f, 0, 0, 0, 0),\n        m = nr(d, n),\n        g = await Ae(m, lc, r),\n        y = (i = e.content) === null || i === void 0 ? void 0 : i.uri,\n        E = y ? nr(y, n) : \"\",\n        R = t == null || (o = t.root) === null || o === void 0 ? void 0 : o.refine,\n        B = e.geometricError,\n        C = (a = e.boundingVolume.extensions) === null || a === void 0 ? void 0 : a[\"3DTILES_bounding_volume_S2\"];\n\n  if (C) {\n    const F = {\n      box: Cc(C),\n      s2VolumeInfo: C\n    };\n    e.boundingVolume = F;\n  }\n\n  const M = e.boundingVolume,\n        b = {\n    contentUrlTemplate: E,\n    subtreesUriTemplate: f,\n    subdivisionScheme: c,\n    subtreeLevels: h,\n    maximumLevel: Number.isFinite(l) ? l - 1 : u,\n    refine: R,\n    basePath: n,\n    lodMetricType: Qn.GEOMETRIC_ERROR,\n    rootLodMetricValue: B,\n    rootBoundingVolume: M,\n    getTileType: Nr,\n    getRefine: Ur\n  };\n  return await Pp(e, n, g, b, r);\n}\n\nasync function Pp(e, t, n, s, r) {\n  if (!e) return null;\n  const {\n    children: i,\n    contentUrl: o\n  } = await Ec({\n    subtree: n,\n    implicitOptions: s,\n    loaderOptions: r\n  });\n  let a,\n      c = null;\n  return o && (a = o, c = {\n    uri: o.replace(`${t}/`, \"\")\n  }), { ...e,\n    id: a,\n    contentUrl: a,\n    lodMetricType: Qn.GEOMETRIC_ERROR,\n    lodMetricValue: e.geometricError,\n    transformMatrix: e.transform,\n    type: Nr(e, a),\n    refine: Ur(e.refine),\n    content: c || e.content,\n    children: i\n  };\n}\n\nfunction fo(e) {\n  var t;\n  return (e == null || (t = e.extensions) === null || t === void 0 ? void 0 : t[\"3DTILES_implicit_tiling\"]) || (e == null ? void 0 : e.implicitTiling);\n}\n\nconst Le = {\n  id: \"3d-tiles\",\n  name: \"3D Tiles\",\n  module: \"3d-tiles\",\n  version: va,\n  extensions: [\"cmpt\", \"pnts\", \"b3dm\", \"i3dm\"],\n  mimeTypes: [\"application/octet-stream\"],\n  tests: [\"cmpt\", \"pnts\", \"b3dm\", \"i3dm\"],\n  parse: Gp,\n  options: {\n    \"3d-tiles\": {\n      loadGLTF: !0,\n      decodeQuantizedPositions: !1,\n      isTileset: \"auto\",\n      assetGltfUpAxis: null\n    }\n  }\n};\n\nasync function Gp(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},\n      n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = t[\"3d-tiles\"] || {};\n  let r;\n  return s.isTileset === \"auto\" ? r = (n == null ? void 0 : n.url) && n.url.indexOf(\".json\") !== -1 : r = s.isTileset, r ? Np(e, t, n) : Up(e, t, n);\n}\n\nasync function Np(e, t, n) {\n  var s;\n  const r = JSON.parse(new TextDecoder().decode(e)),\n        i = (n == null ? void 0 : n.url) || \"\",\n        o = Hp(i),\n        a = await Lp(r, o, t || {});\n  return { ...r,\n    shape: \"tileset3d\",\n    loader: Le,\n    url: i,\n    queryString: (n == null ? void 0 : n.queryString) || \"\",\n    basePath: o,\n    root: a || r.root,\n    type: Md.TILES3D,\n    lodMetricType: Qn.GEOMETRIC_ERROR,\n    lodMetricValue: ((s = r.root) === null || s === void 0 ? void 0 : s.geometricError) || 0\n  };\n}\n\nasync function Up(e, t, n) {\n  const s = {\n    content: {\n      shape: \"tile3d\",\n      featureIds: null\n    }\n  };\n  return await uc(e, 0, t, n, s.content), s.content;\n}\n\nfunction Hp(e) {\n  return ea(e);\n}\n\nconst Tc = \"https://api.cesium.com/v1/assets\";\n\nasync function Jp(e, t) {\n  if (!t) {\n    const i = await Vp(e);\n\n    for (const o of i.items) o.type === \"3DTILES\" && (t = o.id);\n  }\n\n  const n = await jp(e, t),\n        {\n    type: s,\n    url: r\n  } = n;\n  return z(s === \"3DTILES\" && r), n.headers = {\n    Authorization: `Bearer ${n.accessToken}`\n  }, n;\n}\n\nasync function Vp(e) {\n  z(e);\n  const t = Tc,\n        n = {\n    Authorization: `Bearer ${e}`\n  },\n        s = await Ge(t, {\n    headers: n\n  });\n  if (!s.ok) throw new Error(s.statusText);\n  return await s.json();\n}\n\nasync function jp(e, t) {\n  z(e, t);\n  const n = {\n    Authorization: `Bearer ${e}`\n  },\n        s = `${Tc}/${t}`;\n  let r = await Ge(`${s}`, {\n    headers: n\n  });\n  if (!r.ok) throw new Error(r.statusText);\n  let i = await r.json();\n  if (r = await Ge(`${s}/endpoint`, {\n    headers: n\n  }), !r.ok) throw new Error(r.statusText);\n  const o = await r.json();\n  return i = { ...i,\n    ...o\n  }, i;\n}\n\nasync function kp(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  t = t[\"cesium-ion\"] || {};\n  const {\n    accessToken: n\n  } = t;\n  let s = t.assetId;\n\n  if (!Number.isFinite(s)) {\n    const r = e.match(/\\/([0-9]+)\\/tileset.json/);\n    s = r && r[1];\n  }\n\n  return Jp(n, s);\n}\n\nconst bc = { ...Le,\n  id: \"cesium-ion\",\n  name: \"Cesium Ion\",\n  preload: kp,\n  parse: async (e, t, n) => (t = { ...t\n  }, t[\"3d-tiles\"] = t[\"cesium-ion\"], t.loader = bc, Le.parse(e, t, n)),\n  options: {\n    \"cesium-ion\": { ...Le.options[\"3d-tiles\"],\n      accessToken: null\n    }\n  }\n},\n      mo = 100;\n\nclass Kp {\n  constructor(t, n) {\n    if (this.schema = void 0, this.options = void 0, this.shape = void 0, this.length = 0, this.rows = null, this.cursor = 0, this._headers = [], this.options = n, this.schema = t, !Array.isArray(t)) {\n      this._headers = [];\n\n      for (const s in t) this._headers[t[s].index] = t[s].name;\n    }\n  }\n\n  rowCount() {\n    return this.length;\n  }\n\n  addArrayRow(t, n) {\n    Number.isFinite(n) && (this.cursor = n), this.shape = \"array-row-table\", this.rows = this.rows || new Array(mo), this.rows[this.length] = t, this.length++;\n  }\n\n  addObjectRow(t, n) {\n    Number.isFinite(n) && (this.cursor = n), this.shape = \"object-row-table\", this.rows = this.rows || new Array(mo), this.rows[this.length] = t, this.length++;\n  }\n\n  getBatch() {\n    let t = this.rows;\n    return t ? (t = t.slice(0, this.length), this.rows = null, {\n      shape: this.shape || \"array-row-table\",\n      batchType: \"data\",\n      data: t,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    }) : null;\n  }\n\n}\n\nfunction zp(e, t) {\n  if (!e) throw new Error(\"null row\");\n  const n = {};\n  if (t) for (let s = 0; s < t.length; s++) n[t[s]] = e[s];else for (let s = 0; s < e.length; s++) {\n    const r = `column-${s}`;\n    n[r] = e[s];\n  }\n  return n;\n}\n\nfunction Wp(e, t) {\n  if (!e) throw new Error(\"null row\");\n\n  if (t) {\n    const n = new Array(t.length);\n\n    for (let s = 0; s < t.length; s++) n[s] = e[t[s]];\n\n    return n;\n  }\n\n  return Object.values(e);\n}\n\nfunction Xp(e) {\n  const t = [];\n\n  for (let n = 0; n < e.length; n++) {\n    const s = `column-${n}`;\n    t.push(s);\n  }\n\n  return t;\n}\n\nfunction Qp(e) {\n  return Object.keys(e);\n}\n\nconst go = 100;\n\nclass qp {\n  constructor(t, n) {\n    if (this.schema = void 0, this.options = void 0, this.length = 0, this.objectRows = null, this.arrayRows = null, this.cursor = 0, this._headers = null, this.options = n, this.schema = t, t) {\n      this._headers = [];\n\n      for (const s in t) this._headers[t[s].index] = t[s].name;\n    }\n  }\n\n  rowCount() {\n    return this.length;\n  }\n\n  addArrayRow(t, n) {\n    switch (Number.isFinite(n) && (this.cursor = n), this._headers || (this._headers = Xp(t)), this.options.shape) {\n      case \"object-row-table\":\n        const s = zp(t, this._headers);\n        this.addObjectRow(s, n);\n        break;\n\n      case \"array-row-table\":\n        this.arrayRows = this.arrayRows || new Array(go), this.arrayRows[this.length] = t, this.length++;\n        break;\n    }\n  }\n\n  addObjectRow(t, n) {\n    switch (Number.isFinite(n) && (this.cursor = n), this._headers || (this._headers = Qp(t)), this.options.shape) {\n      case \"array-row-table\":\n        const s = Wp(t, this._headers);\n        this.addArrayRow(s, n);\n        break;\n\n      case \"object-row-table\":\n        this.objectRows = this.objectRows || new Array(go), this.objectRows[this.length] = t, this.length++;\n        break;\n    }\n  }\n\n  getBatch() {\n    let t = this.arrayRows || this.objectRows;\n    return t ? (t = t.slice(0, this.length), this.arrayRows = null, this.objectRows = null, {\n      shape: this.options.shape,\n      batchType: \"data\",\n      data: t,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    }) : null;\n  }\n\n}\n\nconst Yp = 100;\n\nclass $p {\n  constructor(t, n) {\n    this.schema = void 0, this.length = 0, this.allocated = 0, this.columns = {}, this.schema = t, this._reallocateColumns();\n  }\n\n  rowCount() {\n    return this.length;\n  }\n\n  addArrayRow(t) {\n    this._reallocateColumns();\n\n    let n = 0;\n\n    for (const s in this.columns) this.columns[s][this.length] = t[n++];\n\n    this.length++;\n  }\n\n  addObjectRow(t) {\n    this._reallocateColumns();\n\n    for (const n in t) this.columns[n][this.length] = t[n];\n\n    this.length++;\n  }\n\n  getBatch() {\n    this._pruneColumns();\n\n    const t = Array.isArray(this.schema) ? this.columns : {};\n    if (!Array.isArray(this.schema)) for (const s in this.schema) {\n      const r = this.schema[s];\n      t[r.name] = this.columns[r.index];\n    }\n    return this.columns = {}, {\n      shape: \"columnar-table\",\n      batchType: \"data\",\n      data: t,\n      schema: this.schema,\n      length: this.length\n    };\n  }\n\n  _reallocateColumns() {\n    if (!(this.length < this.allocated)) {\n      this.allocated = this.allocated > 0 ? this.allocated *= 2 : Yp, this.columns = {};\n\n      for (const t in this.schema) {\n        const n = this.schema[t],\n              s = n.type || Float32Array,\n              r = this.columns[n.index];\n\n        if (r && ArrayBuffer.isView(r)) {\n          const i = new s(this.allocated);\n          i.set(r), this.columns[n.index] = i;\n        } else r ? (r.length = this.allocated, this.columns[n.index] = r) : this.columns[n.index] = new s(this.allocated);\n      }\n    }\n  }\n\n  _pruneColumns() {\n    for (const [t, n] of Object.entries(this.columns)) this.columns[t] = n.slice(0, this.length);\n  }\n\n}\n\nconst Zp = {\n  shape: void 0,\n  batchSize: \"auto\",\n  batchDebounceMs: 0,\n  limit: 0,\n  _limitMB: 0\n},\n      ty = \"TableBatchBuilder\";\n\nclass He {\n  constructor(t, n) {\n    this.schema = void 0, this.options = void 0, this.aggregator = null, this.batchCount = 0, this.bytesUsed = 0, this.isChunkComplete = !1, this.lastBatchEmittedMs = Date.now(), this.totalLength = 0, this.totalBytes = 0, this.rowBytes = 0, this.schema = t, this.options = { ...Zp,\n      ...n\n    };\n  }\n\n  limitReached() {\n    var t, n;\n    return !!(!((t = this.options) === null || t === void 0) && t.limit && this.totalLength >= this.options.limit || !((n = this.options) === null || n === void 0) && n._limitMB && this.totalBytes / 1e6 >= this.options._limitMB);\n  }\n\n  addRow(t) {\n    this.limitReached() || (this.totalLength++, this.rowBytes = this.rowBytes || this._estimateRowMB(t), this.totalBytes += this.rowBytes, Array.isArray(t) ? this.addArrayRow(t) : this.addObjectRow(t));\n  }\n\n  addArrayRow(t) {\n    if (!this.aggregator) {\n      const n = this._getTableBatchType();\n\n      this.aggregator = new n(this.schema, this.options);\n    }\n\n    this.aggregator.addArrayRow(t);\n  }\n\n  addObjectRow(t) {\n    if (!this.aggregator) {\n      const n = this._getTableBatchType();\n\n      this.aggregator = new n(this.schema, this.options);\n    }\n\n    this.aggregator.addObjectRow(t);\n  }\n\n  chunkComplete(t) {\n    t instanceof ArrayBuffer && (this.bytesUsed += t.byteLength), typeof t == \"string\" && (this.bytesUsed += t.length), this.isChunkComplete = !0;\n  }\n\n  getFullBatch(t) {\n    return this._isFull() ? this._getBatch(t) : null;\n  }\n\n  getFinalBatch(t) {\n    return this._getBatch(t);\n  }\n\n  _estimateRowMB(t) {\n    return Array.isArray(t) ? t.length * 8 : Object.keys(t).length * 8;\n  }\n\n  _isFull() {\n    if (!this.aggregator || this.aggregator.rowCount() === 0) return !1;\n\n    if (this.options.batchSize === \"auto\") {\n      if (!this.isChunkComplete) return !1;\n    } else if (this.options.batchSize > this.aggregator.rowCount()) return !1;\n\n    return this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs ? !1 : (this.isChunkComplete = !1, this.lastBatchEmittedMs = Date.now(), !0);\n  }\n\n  _getBatch(t) {\n    if (!this.aggregator) return null;\n    t != null && t.bytesUsed && (this.bytesUsed = t.bytesUsed);\n    const n = this.aggregator.getBatch();\n    return n.count = this.batchCount, n.bytesUsed = this.bytesUsed, Object.assign(n, t), this.batchCount++, this.aggregator = null, n;\n  }\n\n  _getTableBatchType() {\n    switch (this.options.shape) {\n      case \"array-row-table\":\n      case \"object-row-table\":\n        return qp;\n\n      case \"columnar-table\":\n        return $p;\n\n      case \"arrow-table\":\n        if (!He.ArrowBatch) throw new Error(ty);\n        return He.ArrowBatch;\n\n      default:\n        return Kp;\n    }\n  }\n\n}\n\nHe.ArrowBatch = void 0;\n\nfunction ey(e) {\n  try {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return async function* () {\n      const n = new TextDecoder(void 0, t);\n\n      for await (const s of e) yield typeof s == \"string\" ? s : n.decode(s, {\n        stream: !0\n      });\n    }();\n  } catch (t) {\n    return Promise.reject(t);\n  }\n}\n\nconst sr = Number.MAX_SAFE_INTEGER;\n\nvar S = function (e) {\n  return e[e.BEGIN = 0] = \"BEGIN\", e[e.VALUE = 1] = \"VALUE\", e[e.OPEN_OBJECT = 2] = \"OPEN_OBJECT\", e[e.CLOSE_OBJECT = 3] = \"CLOSE_OBJECT\", e[e.OPEN_ARRAY = 4] = \"OPEN_ARRAY\", e[e.CLOSE_ARRAY = 5] = \"CLOSE_ARRAY\", e[e.TEXT_ESCAPE = 6] = \"TEXT_ESCAPE\", e[e.STRING = 7] = \"STRING\", e[e.BACKSLASH = 8] = \"BACKSLASH\", e[e.END = 9] = \"END\", e[e.OPEN_KEY = 10] = \"OPEN_KEY\", e[e.CLOSE_KEY = 11] = \"CLOSE_KEY\", e[e.TRUE = 12] = \"TRUE\", e[e.TRUE2 = 13] = \"TRUE2\", e[e.TRUE3 = 14] = \"TRUE3\", e[e.FALSE = 15] = \"FALSE\", e[e.FALSE2 = 16] = \"FALSE2\", e[e.FALSE3 = 17] = \"FALSE3\", e[e.FALSE4 = 18] = \"FALSE4\", e[e.NULL = 19] = \"NULL\", e[e.NULL2 = 20] = \"NULL2\", e[e.NULL3 = 21] = \"NULL3\", e[e.NUMBER_DECIMAL_POINT = 22] = \"NUMBER_DECIMAL_POINT\", e[e.NUMBER_DIGIT = 23] = \"NUMBER_DIGIT\", e;\n}(S || {});\n\nconst I = {\n  tab: 9,\n  lineFeed: 10,\n  carriageReturn: 13,\n  space: 32,\n  doubleQuote: 34,\n  plus: 43,\n  comma: 44,\n  minus: 45,\n  period: 46,\n  _0: 48,\n  _9: 57,\n  colon: 58,\n  E: 69,\n  openBracket: 91,\n  backslash: 92,\n  closeBracket: 93,\n  a: 97,\n  b: 98,\n  e: 101,\n  f: 102,\n  l: 108,\n  n: 110,\n  r: 114,\n  s: 115,\n  t: 116,\n  u: 117,\n  openBrace: 123,\n  closeBrace: 125\n},\n      Ao = /[\\\\\"\\n]/g,\n      po = {\n  onready: () => {},\n  onopenobject: () => {},\n  onkey: () => {},\n  oncloseobject: () => {},\n  onopenarray: () => {},\n  onclosearray: () => {},\n  onvalue: () => {},\n  onerror: () => {},\n  onend: () => {},\n  onchunkparsed: () => {}\n};\n\nclass ny {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    this.options = po, this.bufferCheckPosition = sr, this.q = \"\", this.c = \"\", this.p = \"\", this.closed = !1, this.closedRoot = !1, this.sawRoot = !1, this.error = null, this.state = S.BEGIN, this.stack = [], this.position = 0, this.column = 0, this.line = 1, this.slashed = !1, this.unicodeI = 0, this.unicodeS = null, this.depth = 0, this.textNode = void 0, this.numberNode = void 0, this.options = { ...po,\n      ...t\n    }, this.textNode = void 0, this.numberNode = \"\", this.emit(\"onready\");\n  }\n\n  end() {\n    return (this.state !== S.VALUE || this.depth !== 0) && this._error(\"Unexpected end\"), this._closeValue(), this.c = \"\", this.closed = !0, this.emit(\"onend\"), this;\n  }\n\n  resume() {\n    return this.error = null, this;\n  }\n\n  close() {\n    return this.write(null);\n  }\n\n  emit(t, n) {\n    var s, r;\n    (s = (r = this.options)[t]) === null || s === void 0 || s.call(r, n, this);\n  }\n\n  emitNode(t, n) {\n    this._closeValue(), this.emit(t, n);\n  }\n\n  write(t) {\n    if (this.error) throw this.error;\n    if (this.closed) return this._error(\"Cannot write after close. Assign an onready handler.\");\n    if (t === null) return this.end();\n    let n = 0,\n        s = t.charCodeAt(0),\n        r = this.p;\n\n    for (; s && (r = s, this.c = s = t.charCodeAt(n++), r !== s ? this.p = r : r = this.p, !!s);) switch (this.position++, s === I.lineFeed ? (this.line++, this.column = 0) : this.column++, this.state) {\n      case S.BEGIN:\n        s === I.openBrace ? this.state = S.OPEN_OBJECT : s === I.openBracket ? this.state = S.OPEN_ARRAY : Se(s) || this._error(\"Non-whitespace before {[.\");\n        continue;\n\n      case S.OPEN_KEY:\n      case S.OPEN_OBJECT:\n        if (Se(s)) continue;\n        if (this.state === S.OPEN_KEY) this.stack.push(S.CLOSE_KEY);else if (s === I.closeBrace) {\n          this.emit(\"onopenobject\"), this.depth++, this.emit(\"oncloseobject\"), this.depth--, this.state = this.stack.pop() || S.VALUE;\n          continue;\n        } else this.stack.push(S.CLOSE_OBJECT);\n        s === I.doubleQuote ? this.state = S.STRING : this._error('Malformed object key should start with \"');\n        continue;\n\n      case S.CLOSE_KEY:\n      case S.CLOSE_OBJECT:\n        if (Se(s)) continue;\n        s === I.colon ? (this.state === S.CLOSE_OBJECT ? (this.stack.push(S.CLOSE_OBJECT), this._closeValue(\"onopenobject\"), this.depth++) : this._closeValue(\"onkey\"), this.state = S.VALUE) : s === I.closeBrace ? (this.emitNode(\"oncloseobject\"), this.depth--, this.state = this.stack.pop() || S.VALUE) : s === I.comma ? (this.state === S.CLOSE_OBJECT && this.stack.push(S.CLOSE_OBJECT), this._closeValue(), this.state = S.OPEN_KEY) : this._error(\"Bad object\");\n        continue;\n\n      case S.OPEN_ARRAY:\n      case S.VALUE:\n        if (Se(s)) continue;\n        if (this.state === S.OPEN_ARRAY) if (this.emit(\"onopenarray\"), this.depth++, this.state = S.VALUE, s === I.closeBracket) {\n          this.emit(\"onclosearray\"), this.depth--, this.state = this.stack.pop() || S.VALUE;\n          continue;\n        } else this.stack.push(S.CLOSE_ARRAY);\n        s === I.doubleQuote ? this.state = S.STRING : s === I.openBrace ? this.state = S.OPEN_OBJECT : s === I.openBracket ? this.state = S.OPEN_ARRAY : s === I.t ? this.state = S.TRUE : s === I.f ? this.state = S.FALSE : s === I.n ? this.state = S.NULL : s === I.minus ? this.numberNode += \"-\" : I._0 <= s && s <= I._9 ? (this.numberNode += String.fromCharCode(s), this.state = S.NUMBER_DIGIT) : this._error(\"Bad value\");\n        continue;\n\n      case S.CLOSE_ARRAY:\n        if (s === I.comma) this.stack.push(S.CLOSE_ARRAY), this._closeValue(\"onvalue\"), this.state = S.VALUE;else if (s === I.closeBracket) this.emitNode(\"onclosearray\"), this.depth--, this.state = this.stack.pop() || S.VALUE;else {\n          if (Se(s)) continue;\n\n          this._error(\"Bad array\");\n        }\n        continue;\n\n      case S.STRING:\n        this.textNode === void 0 && (this.textNode = \"\");\n        let i = n - 1,\n            o = this.slashed,\n            a = this.unicodeI;\n\n        t: for (;;) {\n          for (; a > 0;) if (this.unicodeS += String.fromCharCode(s), s = t.charCodeAt(n++), this.position++, a === 4 ? (this.textNode += String.fromCharCode(parseInt(this.unicodeS, 16)), a = 0, i = n - 1) : a++, !s) break t;\n\n          if (s === I.doubleQuote && !o) {\n            this.state = this.stack.pop() || S.VALUE, this.textNode += t.substring(i, n - 1), this.position += n - 1 - i;\n            break;\n          }\n\n          if (s === I.backslash && !o && (o = !0, this.textNode += t.substring(i, n - 1), this.position += n - 1 - i, s = t.charCodeAt(n++), this.position++, !s)) break;\n\n          if (o) {\n            if (o = !1, s === I.n ? this.textNode += `\n` : s === I.r ? this.textNode += \"\\r\" : s === I.t ? this.textNode += \"\t\" : s === I.f ? this.textNode += \"\\f\" : s === I.b ? this.textNode += \"\\b\" : s === I.u ? (a = 1, this.unicodeS = \"\") : this.textNode += String.fromCharCode(s), s = t.charCodeAt(n++), this.position++, i = n - 1, s) continue;\n            break;\n          }\n\n          Ao.lastIndex = n;\n          const c = Ao.exec(t);\n\n          if (c === null) {\n            n = t.length + 1, this.textNode += t.substring(i, n - 1), this.position += n - 1 - i;\n            break;\n          }\n\n          if (n = c.index + 1, s = t.charCodeAt(c.index), !s) {\n            this.textNode += t.substring(i, n - 1), this.position += n - 1 - i;\n            break;\n          }\n        }\n\n        this.slashed = o, this.unicodeI = a;\n        continue;\n\n      case S.TRUE:\n        s === I.r ? this.state = S.TRUE2 : this._error(`Invalid true started with t${s}`);\n        continue;\n\n      case S.TRUE2:\n        s === I.u ? this.state = S.TRUE3 : this._error(`Invalid true started with tr${s}`);\n        continue;\n\n      case S.TRUE3:\n        s === I.e ? (this.emit(\"onvalue\", !0), this.state = this.stack.pop() || S.VALUE) : this._error(`Invalid true started with tru${s}`);\n        continue;\n\n      case S.FALSE:\n        s === I.a ? this.state = S.FALSE2 : this._error(`Invalid false started with f${s}`);\n        continue;\n\n      case S.FALSE2:\n        s === I.l ? this.state = S.FALSE3 : this._error(`Invalid false started with fa${s}`);\n        continue;\n\n      case S.FALSE3:\n        s === I.s ? this.state = S.FALSE4 : this._error(`Invalid false started with fal${s}`);\n        continue;\n\n      case S.FALSE4:\n        s === I.e ? (this.emit(\"onvalue\", !1), this.state = this.stack.pop() || S.VALUE) : this._error(`Invalid false started with fals${s}`);\n        continue;\n\n      case S.NULL:\n        s === I.u ? this.state = S.NULL2 : this._error(`Invalid null started with n${s}`);\n        continue;\n\n      case S.NULL2:\n        s === I.l ? this.state = S.NULL3 : this._error(`Invalid null started with nu${s}`);\n        continue;\n\n      case S.NULL3:\n        s === I.l ? (this.emit(\"onvalue\", null), this.state = this.stack.pop() || S.VALUE) : this._error(`Invalid null started with nul${s}`);\n        continue;\n\n      case S.NUMBER_DECIMAL_POINT:\n        s === I.period ? (this.numberNode += \".\", this.state = S.NUMBER_DIGIT) : this._error(\"Leading zero not followed by .\");\n        continue;\n\n      case S.NUMBER_DIGIT:\n        I._0 <= s && s <= I._9 ? this.numberNode += String.fromCharCode(s) : s === I.period ? (this.numberNode.indexOf(\".\") !== -1 && this._error(\"Invalid number has two dots\"), this.numberNode += \".\") : s === I.e || s === I.E ? ((this.numberNode.indexOf(\"e\") !== -1 || this.numberNode.indexOf(\"E\") !== -1) && this._error(\"Invalid number has two exponential\"), this.numberNode += \"e\") : s === I.plus || s === I.minus ? (r === I.e || r === I.E || this._error(\"Invalid symbol in number\"), this.numberNode += String.fromCharCode(s)) : (this._closeNumber(), n--, this.state = this.stack.pop() || S.VALUE);\n        continue;\n\n      default:\n        this._error(`Unknown state: ${this.state}`);\n\n    }\n\n    return this.position >= this.bufferCheckPosition && sy(this), this.emit(\"onchunkparsed\"), this;\n  }\n\n  _closeValue() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"onvalue\";\n    this.textNode !== void 0 && this.emit(t, this.textNode), this.textNode = void 0;\n  }\n\n  _closeNumber() {\n    this.numberNode && this.emit(\"onvalue\", parseFloat(this.numberNode)), this.numberNode = \"\";\n  }\n\n  _error() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n    this._closeValue(), t += `\nLine: ${this.line}\nColumn: ${this.column}\nChar: ${this.c}`;\n    const n = new Error(t);\n    this.error = n, this.emit(\"onerror\", n);\n  }\n\n}\n\nfunction Se(e) {\n  return e === I.carriageReturn || e === I.lineFeed || e === I.space || e === I.tab;\n}\n\nfunction sy(e) {\n  const t = Math.max(sr, 10);\n  let n = 0;\n\n  for (const s of [\"textNode\", \"numberNode\"]) {\n    const r = e[s] === void 0 ? 0 : e[s].length;\n    if (r > t) switch (s) {\n      case \"text\":\n        break;\n\n      default:\n        e._error(`Max buffer length exceeded: ${s}`);\n\n    }\n    n = Math.max(n, r);\n  }\n\n  e.bufferCheckPosition = sr - n + e.position;\n}\n\nclass te {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n\n    if (this.path = void 0, this.path = [\"$\"], t instanceof te) {\n      this.path = [...t.path];\n      return;\n    }\n\n    if (Array.isArray(t)) {\n      this.path.push(...t);\n      return;\n    }\n\n    if (typeof t == \"string\" && (this.path = t.split(\".\"), this.path[0] !== \"$\")) throw new Error(\"JSONPaths must start with $\");\n  }\n\n  clone() {\n    return new te(this);\n  }\n\n  toString() {\n    return this.path.join(\".\");\n  }\n\n  push(t) {\n    this.path.push(t);\n  }\n\n  pop() {\n    return this.path.pop();\n  }\n\n  set(t) {\n    this.path[this.path.length - 1] = t;\n  }\n\n  equals(t) {\n    if (!this || !t || this.path.length !== t.path.length) return !1;\n\n    for (let n = 0; n < this.path.length; ++n) if (this.path[n] !== t.path[n]) return !1;\n\n    return !0;\n  }\n\n  setFieldAtPath(t, n) {\n    const s = [...this.path];\n    s.shift();\n    const r = s.pop();\n\n    for (const i of s) t = t[i];\n\n    t[r] = n;\n  }\n\n  getFieldAtPath(t) {\n    const n = [...this.path];\n    n.shift();\n    const s = n.pop();\n\n    for (const r of n) t = t[r];\n\n    return t[s];\n  }\n\n}\n\nclass ry {\n  constructor(t) {\n    this.parser = void 0, this.result = void 0, this.previousStates = [], this.currentState = Object.freeze({\n      container: [],\n      key: null\n    }), this.jsonpath = new te(), this.reset(), this.parser = new ny({\n      onready: () => {\n        this.jsonpath = new te(), this.previousStates.length = 0, this.currentState.container.length = 0;\n      },\n      onopenobject: n => {\n        this._openObject({}), typeof n < \"u\" && this.parser.emit(\"onkey\", n);\n      },\n      onkey: n => {\n        this.jsonpath.set(n), this.currentState.key = n;\n      },\n      oncloseobject: () => {\n        this._closeObject();\n      },\n      onopenarray: () => {\n        this._openArray();\n      },\n      onclosearray: () => {\n        this._closeArray();\n      },\n      onvalue: n => {\n        this._pushOrSet(n);\n      },\n      onerror: n => {\n        throw n;\n      },\n      onend: () => {\n        this.result = this.currentState.container.pop();\n      },\n      ...t\n    });\n  }\n\n  reset() {\n    this.result = void 0, this.previousStates = [], this.currentState = Object.freeze({\n      container: [],\n      key: null\n    }), this.jsonpath = new te();\n  }\n\n  write(t) {\n    this.parser.write(t);\n  }\n\n  close() {\n    this.parser.close();\n  }\n\n  _pushOrSet(t) {\n    const {\n      container: n,\n      key: s\n    } = this.currentState;\n    s !== null ? (n[s] = t, this.currentState.key = null) : n.push(t);\n  }\n\n  _openArray() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    this.jsonpath.push(null), this._pushOrSet(t), this.previousStates.push(this.currentState), this.currentState = {\n      container: t,\n      isArray: !0,\n      key: null\n    };\n  }\n\n  _closeArray() {\n    this.jsonpath.pop(), this.currentState = this.previousStates.pop();\n  }\n\n  _openObject() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    this.jsonpath.push(null), this._pushOrSet(t), this.previousStates.push(this.currentState), this.currentState = {\n      container: t,\n      isArray: !1,\n      key: null\n    };\n  }\n\n  _closeObject() {\n    this.jsonpath.pop(), this.currentState = this.previousStates.pop();\n  }\n\n}\n\nclass iy extends ry {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    super({\n      onopenarray: () => {\n        if (!this.streamingArray && this._matchJSONPath()) {\n          this.streamingJsonPath = this.getJsonPath().clone(), this.streamingArray = [], this._openArray(this.streamingArray);\n          return;\n        }\n\n        this._openArray();\n      },\n      onopenobject: s => {\n        this.topLevelObject ? this._openObject({}) : (this.topLevelObject = {}, this._openObject(this.topLevelObject)), typeof s < \"u\" && this.parser.emit(\"onkey\", s);\n      }\n    }), this.jsonPaths = void 0, this.streamingJsonPath = null, this.streamingArray = null, this.topLevelObject = null;\n    const n = t.jsonpaths || [];\n    this.jsonPaths = n.map(s => new te(s));\n  }\n\n  write(t) {\n    super.write(t);\n    let n = [];\n    return this.streamingArray && (n = [...this.streamingArray], this.streamingArray.length = 0), n;\n  }\n\n  getPartialResult() {\n    return this.topLevelObject;\n  }\n\n  getStreamingJsonPath() {\n    return this.streamingJsonPath;\n  }\n\n  getStreamingJsonPathAsString() {\n    return this.streamingJsonPath && this.streamingJsonPath.toString();\n  }\n\n  getJsonPath() {\n    return this.jsonpath;\n  }\n\n  _matchJSONPath() {\n    const t = this.getJsonPath();\n    if (this.jsonPaths.length === 0) return !0;\n\n    for (const n of this.jsonPaths) if (n.equals(t)) return !0;\n\n    return !1;\n  }\n\n}\n\nasync function* oy(e, t) {\n  const n = ey(e),\n        {\n    metadata: s\n  } = t,\n        {\n    jsonpaths: r\n  } = t.json || {};\n  let i = !0;\n  const o = null,\n        a = new He(o, t),\n        c = new iy({\n    jsonpaths: r\n  });\n\n  for await (const f of n) {\n    const d = c.write(f),\n          m = d.length > 0 && c.getStreamingJsonPathAsString();\n\n    if (d.length > 0 && i) {\n      if (s) {\n        var u;\n        yield {\n          shape: (t == null || (u = t.json) === null || u === void 0 ? void 0 : u.shape) || \"array-row-table\",\n          batchType: \"partial-result\",\n          data: [],\n          length: 0,\n          bytesUsed: 0,\n          container: c.getPartialResult(),\n          jsonpath: m\n        };\n      }\n\n      i = !1;\n    }\n\n    for (const y of d) {\n      a.addRow(y);\n      const E = a.getFullBatch({\n        jsonpath: m\n      });\n      E && (yield E);\n    }\n\n    a.chunkComplete(f);\n    const g = a.getFullBatch({\n      jsonpath: m\n    });\n    g && (yield g);\n  }\n\n  const l = c.getStreamingJsonPathAsString(),\n        h = a.getFinalBatch({\n    jsonpath: l\n  });\n  h && (yield h), s && (yield {\n    shape: \"json\",\n    batchType: \"final-result\",\n    container: c.getPartialResult(),\n    jsonpath: c.getStreamingJsonPathAsString(),\n    data: [],\n    length: 0\n  });\n}\n\nconst Hn = {\n  x: 0,\n  y: 1,\n  z: 2\n};\n\nfunction _c(e, t = {}) {\n  const {\n    start: n = 0,\n    end: s = e.length,\n    plane: r = \"xy\"\n  } = t,\n        i = t.size || 2;\n  let o = 0;\n  const a = Hn[r[0]],\n        c = Hn[r[1]];\n\n  for (let u = n, l = s - i; u < s; u += i) o += (e[u + a] - e[l + a]) * (e[u + c] + e[l + c]), l = u;\n\n  return o / 2;\n}\n\nfunction ay(e, t, n = 2, s, r = \"xy\") {\n  const i = t && t.length,\n        o = i ? t[0] * n : e.length;\n  let a = wc(e, 0, o, n, !0, s && s[0], r);\n  const c = [];\n  if (!a || a.next === a.prev) return c;\n  let u, l, h, f, d, m, g;\n\n  if (i && (a = fy(e, t, a, n, s, r)), e.length > 80 * n) {\n    f = l = e[0], d = h = e[1];\n\n    for (let y = n; y < o; y += n) m = e[y], g = e[y + 1], m < f && (f = m), g < d && (d = g), m > l && (l = m), g > h && (h = g);\n\n    u = Math.max(l - f, h - d), u = u !== 0 ? 32767 / u : 0;\n  }\n\n  return Je(a, c, n, f, d, u, 0), c;\n}\n\nfunction wc(e, t, n, s, r, i, o) {\n  let a, c;\n  i === void 0 && (i = _c(e, {\n    start: t,\n    end: n,\n    size: s,\n    plane: o\n  }));\n  let u = Hn[o[0]],\n      l = Hn[o[1]];\n  if (r === i < 0) for (a = t; a < n; a += s) c = yo(a, e[a + u], e[a + l], c);else for (a = n - s; a >= t; a -= s) c = yo(a, e[a + u], e[a + l], c);\n  return c && Zn(c, c.next) && (je(c), c = c.next), c;\n}\n\nfunction ne(e, t) {\n  if (!e) return e;\n  t || (t = e);\n  let n = e,\n      s;\n\n  do if (s = !1, !n.steiner && (Zn(n, n.next) || W(n.prev, n, n.next) === 0)) {\n    if (je(n), n = t = n.prev, n === n.next) break;\n    s = !0;\n  } else n = n.next; while (s || n !== t);\n\n  return t;\n}\n\nfunction Je(e, t, n, s, r, i, o) {\n  if (!e) return;\n  !o && i && py(e, s, r, i);\n  let a = e,\n      c,\n      u;\n\n  for (; e.prev !== e.next;) {\n    if (c = e.prev, u = e.next, i ? uy(e, s, r, i) : cy(e)) {\n      t.push(c.i / n | 0), t.push(e.i / n | 0), t.push(u.i / n | 0), je(e), e = u.next, a = u.next;\n      continue;\n    }\n\n    if (e = u, e === a) {\n      o ? o === 1 ? (e = ly(ne(e), t, n), Je(e, t, n, s, r, i, 2)) : o === 2 && hy(e, t, n, s, r, i) : Je(ne(e), t, n, s, r, i, 1);\n      break;\n    }\n  }\n}\n\nfunction cy(e) {\n  const t = e.prev,\n        n = e,\n        s = e.next;\n  if (W(t, n, s) >= 0) return !1;\n  const r = t.x,\n        i = n.x,\n        o = s.x,\n        a = t.y,\n        c = n.y,\n        u = s.y,\n        l = r < i ? r < o ? r : o : i < o ? i : o,\n        h = a < c ? a < u ? a : u : c < u ? c : u,\n        f = r > i ? r > o ? r : o : i > o ? i : o,\n        d = a > c ? a > u ? a : u : c > u ? c : u;\n  let m = s.next;\n\n  for (; m !== t;) {\n    if (m.x >= l && m.x <= f && m.y >= h && m.y <= d && me(r, a, i, c, o, u, m.x, m.y) && W(m.prev, m, m.next) >= 0) return !1;\n    m = m.next;\n  }\n\n  return !0;\n}\n\nfunction uy(e, t, n, s) {\n  const r = e.prev,\n        i = e,\n        o = e.next;\n  if (W(r, i, o) >= 0) return !1;\n  const a = r.x,\n        c = i.x,\n        u = o.x,\n        l = r.y,\n        h = i.y,\n        f = o.y,\n        d = a < c ? a < u ? a : u : c < u ? c : u,\n        m = l < h ? l < f ? l : f : h < f ? h : f,\n        g = a > c ? a > u ? a : u : c > u ? c : u,\n        y = l > h ? l > f ? l : f : h > f ? h : f,\n        E = rr(d, m, t, n, s),\n        R = rr(g, y, t, n, s);\n  let B = e.prevZ,\n      C = e.nextZ;\n\n  for (; B && B.z >= E && C && C.z <= R;) {\n    if (B.x >= d && B.x <= g && B.y >= m && B.y <= y && B !== r && B !== o && me(a, l, c, h, u, f, B.x, B.y) && W(B.prev, B, B.next) >= 0 || (B = B.prevZ, C.x >= d && C.x <= g && C.y >= m && C.y <= y && C !== r && C !== o && me(a, l, c, h, u, f, C.x, C.y) && W(C.prev, C, C.next) >= 0)) return !1;\n    C = C.nextZ;\n  }\n\n  for (; B && B.z >= E;) {\n    if (B.x >= d && B.x <= g && B.y >= m && B.y <= y && B !== r && B !== o && me(a, l, c, h, u, f, B.x, B.y) && W(B.prev, B, B.next) >= 0) return !1;\n    B = B.prevZ;\n  }\n\n  for (; C && C.z <= R;) {\n    if (C.x >= d && C.x <= g && C.y >= m && C.y <= y && C !== r && C !== o && me(a, l, c, h, u, f, C.x, C.y) && W(C.prev, C, C.next) >= 0) return !1;\n    C = C.nextZ;\n  }\n\n  return !0;\n}\n\nfunction ly(e, t, n) {\n  let s = e;\n\n  do {\n    const r = s.prev,\n          i = s.next.next;\n    !Zn(r, i) && Rc(r, s, s.next, i) && Ve(r, i) && Ve(i, r) && (t.push(r.i / n | 0), t.push(s.i / n | 0), t.push(i.i / n | 0), je(s), je(s.next), s = e = i), s = s.next;\n  } while (s !== e);\n\n  return ne(s);\n}\n\nfunction hy(e, t, n, s, r, i) {\n  let o = e;\n\n  do {\n    let a = o.next.next;\n\n    for (; a !== o.prev;) {\n      if (o.i !== a.i && Cy(o, a)) {\n        let c = Mc(o, a);\n        o = ne(o, o.next), c = ne(c, c.next), Je(o, t, n, s, r, i, 0), Je(c, t, n, s, r, i, 0);\n        return;\n      }\n\n      a = a.next;\n    }\n\n    o = o.next;\n  } while (o !== e);\n}\n\nfunction fy(e, t, n, s, r, i) {\n  const o = [];\n  let a, c, u, l, h;\n\n  for (a = 0, c = t.length; a < c; a++) u = t[a] * s, l = a < c - 1 ? t[a + 1] * s : e.length, h = wc(e, u, l, s, !1, r && r[a + 1], i), h === h.next && (h.steiner = !0), o.push(By(h));\n\n  for (o.sort(dy), a = 0; a < o.length; a++) n = my(o[a], n);\n\n  return n;\n}\n\nfunction dy(e, t) {\n  return e.x - t.x;\n}\n\nfunction my(e, t) {\n  const n = gy(e, t);\n  if (!n) return t;\n  const s = Mc(n, e);\n  return ne(s, s.next), ne(n, n.next);\n}\n\nfunction gy(e, t) {\n  let n = t;\n  const s = e.x,\n        r = e.y;\n  let i = -1 / 0,\n      o;\n\n  do {\n    if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {\n      const f = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);\n      if (f <= s && f > i && (i = f, o = n.x < n.next.x ? n : n.next, f === s)) return o;\n    }\n\n    n = n.next;\n  } while (n !== t);\n\n  if (!o) return null;\n  const a = o,\n        c = o.x,\n        u = o.y;\n  let l = 1 / 0,\n      h;\n  n = o;\n\n  do s >= n.x && n.x >= c && s !== n.x && me(r < u ? s : i, r, c, u, r < u ? i : s, r, n.x, n.y) && (h = Math.abs(r - n.y) / (s - n.x), Ve(n, e) && (h < l || h === l && (n.x > o.x || n.x === o.x && Ay(o, n))) && (o = n, l = h)), n = n.next; while (n !== a);\n\n  return o;\n}\n\nfunction Ay(e, t) {\n  return W(e.prev, e, t.prev) < 0 && W(t.next, e, e.next) < 0;\n}\n\nfunction py(e, t, n, s) {\n  let r = e;\n\n  do r.z === 0 && (r.z = rr(r.x, r.y, t, n, s)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next; while (r !== e);\n\n  r.prevZ.nextZ = null, r.prevZ = null, yy(r);\n}\n\nfunction yy(e) {\n  let t,\n      n,\n      s = 1,\n      r,\n      i,\n      o,\n      a,\n      c,\n      u;\n\n  do {\n    for (i = e, e = null, u = null, r = 0; i;) {\n      for (r++, a = i, o = 0, n = 0; n < s && (o++, a = a.nextZ, !!a); n++);\n\n      for (c = s; o > 0 || c > 0 && a;) o !== 0 && (c === 0 || !a || i.z <= a.z) ? (t = i, i = i.nextZ, o--) : (t = a, a = a.nextZ, c--), u ? u.nextZ = t : e = t, t.prevZ = u, u = t;\n\n      i = a;\n    }\n\n    u.nextZ = null, s *= 2;\n  } while (r > 1);\n\n  return e;\n}\n\nfunction rr(e, t, n, s, r) {\n  return e = (e - n) * r | 0, t = (t - s) * r | 0, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e | t << 1;\n}\n\nfunction By(e) {\n  let t = e,\n      n = e;\n\n  do (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next; while (t !== e);\n\n  return n;\n}\n\nfunction me(e, t, n, s, r, i, o, a) {\n  return (r - o) * (t - a) >= (e - o) * (i - a) && (e - o) * (s - a) >= (n - o) * (t - a) && (n - o) * (i - a) >= (r - o) * (s - a);\n}\n\nfunction Cy(e, t) {\n  return e.next.i !== t.i && e.prev.i !== t.i && !Ey(e, t) && ( // dones't intersect other edges\n  Ve(e, t) && Ve(t, e) && Ty(e, t) && ( // locally visible\n  W(e.prev, e, t.prev) || W(e, t.prev, t)) || // does not create opposite-facing sectors\n  Zn(e, t) && W(e.prev, e, e.next) > 0 && W(t.prev, t, t.next) > 0);\n}\n\nfunction W(e, t, n) {\n  return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);\n}\n\nfunction Zn(e, t) {\n  return e.x === t.x && e.y === t.y;\n}\n\nfunction Rc(e, t, n, s) {\n  const r = Bn(W(e, t, n)),\n        i = Bn(W(e, t, s)),\n        o = Bn(W(n, s, e)),\n        a = Bn(W(n, s, t));\n  return !!(r !== i && o !== a || r === 0 && yn(e, n, t) || i === 0 && yn(e, s, t) || o === 0 && yn(n, e, s) || a === 0 && yn(n, t, s));\n}\n\nfunction yn(e, t, n) {\n  return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y);\n}\n\nfunction Bn(e) {\n  return e > 0 ? 1 : e < 0 ? -1 : 0;\n}\n\nfunction Ey(e, t) {\n  let n = e;\n\n  do {\n    if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Rc(n, n.next, e, t)) return !0;\n    n = n.next;\n  } while (n !== e);\n\n  return !1;\n}\n\nfunction Ve(e, t) {\n  return W(e.prev, e, e.next) < 0 ? W(e, t, e.next) >= 0 && W(e, e.prev, t) >= 0 : W(e, t, e.prev) < 0 || W(e, e.next, t) < 0;\n}\n\nfunction Ty(e, t) {\n  let n = e,\n      s = !1;\n  const r = (e.x + t.x) / 2,\n        i = (e.y + t.y) / 2;\n\n  do n.y > i != n.next.y > i && n.next.y !== n.y && r < (n.next.x - n.x) * (i - n.y) / (n.next.y - n.y) + n.x && (s = !s), n = n.next; while (n !== e);\n\n  return s;\n}\n\nfunction Mc(e, t) {\n  const n = new ir(e.i, e.x, e.y),\n        s = new ir(t.i, t.x, t.y),\n        r = e.next,\n        i = t.prev;\n  return e.next = t, t.prev = e, n.next = r, r.prev = n, s.next = n, n.prev = s, i.next = s, s.prev = i, s;\n}\n\nfunction yo(e, t, n, s) {\n  const r = new ir(e, t, n);\n  return s ? (r.next = s.next, r.prev = s, s.next.prev = r, s.next = r) : (r.prev = r, r.next = r), r;\n}\n\nfunction je(e) {\n  e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ);\n}\n\nclass ir {\n  constructor(t, n, s) {\n    this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1, this.i = t, this.x = n, this.y = s;\n  }\n\n}\n\nfunction by(e, t, n) {\n  const s = _y(e),\n        r = Object.keys(s).filter(i => s[i] !== Array);\n\n  return wy(e, {\n    propArrayTypes: s,\n    ...t\n  }, {\n    numericPropKeys: n && n.numericPropKeys || r,\n    PositionDataType: n ? n.PositionDataType : Float32Array,\n    triangulate: n ? n.triangulate : !0\n  });\n}\n\nfunction _y(e) {\n  const t = {};\n\n  for (const n of e) if (n.properties) for (const s in n.properties) {\n    const r = n.properties[s];\n    t[s] = vy(r, t[s]);\n  }\n\n  return t;\n}\n\nfunction wy(e, t, n) {\n  const {\n    pointPositionsCount: s,\n    pointFeaturesCount: r,\n    linePositionsCount: i,\n    linePathsCount: o,\n    lineFeaturesCount: a,\n    polygonPositionsCount: c,\n    polygonObjectsCount: u,\n    polygonRingsCount: l,\n    polygonFeaturesCount: h,\n    propArrayTypes: f,\n    coordLength: d\n  } = t,\n        {\n    numericPropKeys: m = [],\n    PositionDataType: g = Float32Array,\n    triangulate: y = !0\n  } = n,\n        E = e[0] && \"id\" in e[0],\n        R = e.length > 65535 ? Uint32Array : Uint16Array,\n        B = {\n    type: \"Point\",\n    positions: new g(s * d),\n    globalFeatureIds: new R(s),\n    featureIds: r > 65535 ? new Uint32Array(s) : new Uint16Array(s),\n    numericProps: {},\n    properties: [],\n    fields: []\n  },\n        C = {\n    type: \"LineString\",\n    pathIndices: i > 65535 ? new Uint32Array(o + 1) : new Uint16Array(o + 1),\n    positions: new g(i * d),\n    globalFeatureIds: new R(i),\n    featureIds: a > 65535 ? new Uint32Array(i) : new Uint16Array(i),\n    numericProps: {},\n    properties: [],\n    fields: []\n  },\n        M = {\n    type: \"Polygon\",\n    polygonIndices: c > 65535 ? new Uint32Array(u + 1) : new Uint16Array(u + 1),\n    primitivePolygonIndices: c > 65535 ? new Uint32Array(l + 1) : new Uint16Array(l + 1),\n    positions: new g(c * d),\n    globalFeatureIds: new R(c),\n    featureIds: h > 65535 ? new Uint32Array(c) : new Uint16Array(c),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  y && (M.triangles = []);\n\n  for (const O of [B, C, M]) for (const F of m) {\n    const v = f[F];\n    O.numericProps[F] = new v(O.positions.length / d);\n  }\n\n  C.pathIndices[o] = i, M.polygonIndices[u] = c, M.primitivePolygonIndices[l] = c;\n  const b = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n\n  for (const O of e) {\n    const F = O.geometry,\n          v = O.properties || {};\n\n    switch (F.type) {\n      case \"Point\":\n        Ry(F, B, b, d, v), B.properties.push(xs(v, m)), E && B.fields.push({\n          id: O.id\n        }), b.pointFeature++;\n        break;\n\n      case \"LineString\":\n        My(F, C, b, d, v), C.properties.push(xs(v, m)), E && C.fields.push({\n          id: O.id\n        }), b.lineFeature++;\n        break;\n\n      case \"Polygon\":\n        Sy(F, M, b, d, v), M.properties.push(xs(v, m)), E && M.fields.push({\n          id: O.id\n        }), b.polygonFeature++;\n        break;\n\n      default:\n        throw new Error(\"Invalid geometry type\");\n    }\n\n    b.feature++;\n  }\n\n  return xy(B, C, M, d);\n}\n\nfunction Ry(e, t, n, s, r) {\n  t.positions.set(e.data, n.pointPosition * s);\n  const i = e.data.length / s;\n  Hr(t, r, n.pointPosition, i), t.globalFeatureIds.fill(n.feature, n.pointPosition, n.pointPosition + i), t.featureIds.fill(n.pointFeature, n.pointPosition, n.pointPosition + i), n.pointPosition += i;\n}\n\nfunction My(e, t, n, s, r) {\n  t.positions.set(e.data, n.linePosition * s);\n  const i = e.data.length / s;\n  Hr(t, r, n.linePosition, i), t.globalFeatureIds.fill(n.feature, n.linePosition, n.linePosition + i), t.featureIds.fill(n.lineFeature, n.linePosition, n.linePosition + i);\n\n  for (let o = 0, a = e.indices.length; o < a; ++o) {\n    const c = e.indices[o],\n          u = o === a - 1 ? e.data.length : e.indices[o + 1];\n    t.pathIndices[n.linePath++] = n.linePosition, n.linePosition += (u - c) / s;\n  }\n}\n\nfunction Sy(e, t, n, s, r) {\n  t.positions.set(e.data, n.polygonPosition * s);\n  const i = e.data.length / s;\n  Hr(t, r, n.polygonPosition, i), t.globalFeatureIds.fill(n.feature, n.polygonPosition, n.polygonPosition + i), t.featureIds.fill(n.polygonFeature, n.polygonPosition, n.polygonPosition + i);\n\n  for (let o = 0, a = e.indices.length; o < a; ++o) {\n    const c = n.polygonPosition;\n    t.polygonIndices[n.polygonObject++] = c;\n    const u = e.areas[o],\n          l = e.indices[o],\n          h = e.indices[o + 1];\n\n    for (let d = 0, m = l.length; d < m; ++d) {\n      const g = l[d],\n            y = d === m - 1 ? h === void 0 ? e.data.length : h[0] : l[d + 1];\n      t.primitivePolygonIndices[n.polygonRing++] = n.polygonPosition, n.polygonPosition += (y - g) / s;\n    }\n\n    const f = n.polygonPosition;\n    Iy(t, u, l, {\n      startPosition: c,\n      endPosition: f,\n      coordLength: s\n    });\n  }\n}\n\nfunction Iy(e, t, n, s) {\n  let {\n    startPosition: r,\n    endPosition: i,\n    coordLength: o\n  } = s;\n  if (!e.triangles) return;\n  const a = r * o,\n        c = i * o,\n        u = e.positions.subarray(a, c),\n        l = n[0],\n        h = n.slice(1).map(d => (d - l) / o),\n        f = ay(u, h, o, t);\n\n  for (let d = 0, m = f.length; d < m; ++d) e.triangles.push(r + f[d]);\n}\n\nfunction Is(e, t) {\n  const n = {};\n\n  for (const s in e) n[s] = {\n    value: e[s],\n    size: t\n  };\n\n  return n;\n}\n\nfunction xy(e, t, n, s) {\n  const r = {\n    shape: \"binary-feature-collection\",\n    points: { ...e,\n      positions: {\n        value: e.positions,\n        size: s\n      },\n      globalFeatureIds: {\n        value: e.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: e.featureIds,\n        size: 1\n      },\n      numericProps: Is(e.numericProps, 1)\n    },\n    lines: { ...t,\n      positions: {\n        value: t.positions,\n        size: s\n      },\n      pathIndices: {\n        value: t.pathIndices,\n        size: 1\n      },\n      globalFeatureIds: {\n        value: t.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: t.featureIds,\n        size: 1\n      },\n      numericProps: Is(t.numericProps, 1)\n    },\n    polygons: { ...n,\n      positions: {\n        value: n.positions,\n        size: s\n      },\n      polygonIndices: {\n        value: n.polygonIndices,\n        size: 1\n      },\n      primitivePolygonIndices: {\n        value: n.primitivePolygonIndices,\n        size: 1\n      },\n      globalFeatureIds: {\n        value: n.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: n.featureIds,\n        size: 1\n      },\n      numericProps: Is(n.numericProps, 1)\n    }\n  };\n  return r.polygons && n.triangles && (r.polygons.triangles = {\n    value: new Uint32Array(n.triangles),\n    size: 1\n  }), r;\n}\n\nfunction Hr(e, t, n, s) {\n  for (const r in e.numericProps) if (r in t) {\n    const i = t[r];\n    e.numericProps[r].fill(i, n, n + s);\n  }\n}\n\nfunction xs(e, t) {\n  const n = {};\n\n  for (const s in e) t.includes(s) || (n[s] = e[s]);\n\n  return n;\n}\n\nfunction vy(e, t) {\n  return t === Array || !Number.isFinite(e) ? Array : t === Float64Array || Math.fround(e) !== e ? Float64Array : Float32Array;\n}\n\nfunction Oy(e) {\n  let t = 0,\n      n = 0,\n      s = 0,\n      r = 0,\n      i = 0,\n      o = 0,\n      a = 0,\n      c = 0,\n      u = 0;\n  const l = /* @__PURE__ */new Set();\n\n  for (const h of e) {\n    const f = h.geometry;\n\n    switch (f.type) {\n      case \"Point\":\n        n++, t++, l.add(f.coordinates.length);\n        break;\n\n      case \"MultiPoint\":\n        n++, t += f.coordinates.length;\n\n        for (const m of f.coordinates) l.add(m.length);\n\n        break;\n\n      case \"LineString\":\n        i++, s += f.coordinates.length, r++;\n\n        for (const m of f.coordinates) l.add(m.length);\n\n        break;\n\n      case \"MultiLineString\":\n        i++;\n\n        for (const m of f.coordinates) {\n          s += m.length, r++;\n\n          for (const g of m) l.add(g.length);\n        }\n\n        break;\n\n      case \"Polygon\":\n        u++, a++, c += f.coordinates.length;\n        const d = f.coordinates.flat();\n        o += d.length;\n\n        for (const m of d) l.add(m.length);\n\n        break;\n\n      case \"MultiPolygon\":\n        u++;\n\n        for (const m of f.coordinates) {\n          a++, c += m.length;\n          const g = m.flat();\n          o += g.length;\n\n          for (const y of g) l.add(y.length);\n        }\n\n        break;\n\n      default:\n        throw new Error(`Unsupported geometry type: ${f.type}`);\n    }\n  }\n\n  return {\n    coordLength: l.size > 0 ? Math.max(...l) : 2,\n    pointPositionsCount: t,\n    pointFeaturesCount: n,\n    linePositionsCount: s,\n    linePathsCount: r,\n    lineFeaturesCount: i,\n    polygonPositionsCount: o,\n    polygonObjectsCount: a,\n    polygonRingsCount: c,\n    polygonFeaturesCount: u\n  };\n}\n\nfunction Fy(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n    coordLength: 2,\n    fixRingWinding: !0\n  };\n  return e.map(n => Dy(n, t));\n}\n\nfunction Bo(e, t, n, s) {\n  n.push(t.length), t.push(...e);\n\n  for (let r = e.length; r < s.coordLength; r++) t.push(0);\n}\n\nfunction or(e, t, n, s) {\n  n.push(t.length);\n\n  for (const r of e) {\n    t.push(...r);\n\n    for (let i = r.length; i < s.coordLength; i++) t.push(0);\n  }\n}\n\nfunction Co(e, t, n, s, r) {\n  let i = 0;\n  const o = [],\n        a = [];\n\n  for (const c of e) {\n    const u = c.map(f => f.slice(0, 2));\n\n    let l = _c(u.flat());\n\n    const h = l < 0;\n    r.fixRingWinding && (i === 0 && !h || i > 0 && h) && (c.reverse(), l = -l), o.push(l), or(c, t, a, r), i++;\n  }\n\n  i > 0 && (s.push(o), n.push(a));\n}\n\nfunction Dy(e, t) {\n  const {\n    geometry: n\n  } = e;\n  if (n.type === \"GeometryCollection\") throw new Error(\"GeometryCollection type not supported\");\n  const s = [],\n        r = [];\n  let i, o;\n\n  switch (n.type) {\n    case \"Point\":\n      o = \"Point\", Bo(n.coordinates, s, r, t);\n      break;\n\n    case \"MultiPoint\":\n      o = \"Point\", n.coordinates.map(a => Bo(a, s, r, t));\n      break;\n\n    case \"LineString\":\n      o = \"LineString\", or(n.coordinates, s, r, t);\n      break;\n\n    case \"MultiLineString\":\n      o = \"LineString\", n.coordinates.map(a => or(a, s, r, t));\n      break;\n\n    case \"Polygon\":\n      o = \"Polygon\", i = [], Co(n.coordinates, s, r, i, t);\n      break;\n\n    case \"MultiPolygon\":\n      o = \"Polygon\", i = [], n.coordinates.map(a => Co(a, s, r, i, t));\n      break;\n\n    default:\n      throw new Error(`Unknown type: ${o}`);\n  }\n\n  return { ...e,\n    geometry: {\n      type: o,\n      indices: r,\n      data: s,\n      areas: i\n    }\n  };\n}\n\nfunction Sc(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n    fixRingWinding: !0,\n    triangulate: !0\n  };\n  const n = Oy(e),\n        s = n.coordLength,\n        {\n    fixRingWinding: r\n  } = t,\n        i = Fy(e, {\n    coordLength: s,\n    fixRingWinding: r\n  });\n  return by(i, n, {\n    numericPropKeys: t.numericPropKeys,\n    PositionDataType: t.PositionDataType || Float32Array,\n    triangulate: t.triangulate\n  });\n}\n\nconst Ly = \"4.1.4\",\n      Py = {\n  name: \"GeoJSON\",\n  id: \"geojson\",\n  module: \"geojson\",\n  version: Ly,\n  worker: !0,\n  extensions: [\"geojson\"],\n  mimeTypes: [\"application/geo+json\"],\n  category: \"geometry\",\n  text: !0,\n  options: {\n    geojson: {\n      shape: \"object-row-table\"\n    },\n    json: {\n      shape: \"object-row-table\",\n      jsonpaths: [\"$\", \"$.features\"]\n    },\n    gis: {\n      format: \"geojson\"\n    }\n  }\n},\n      ke = { ...Py,\n  parse: Gy,\n  parseTextSync: Ic,\n  parseInBatches: Ny\n};\n\nasync function Gy(e, t) {\n  return Ic(new TextDecoder().decode(e), t);\n}\n\nfunction Ic(e, t) {\n  var n;\n  t = { ...ke.options,\n    ...t\n  }, t.geojson = { ...ke.options.geojson,\n    ...t.geojson\n  }, t.gis = t.gis || {};\n  let s;\n\n  try {\n    s = JSON.parse(e);\n  } catch {\n    s = {};\n  }\n\n  const r = {\n    shape: \"geojson-table\",\n    type: \"FeatureCollection\",\n    features: ((n = s) === null || n === void 0 ? void 0 : n.features) || []\n  };\n\n  switch (t.gis.format) {\n    case \"binary\":\n      return Sc(r.features);\n\n    default:\n      return r;\n  }\n}\n\nfunction Ny(e, t) {\n  t = { ...ke.options,\n    ...t\n  }, t.json = { ...ke.options.geojson,\n    ...t.geojson\n  };\n  const n = oy(e, t);\n\n  switch (t.gis.format) {\n    case \"binary\":\n      return Uy(n);\n\n    default:\n      return n;\n  }\n}\n\nasync function* Uy(e) {\n  for await (const t of e) t.data = Sc(t.data), yield t;\n}\n\nfunction $t(e, t) {\n  if (!e) throw new Error(t || \"loader assertion failed.\");\n}\n\nconst Hy = \"Queued Requests\",\n      Jy = \"Active Requests\",\n      Vy = \"Cancelled Requests\",\n      jy = \"Queued Requests Ever\",\n      ky = \"Active Requests Ever\",\n      Ky = {\n  id: \"request-scheduler\",\n\n  /** Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing. */\n  throttleRequests: !0,\n\n  /** The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit. */\n  maxRequests: 6,\n\n  /**\n   * Specifies a debounce time, in milliseconds. All requests are queued, until no new requests have\n   * been added to the queue for this amount of time.\n   */\n  debounceTime: 0\n};\n\nclass zy {\n  constructor(t = {}) {\n    p(this, \"props\");\n    p(this, \"stats\");\n    p(this, \"activeRequestCount\", 0);\n    /** Tracks the number of active requests and prioritizes/cancels queued requests. */\n\n    p(this, \"requestQueue\", []);\n    p(this, \"requestMap\", /* @__PURE__ */new Map());\n    p(this, \"updateTimer\", null);\n    this.props = { ...Ky,\n      ...t\n    }, this.stats = new $o({\n      id: this.props.id\n    }), this.stats.get(Hy), this.stats.get(Jy), this.stats.get(Vy), this.stats.get(jy), this.stats.get(ky);\n  }\n  /**\n   * Called by an application that wants to issue a request, without having it deeply queued by the browser\n   *\n   * When the returned promise resolved, it is OK for the application to issue a request.\n   * The promise resolves to an object that contains a `done` method.\n   * When the application's request has completed (or failed), the application must call the `done` function\n   *\n   * @param handle\n   * @param getPriority will be called when request \"slots\" open up,\n   *    allowing the caller to update priority or cancel the request\n   *    Highest priority executes first, priority < 0 cancels the request\n   * @returns a promise\n   *   - resolves to a object (with a `done` field) when the request can be issued without queueing,\n   *   - resolves to `null` if the request has been cancelled (by the callback return < 0).\n   *     In this case the application should not issue the request\n   */\n\n\n  scheduleRequest(t, n = () => 0) {\n    if (!this.props.throttleRequests) return Promise.resolve({\n      done: () => {}\n    });\n    if (this.requestMap.has(t)) return this.requestMap.get(t);\n    const s = {\n      handle: t,\n      priority: 0,\n      getPriority: n\n    },\n          r = new Promise(i => (s.resolve = i, s));\n    return this.requestQueue.push(s), this.requestMap.set(t, r), this._issueNewRequests(), r;\n  } // PRIVATE\n\n\n  _issueRequest(t) {\n    const {\n      handle: n,\n      resolve: s\n    } = t;\n    let r = !1;\n\n    const i = () => {\n      r || (r = !0, this.requestMap.delete(n), this.activeRequestCount--, this._issueNewRequests());\n    };\n\n    return this.activeRequestCount++, s ? s({\n      done: i\n    }) : Promise.resolve({\n      done: i\n    });\n  }\n  /** We check requests asynchronously, to prevent multiple updates */\n\n\n  _issueNewRequests() {\n    this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = setTimeout(() => this._issueNewRequestsAsync(), this.props.debounceTime);\n  }\n  /** Refresh all requests  */\n\n\n  _issueNewRequestsAsync() {\n    this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = null;\n    const t = Math.max(this.props.maxRequests - this.activeRequestCount, 0);\n\n    if (t !== 0) {\n      this._updateAllRequests();\n\n      for (let n = 0; n < t; ++n) {\n        const s = this.requestQueue.shift();\n        s && this._issueRequest(s);\n      }\n    }\n  }\n  /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */\n\n\n  _updateAllRequests() {\n    const t = this.requestQueue;\n\n    for (let n = 0; n < t.length; ++n) {\n      const s = t[n];\n      this._updateRequest(s) || (t.splice(n, 1), this.requestMap.delete(s.handle), n--);\n    }\n\n    t.sort((n, s) => n.priority - s.priority);\n  }\n  /** Update a single request by calling the callback */\n\n\n  _updateRequest(t) {\n    return t.priority = t.getPriority(t.handle), t.priority < 0 ? (t.resolve(null), !1) : !0;\n  }\n\n}\n\nfunction Wy(e) {\n  const t = e ? e.lastIndexOf(\"/\") : -1;\n  return t >= 0 ? e.substr(0, t) : \"\";\n}\n\nclass Xy {\n  constructor(t, n, s) {\n    p(this, \"item\");\n    p(this, \"previous\");\n    p(this, \"next\");\n    this.item = t, this.previous = n, this.next = s;\n  }\n\n}\n\nclass Qy {\n  constructor() {\n    p(this, \"head\", null);\n    p(this, \"tail\", null);\n    p(this, \"_length\", 0);\n  }\n\n  get length() {\n    return this._length;\n  }\n  /**\n   * Adds the item to the end of the list\n   * @param {*} [item]\n   * @return {DoublyLinkedListNode}\n   */\n\n\n  add(t) {\n    const n = new Xy(t, this.tail, null);\n    return this.tail ? (this.tail.next = n, this.tail = n) : (this.head = n, this.tail = n), ++this._length, n;\n  }\n  /**\n   * Removes the given node from the list\n   * @param {DoublyLinkedListNode} node\n   */\n\n\n  remove(t) {\n    t && (t.previous && t.next ? (t.previous.next = t.next, t.next.previous = t.previous) : t.previous ? (t.previous.next = null, this.tail = t.previous) : t.next ? (t.next.previous = null, this.head = t.next) : (this.head = null, this.tail = null), t.next = null, t.previous = null, --this._length);\n  }\n  /**\n   * Moves nextNode after node\n   * @param {DoublyLinkedListNode} node\n   * @param {DoublyLinkedListNode} nextNode\n   */\n\n\n  splice(t, n) {\n    t !== n && (this.remove(n), this._insert(t, n));\n  }\n\n  _insert(t, n) {\n    const s = t.next;\n    t.next = n, this.tail === t ? this.tail = n : s.previous = n, n.next = s, n.previous = t, ++this._length;\n  }\n\n}\n\nclass qy {\n  constructor() {\n    p(this, \"_list\");\n    p(this, \"_sentinel\");\n    p(this, \"_trimTiles\");\n    this._list = new Qy(), this._sentinel = this._list.add(\"sentinel\"), this._trimTiles = !1;\n  }\n\n  reset() {\n    this._list.splice(this._list.tail, this._sentinel);\n  }\n\n  touch(t) {\n    const n = t._cacheNode;\n    n && this._list.splice(this._sentinel, n);\n  }\n\n  add(t, n, s) {\n    n._cacheNode || (n._cacheNode = this._list.add(n), s && s(t, n));\n  }\n\n  unloadTile(t, n, s) {\n    const r = n._cacheNode;\n    r && (this._list.remove(r), n._cacheNode = null, s && s(t, n));\n  }\n\n  unloadTiles(t, n) {\n    const s = this._trimTiles;\n    this._trimTiles = !1;\n    const r = this._list,\n          i = t.maximumMemoryUsage * 1024 * 1024,\n          o = this._sentinel;\n    let a = r.head;\n\n    for (; a !== o && (t.gpuMemoryUsageInBytes > i || s);) {\n      const c = a.item;\n      a = a.next, this.unloadTile(t, c, n);\n    }\n  }\n\n  trim() {\n    this._trimTiles = !0;\n  }\n\n}\n\nfunction Yy(e, t) {\n  $t(e), $t(t);\n  const {\n    rtcCenter: n,\n    gltfUpAxis: s\n  } = t,\n        {\n    computedTransform: r,\n    boundingVolume: {\n      center: i\n    }\n  } = e;\n  let o = new V(r);\n\n  switch (n && o.translate(n), s) {\n    case \"Z\":\n      break;\n\n    case \"Y\":\n      const h = new V().rotateX(Math.PI / 2);\n      o = o.multiplyRight(h);\n      break;\n\n    case \"X\":\n      const f = new V().rotateY(-Math.PI / 2);\n      o = o.multiplyRight(f);\n      break;\n  }\n\n  t.isQuantized && o.translate(t.quantizedVolumeOffset).scale(t.quantizedVolumeScale);\n  const a = new A(i);\n  t.cartesianModelMatrix = o, t.cartesianOrigin = a;\n  const c = J.WGS84.cartesianToCartographic(a, new A()),\n        l = J.WGS84.eastNorthUpToFixedFrame(a).invert();\n  t.cartographicModelMatrix = l.multiplyRight(o), t.cartographicOrigin = c, t.coordinateSystem || (t.modelMatrix = t.cartographicModelMatrix);\n}\n\nconst Eo = new A(),\n      vs = new A(),\n      ar = new dt([new nt(), new nt(), new nt(), new nt(), new nt(), new nt()]);\n\nfunction $y(e, t) {\n  const {\n    cameraDirection: n,\n    cameraUp: s,\n    height: r\n  } = e,\n        {\n    metersPerUnit: i\n  } = e.distanceScales,\n        o = wn(e, e.center),\n        a = J.WGS84.eastNorthUpToFixedFrame(o),\n        c = e.unprojectPosition(e.cameraPosition),\n        u = J.WGS84.cartographicToCartesian(c, new A()),\n        l = new A( // @ts-ignore\n  a.transformAsVector(new A(n).scale(i))).normalize(),\n        h = new A( // @ts-ignore\n  a.transformAsVector(new A(s).scale(i))).normalize();\n  tB(e);\n  const f = e.constructor,\n        {\n    longitude: d,\n    latitude: m,\n    width: g,\n    bearing: y,\n    zoom: E\n  } = e,\n        R = new f({\n    longitude: d,\n    latitude: m,\n    height: r,\n    width: g,\n    bearing: y,\n    zoom: E,\n    pitch: 0\n  });\n  return {\n    camera: {\n      position: u,\n      direction: l,\n      up: h\n    },\n    viewport: e,\n    topDownViewport: R,\n    height: r,\n    cullingVolume: ar,\n    frameNumber: t,\n    // TODO: This can be the same between updates, what number is unique for between updates?\n    sseDenominator: 1.15 // Assumes fovy = 60 degrees\n\n  };\n}\n\nfunction Zy(e, t, n) {\n  if (n === 0 || e.length <= n) return [e, []];\n  const s = [],\n        {\n    longitude: r,\n    latitude: i\n  } = t.viewport;\n\n  for (const [u, l] of e.entries()) {\n    const [h, f] = l.header.mbs,\n          d = Math.abs(r - h),\n          m = Math.abs(i - f),\n          g = Math.sqrt(m * m + d * d);\n    s.push([u, g]);\n  }\n\n  const o = s.sort((u, l) => u[1] - l[1]),\n        a = [];\n\n  for (let u = 0; u < n; u++) a.push(e[o[u][0]]);\n\n  const c = [];\n\n  for (let u = n; u < o.length; u++) c.push(e[o[u][0]]);\n\n  return [a, c];\n}\n\nfunction tB(e) {\n  const t = e.getFrustumPlanes(),\n        n = To(t.near, e.cameraPosition),\n        s = wn(e, n),\n        r = wn(e, e.cameraPosition, vs);\n  let i = 0;\n  ar.planes[i++].fromPointNormal(s, Eo.copy(s).subtract(r));\n\n  for (const o in t) {\n    if (o === \"near\") continue;\n    const a = t[o],\n          c = To(a, n, vs),\n          u = wn(e, c, vs);\n    ar.planes[i++].fromPointNormal(u, // Want the normal to point into the frustum since that's what culling expects\n    Eo.copy(s).subtract(u));\n  }\n}\n\nfunction To(e, t, n = new A()) {\n  const s = e.normal.dot(t);\n  return n.copy(e.normal).scale(e.distance - s).add(t), n;\n}\n\nfunction wn(e, t, n = new A()) {\n  const s = e.unprojectPosition(t);\n  return J.WGS84.cartographicToCartesian(s, n);\n}\n\nconst eB = 6378137,\n      nB = 6378137,\n      cr = 6356752314245179e-9,\n      ge = new A();\n\nfunction sB(e, t) {\n  if (e instanceof qe) {\n    const {\n      halfAxes: n\n    } = e,\n          s = iB(n);\n    return Math.log2(cr / (s + t[2]));\n  } else if (e instanceof Qe) {\n    const {\n      radius: n\n    } = e;\n    return Math.log2(cr / (n + t[2]));\n  } else if (e.width && e.height) {\n    const {\n      width: n,\n      height: s\n    } = e,\n          r = Math.log2(eB / n),\n          i = Math.log2(nB / s);\n    return (r + i) / 2;\n  }\n\n  return 1;\n}\n\nfunction xc(e, t, n) {\n  J.WGS84.cartographicToCartesian([e.xmax, e.ymax, e.zmax], ge);\n  const s = Math.sqrt(Math.pow(ge[0] - n[0], 2) + Math.pow(ge[1] - n[1], 2) + Math.pow(ge[2] - n[2], 2));\n  return Math.log2(cr / (s + t[2]));\n}\n\nfunction rB(e, t, n) {\n  const [s, r, i, o] = e;\n  return xc({\n    xmin: s,\n    xmax: i,\n    ymin: r,\n    ymax: o,\n    zmin: 0,\n    zmax: 0\n  }, t, n);\n}\n\nfunction iB(e) {\n  e.getColumn(0, ge);\n  const t = e.getColumn(1),\n        n = e.getColumn(2);\n  return ge.add(t).add(n).len();\n}\n\nconst lt = {\n  UNLOADED: 0,\n  // Has never been requested\n  LOADING: 1,\n  // Is waiting on a pending request\n  PROCESSING: 2,\n  // Request received.  Contents are being processed for rendering.  Depending on the content, it might make its own requests for external data.\n  READY: 3,\n  // Ready to render.\n  EXPIRED: 4,\n  // Is expired and will be unloaded once new content is loaded.\n  FAILED: 5 // Request failed.\n\n};\nvar Ht;\n\n(function (e) {\n  e[e.ADD = 1] = \"ADD\", e[e.REPLACE = 2] = \"REPLACE\";\n})(Ht || (Ht = {}));\n\nvar Pe;\n\n(function (e) {\n  e.EMPTY = \"empty\", e.SCENEGRAPH = \"scenegraph\", e.POINTCLOUD = \"pointcloud\", e.MESH = \"mesh\";\n})(Pe || (Pe = {}));\n\nvar At;\n\n(function (e) {\n  e.I3S = \"I3S\", e.TILES3D = \"TILES3D\";\n})(At || (At = {}));\n\nvar bo;\n\n(function (e) {\n  e.GEOMETRIC_ERROR = \"geometricError\", e.MAX_SCREEN_THRESHOLD = \"maxScreenThreshold\";\n})(bo || (bo = {}));\n\nconst oB = {\n  NOT_COMPUTED: -1,\n  USE_OPTIMIZATION: 1,\n  SKIP_OPTIMIZATION: 0\n};\n\nfunction vc(e) {\n  return e != null;\n}\n\nconst it = new A(),\n      Rn = new A(),\n      aB = new A(),\n      cB = new A(),\n      qt = new A(),\n      _o = new A(),\n      wo = new A(),\n      Ro = new A();\n\nfunction Os(e, t, n) {\n  if ($t(e, \"3D Tile: boundingVolume must be defined\"), e.box) return Oc(e.box, t, n);\n  if (e.region) return hB(e.region);\n  if (e.sphere) return lB(e.sphere, t, n);\n  throw new Error(\"3D Tile: boundingVolume must contain a sphere, region, or box\");\n}\n\nfunction uB(e, t) {\n  if (e.box) return fB(t);\n\n  if (e.region) {\n    const [n, s, r, i, o, a] = e.region;\n    return [[Rt(n), Rt(s), o], [Rt(r), Rt(i), a]];\n  }\n\n  if (e.sphere) return dB(t);\n  throw new Error(\"Unkown boundingVolume type\");\n}\n\nfunction Oc(e, t, n) {\n  const s = new A(e[0], e[1], e[2]);\n  t.transform(s, s);\n  let r = [];\n\n  if (e.length === 10) {\n    const u = e.slice(3, 6),\n          l = new On();\n    l.fromArray(e, 6);\n    const h = new A([1, 0, 0]),\n          f = new A([0, 1, 0]),\n          d = new A([0, 0, 1]);\n    h.transformByQuaternion(l), h.scale(u[0]), f.transformByQuaternion(l), f.scale(u[1]), d.transformByQuaternion(l), d.scale(u[2]), r = [...h.toArray(), ...f.toArray(), ...d.toArray()];\n  } else r = [...e.slice(3, 6), ...e.slice(6, 9), ...e.slice(9, 12)];\n\n  const i = t.transformAsVector(r.slice(0, 3)),\n        o = t.transformAsVector(r.slice(3, 6)),\n        a = t.transformAsVector(r.slice(6, 9)),\n        c = new X([i[0], i[1], i[2], o[0], o[1], o[2], a[0], a[1], a[2]]);\n  return vc(n) ? (n.center = s, n.halfAxes = c, n) : new qe(s, c);\n}\n\nfunction lB(e, t, n) {\n  const s = new A(e[0], e[1], e[2]);\n  t.transform(s, s);\n  const r = t.getScale(Rn),\n        i = Math.max(Math.max(r[0], r[1]), r[2]),\n        o = e[3] * i;\n  return vc(n) ? (n.center = s, n.radius = o, n) : new Qe(s, o);\n}\n\nfunction hB(e) {\n  const [t, n, s, r, i, o] = e,\n        a = J.WGS84.cartographicToCartesian([Rt(t), Rt(r), i], aB),\n        c = J.WGS84.cartographicToCartesian([Rt(s), Rt(n), o], cB),\n        u = new A().addVectors(a, c).multiplyByScalar(0.5);\n  return J.WGS84.cartesianToCartographic(u, qt), J.WGS84.cartographicToCartesian([Rt(s), qt[1], qt[2]], _o), J.WGS84.cartographicToCartesian([qt[0], Rt(r), qt[2]], wo), J.WGS84.cartographicToCartesian([qt[0], qt[1], o], Ro), Oc([...u, ..._o.subtract(u), ...wo.subtract(u), ...Ro.subtract(u)], new V());\n}\n\nfunction fB(e) {\n  const t = Fc(),\n        {\n    halfAxes: n\n  } = e,\n        s = new A(n.getColumn(0)),\n        r = new A(n.getColumn(1)),\n        i = new A(n.getColumn(2));\n\n  for (let o = 0; o < 2; o++) {\n    for (let a = 0; a < 2; a++) {\n      for (let c = 0; c < 2; c++) it.copy(e.center), it.add(s), it.add(r), it.add(i), Dc(t, it), i.negate();\n\n      r.negate();\n    }\n\n    s.negate();\n  }\n\n  return t;\n}\n\nfunction dB(e) {\n  const t = Fc(),\n        {\n    center: n,\n    radius: s\n  } = e,\n        r = J.WGS84.scaleToGeodeticSurface(n, it);\n  let i;\n  r ? i = J.WGS84.geodeticSurfaceNormal(r) : i = new A(0, 0, 1);\n  let o = new A(i[2], -i[1], 0);\n  o.len() > 0 ? o.normalize() : o = new A(0, 1, 0);\n  const a = o.clone().cross(i);\n\n  for (const c of [o, a, i]) {\n    Rn.copy(c).scale(s);\n\n    for (let u = 0; u < 2; u++) it.copy(n), it.add(Rn), Dc(t, it), Rn.negate();\n  }\n\n  return t;\n}\n\nfunction Fc() {\n  return [[1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]];\n}\n\nfunction Dc(e, t) {\n  J.WGS84.cartesianToCartographic(t, it), e[0][0] = Math.min(e[0][0], it[0]), e[0][1] = Math.min(e[0][1], it[1]), e[0][2] = Math.min(e[0][2], it[2]), e[1][0] = Math.max(e[1][0], it[0]), e[1][1] = Math.max(e[1][1], it[1]), e[1][2] = Math.max(e[1][2], it[2]);\n}\n\nnew A();\nnew A();\nnew V();\nnew A();\nnew A();\nnew A();\n\nfunction mB(e, t) {\n  const n = e * t;\n  return 1 - Math.exp(-(n * n));\n}\n\nfunction gB(e, t) {\n  if (e.dynamicScreenSpaceError && e.dynamicScreenSpaceErrorComputedDensity) {\n    const n = e.dynamicScreenSpaceErrorComputedDensity,\n          s = e.dynamicScreenSpaceErrorFactor;\n    return mB(t, n) * s;\n  }\n\n  return 0;\n}\n\nfunction AB(e, t, n) {\n  const s = e.tileset,\n        r = e.parent && e.parent.lodMetricValue || e.lodMetricValue,\n        i = n ? r : e.lodMetricValue;\n  if (i === 0) return 0;\n  const o = Math.max(e._distanceToCamera, 1e-7),\n        {\n    height: a,\n    sseDenominator: c\n  } = t,\n        {\n    viewDistanceScale: u\n  } = s.options;\n  let l = i * a * (u || 1) / (o * c);\n  return l -= gB(s, o), l;\n}\n\nconst Fs = new A(),\n      Mo = new A(),\n      jt = new A(),\n      So = new A(),\n      pB = new A(),\n      Ds = new V(),\n      Io = new V();\n\nfunction yB(e, t) {\n  if (e.lodMetricValue === 0 || isNaN(e.lodMetricValue)) return \"DIG\";\n  const n = 2 * Lc(e, t);\n  return n < 2 ? \"OUT\" : !e.header.children || n <= e.lodMetricValue ? \"DRAW\" : e.header.children ? \"DIG\" : \"OUT\";\n}\n\nfunction Lc(e, t) {\n  const {\n    topDownViewport: n\n  } = t,\n        s = e.header.mbs[1],\n        r = e.header.mbs[0],\n        i = e.header.mbs[2],\n        o = e.header.mbs[3],\n        a = [...e.boundingVolume.center],\n        c = n.unprojectPosition(n.cameraPosition);\n  J.WGS84.cartographicToCartesian(c, Fs), Mo.copy(Fs).subtract(a).normalize(), J.WGS84.eastNorthUpToFixedFrame(a, Ds), Io.copy(Ds).invert(), jt.copy(Fs).transform(Io);\n  const u = Math.sqrt(jt[0] * jt[0] + jt[1] * jt[1]),\n        l = u * u / jt[2];\n  So.copy([jt[0], jt[1], l]);\n  const f = So.transform(Ds).subtract(a).normalize(),\n        m = Mo.cross(f).normalize().scale(o).add(a),\n        g = J.WGS84.cartesianToCartographic(m),\n        y = n.project([r, s, i]),\n        E = n.project(g);\n  return pB.copy(y).subtract(E).magnitude();\n}\n\nfunction BB(e) {\n  return {\n    assetGltfUpAxis: e.asset && e.asset.gltfUpAxis || \"Y\"\n  };\n}\n\nclass xo {\n  constructor(t = 0) {\n    p(this, \"_map\", /* @__PURE__ */new Map());\n    p(this, \"_array\");\n    p(this, \"_length\");\n    this._array = new Array(t), this._length = t;\n  }\n  /**\n   * Gets or sets the length of the array.\n   * If the set length is greater than the length of the internal array, the internal array is resized.\n   *\n   * @memberof ManagedArray.prototype\n   * @type Number\n   */\n\n\n  get length() {\n    return this._length;\n  }\n\n  set length(t) {\n    this._length = t, t > this._array.length && (this._array.length = t);\n  }\n  /**\n   * Gets the internal array.\n   *\n   * @memberof ManagedArray.prototype\n   * @type Array\n   * @readonly\n   */\n\n\n  get values() {\n    return this._array;\n  }\n  /**\n   * Gets the element at an index.\n   *\n   * @param {Number} index The index to get.\n   */\n\n\n  get(t) {\n    return $t(t < this._array.length), this._array[t];\n  }\n  /**\n   * Sets the element at an index. Resizes the array if index is greater than the length of the array.\n   *\n   * @param {Number} index The index to set.\n   * @param {*} element The element to set at index.\n   */\n\n\n  set(t, n) {\n    $t(t >= 0), t >= this.length && (this.length = t + 1), this._map.has(this._array[t]) && this._map.delete(this._array[t]), this._array[t] = n, this._map.set(n, t);\n  }\n\n  delete(t) {\n    const n = this._map.get(t);\n\n    n >= 0 && (this._array.splice(n, 1), this._map.delete(t), this.length--);\n  }\n  /**\n   * Returns the last element in the array without modifying the array.\n   *\n   * @returns {*} The last element in the array.\n   */\n\n\n  peek() {\n    return this._array[this._length - 1];\n  }\n  /**\n   * Push an element into the array.\n   *\n   * @param {*} element The element to push.\n   */\n\n\n  push(t) {\n    if (!this._map.has(t)) {\n      const n = this.length++;\n      this._array[n] = t, this._map.set(t, n);\n    }\n  }\n  /**\n   * Pop an element from the array.\n   *\n   * @returns {*} The last element in the array.\n   */\n\n\n  pop() {\n    const t = this._array[--this.length];\n    return this._map.delete(t), t;\n  }\n  /**\n   * Resize the internal array if length > _array.length.\n   *\n   * @param {Number} length The length.\n   */\n\n\n  reserve(t) {\n    $t(t >= 0), t > this._array.length && (this._array.length = t);\n  }\n  /**\n   * Resize the array.\n   *\n   * @param {Number} length The length.\n   */\n\n\n  resize(t) {\n    $t(t >= 0), this.length = t;\n  }\n  /**\n   * Trim the internal array to the specified length. Defaults to the current length.\n   *\n   * @param {Number} [length] The length.\n   */\n\n\n  trim(t) {\n    t == null && (t = this.length), this._array.length = t;\n  }\n\n  reset() {\n    this._array = [], this._map = /* @__PURE__ */new Map(), this._length = 0;\n  }\n\n  find(t) {\n    return this._map.has(t);\n  }\n\n}\n\nconst CB = {\n  loadSiblings: !1,\n  skipLevelOfDetail: !1,\n  updateTransforms: !0,\n  onTraversalEnd: () => {},\n  viewportTraversersMap: {},\n  basePath: \"\"\n};\n\nclass ts {\n  // TODO nested props\n  constructor(t) {\n    p(this, \"options\"); // fulfill in traverse call\n\n    p(this, \"root\", null); // tiles should be rendered\n\n    p(this, \"selectedTiles\", {}); // tiles should be loaded from server\n\n    p(this, \"requestedTiles\", {}); // tiles does not have render content\n\n    p(this, \"emptyTiles\", {});\n    p(this, \"lastUpdate\", /* @__PURE__ */new Date().getTime());\n    p(this, \"updateDebounceTime\", 1e3);\n    /** temporary storage to hold the traversed tiles during a traversal */\n\n    p(this, \"_traversalStack\", new xo());\n    p(this, \"_emptyTraversalStack\", new xo());\n    /** set in every traverse cycle */\n\n    p(this, \"_frameNumber\", null);\n    this.options = { ...CB,\n      ...t\n    };\n  } // RESULT\n\n\n  traversalFinished(t) {\n    return !0;\n  } // tiles should be visible\n\n\n  traverse(t, n, s) {\n    this.root = t, this.options = { ...this.options,\n      ...s\n    }, this.reset(), this.updateTile(t, n), this._frameNumber = n.frameNumber, this.executeTraversal(t, n);\n  }\n\n  reset() {\n    this.requestedTiles = {}, this.selectedTiles = {}, this.emptyTiles = {}, this._traversalStack.reset(), this._emptyTraversalStack.reset();\n  }\n  /**\n   * Execute traverse\n   * Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n   * If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n   * This is the traditional replacement refinement approach and is called the base traversal.\n   * Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n   * all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n   * and rendering children and parent tiles simultaneously.\n   */\n\n  /* eslint-disable-next-line complexity, max-statements */\n\n\n  executeTraversal(t, n) {\n    const s = this._traversalStack;\n\n    for (t._selectionDepth = 1, s.push(t); s.length > 0;) {\n      const i = s.pop();\n      let o = !1;\n      this.canTraverse(i, n) && (this.updateChildTiles(i, n), o = this.updateAndPushChildren(i, n, s, i.hasRenderContent ? i._selectionDepth + 1 : i._selectionDepth));\n      const a = i.parent,\n            c = !!(!a || a._shouldRefine),\n            u = !o;\n      i.hasRenderContent ? i.refine === Ht.ADD ? (this.loadTile(i, n), this.selectTile(i, n)) : i.refine === Ht.REPLACE && (this.loadTile(i, n), u && this.selectTile(i, n)) : (this.emptyTiles[i.id] = i, this.loadTile(i, n), u && this.selectTile(i, n)), this.touchTile(i, n), i._shouldRefine = o && c;\n    }\n\n    const r = /* @__PURE__ */new Date().getTime();\n    (this.traversalFinished(n) || r - this.lastUpdate > this.updateDebounceTime) && (this.lastUpdate = r, this.options.onTraversalEnd(n));\n  }\n\n  updateChildTiles(t, n) {\n    const s = t.children;\n\n    for (const r of s) this.updateTile(r, n);\n  }\n  /* eslint-disable complexity, max-statements */\n\n\n  updateAndPushChildren(t, n, s, r) {\n    const {\n      loadSiblings: i,\n      skipLevelOfDetail: o\n    } = this.options,\n          a = t.children;\n    a.sort(this.compareDistanceToCamera.bind(this));\n    const c = t.refine === Ht.REPLACE && t.hasRenderContent && !o;\n    let u = !1,\n        l = !0;\n\n    for (const h of a) if (h._selectionDepth = r, h.isVisibleAndInRequestVolume ? (s.find(h) && s.delete(h), s.push(h), u = !0) : (c || i) && (this.loadTile(h, n), this.touchTile(h, n)), c) {\n      let f;\n      if (h._inRequestVolume ? h.hasRenderContent ? f = h.contentAvailable : f = this.executeEmptyTraversal(h, n) : f = !1, l = l && f, !l) return !1;\n    }\n\n    return u || (l = !1), l;\n  }\n  /* eslint-enable complexity, max-statements */\n\n\n  updateTile(t, n) {\n    this.updateTileVisibility(t, n);\n  } // tile to render in the browser\n\n\n  selectTile(t, n) {\n    this.shouldSelectTile(t) && (t._selectedFrame = n.frameNumber, this.selectedTiles[t.id] = t);\n  } // tile to load from server\n\n\n  loadTile(t, n) {\n    this.shouldLoadTile(t) && (t._requestedFrame = n.frameNumber, t._priority = t._getPriority(), this.requestedTiles[t.id] = t);\n  } // cache tile\n\n\n  touchTile(t, n) {\n    t.tileset._cache.touch(t), t._touchedFrame = n.frameNumber;\n  } // tile should be visible\n  // tile should have children\n  // tile LoD (level of detail) is not sufficient under current viewport\n\n\n  canTraverse(t, n) {\n    return t.hasChildren ? t.hasTilesetContent ? !t.contentExpired : this.shouldRefine(t, n) : !1;\n  }\n\n  shouldLoadTile(t) {\n    return t.hasUnloadedContent || t.contentExpired;\n  }\n\n  shouldSelectTile(t) {\n    return t.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n  /** Decide if tile LoD (level of detail) is not sufficient under current viewport */\n\n\n  shouldRefine(t, n, s = !1) {\n    let r = t._screenSpaceError;\n    return s && (r = t.getScreenSpaceError(n, !0)), r > t.tileset.memoryAdjustedScreenSpaceError;\n  }\n\n  updateTileVisibility(t, n) {\n    const s = [];\n    if (this.options.viewportTraversersMap) for (const r in this.options.viewportTraversersMap) this.options.viewportTraversersMap[r] === n.viewport.id && s.push(r);else s.push(n.viewport.id);\n    t.updateVisibility(n, s);\n  } // UTILITIES\n\n\n  compareDistanceToCamera(t, n) {\n    return t._distanceToCamera - n._distanceToCamera;\n  }\n\n  anyChildrenVisible(t, n) {\n    let s = !1;\n\n    for (const r of t.children) r.updateVisibility(n), s = s || r.isVisibleAndInRequestVolume;\n\n    return s;\n  } // Depth-first traversal that checks if all nearest descendants with content are loaded.\n  // Ignores visibility.\n\n\n  executeEmptyTraversal(t, n) {\n    let s = !0;\n    const r = this._emptyTraversalStack;\n\n    for (r.push(t); r.length > 0;) {\n      const i = r.pop(),\n            o = !i.hasRenderContent && this.canTraverse(i, n),\n            a = !i.hasRenderContent && i.children.length === 0;\n\n      if (!o && !i.contentAvailable && !a && (s = !1), this.updateTile(i, n), i.isVisibleAndInRequestVolume || (this.loadTile(i, n), this.touchTile(i, n)), o) {\n        const c = i.children;\n\n        for (const u of c) r.push(u);\n      }\n    }\n\n    return s;\n  }\n\n}\n\nconst vo = new A();\n\nfunction EB(e) {\n  return e != null;\n}\n\nclass ur {\n  // TODO i3s specific, needs to remove\n\n  /**\n   * @constructs\n   * Create a Tile3D instance\n   * @param tileset - Tileset3D instance\n   * @param header - tile header - JSON loaded from a dataset\n   * @param parentHeader - parent Tile3D instance\n   * @param extendedId - optional ID to separate copies of a tile for different viewports.\n   *    const extendedId = `${tile.id}-${frameState.viewport.id}`;\n   */\n  // eslint-disable-next-line max-statements\n  constructor(t, n, s, r = \"\") {\n    p(this, \"tileset\");\n    p(this, \"header\");\n    p(this, \"id\");\n    p(this, \"url\");\n    p(this, \"parent\");\n    /* Specifies the type of refine that is used when traversing this tile for rendering. */\n\n    p(this, \"refine\");\n    p(this, \"type\");\n    p(this, \"contentUrl\");\n    /** Different refinement algorithms used by I3S and 3D tiles */\n\n    p(this, \"lodMetricType\", \"geometricError\");\n    /** The error, in meters, introduced if this tile is rendered and its children are not. */\n\n    p(this, \"lodMetricValue\", 0);\n    /** @todo math.gl is not exporting BoundingVolume base type? */\n\n    p(this, \"boundingVolume\", null);\n    /**\n     * The tile's content.  This represents the actual tile's payload,\n     * not the content's metadata in the tileset JSON file.\n     */\n\n    p(this, \"content\", null);\n    p(this, \"contentState\", lt.UNLOADED);\n    p(this, \"gpuMemoryUsageInBytes\", 0);\n    /** The tile's children - an array of Tile3D objects. */\n\n    p(this, \"children\", []);\n    p(this, \"depth\", 0);\n    p(this, \"viewportIds\", []);\n    p(this, \"transform\", new V());\n    p(this, \"extensions\", null);\n    /** TODO Cesium 3d tiles specific */\n\n    p(this, \"implicitTiling\", null);\n    /** Container to store application specific data */\n\n    p(this, \"userData\", {});\n    p(this, \"computedTransform\");\n    p(this, \"hasEmptyContent\", !1);\n    p(this, \"hasTilesetContent\", !1);\n    p(this, \"traverser\", new ts({}));\n    /** Used by TilesetCache */\n\n    p(this, \"_cacheNode\", null);\n    p(this, \"_frameNumber\", null); // TODO Cesium 3d tiles specific\n\n    p(this, \"_expireDate\", null);\n    p(this, \"_expiredContent\", null);\n    p(this, \"_boundingBox\");\n    /** updated every frame for tree traversal and rendering optimizations: */\n\n    p(this, \"_distanceToCamera\", 0);\n    p(this, \"_screenSpaceError\", 0);\n    p(this, \"_visibilityPlaneMask\");\n    p(this, \"_visible\");\n    p(this, \"_contentBoundingVolume\");\n    p(this, \"_viewerRequestVolume\");\n    p(this, \"_initialTransform\", new V()); // Used by traverser, cannot be marked private\n\n    p(this, \"_priority\", 0);\n    p(this, \"_selectedFrame\", 0);\n    p(this, \"_requestedFrame\", 0);\n    p(this, \"_selectionDepth\", 0);\n    p(this, \"_touchedFrame\", 0);\n    p(this, \"_centerZDepth\", 0);\n    p(this, \"_shouldRefine\", !1);\n    p(this, \"_stackLength\", 0);\n    p(this, \"_visitedFrame\", 0);\n    p(this, \"_inRequestVolume\", !1);\n    p(this, \"_lodJudge\", null);\n    this.header = n, this.tileset = t, this.id = r || n.id, this.url = n.url, this.parent = s, this.refine = this._getRefine(n.refine), this.type = n.type, this.contentUrl = n.contentUrl, this._initializeLodMetric(n), this._initializeTransforms(n), this._initializeBoundingVolumes(n), this._initializeContent(n), this._initializeRenderingState(n), Object.seal(this);\n  }\n\n  destroy() {\n    this.header = null;\n  }\n\n  isDestroyed() {\n    return this.header === null;\n  }\n\n  get selected() {\n    return this._selectedFrame === this.tileset._frameNumber;\n  }\n\n  get isVisible() {\n    return this._visible;\n  }\n\n  get isVisibleAndInRequestVolume() {\n    return this._visible && this._inRequestVolume;\n  }\n  /** Returns true if tile is not an empty tile and not an external tileset */\n\n\n  get hasRenderContent() {\n    return !this.hasEmptyContent && !this.hasTilesetContent;\n  }\n  /** Returns true if tile has children */\n\n\n  get hasChildren() {\n    return this.children.length > 0 || this.header.children && this.header.children.length > 0;\n  }\n  /**\n   * Determines if the tile's content is ready. This is automatically `true` for\n   * tiles with empty content.\n   */\n\n\n  get contentReady() {\n    return this.contentState === lt.READY || this.hasEmptyContent;\n  }\n  /**\n   * Determines if the tile has available content to render.  `true` if the tile's\n   * content is ready or if it has expired content this renders while new content loads; otherwise,\n   */\n\n\n  get contentAvailable() {\n    return !!(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);\n  }\n  /** Returns true if tile has renderable content but it's unloaded */\n\n\n  get hasUnloadedContent() {\n    return this.hasRenderContent && this.contentUnloaded;\n  }\n  /**\n   * Determines if the tile's content has not be requested. `true` if tile's\n   * content has not be requested; otherwise, `false`.\n   */\n\n\n  get contentUnloaded() {\n    return this.contentState === lt.UNLOADED;\n  }\n  /**\n   * Determines if the tile's content is expired. `true` if tile's\n   * content is expired; otherwise, `false`.\n   */\n\n\n  get contentExpired() {\n    return this.contentState === lt.EXPIRED;\n  } // Determines if the tile's content failed to load.  `true` if the tile's\n  // content failed to load; otherwise, `false`.\n\n\n  get contentFailed() {\n    return this.contentState === lt.FAILED;\n  }\n  /**\n   * Distance from the tile's bounding volume center to the camera\n   */\n\n\n  get distanceToCamera() {\n    return this._distanceToCamera;\n  }\n  /**\n   * Screen space error for LOD selection\n   */\n\n\n  get screenSpaceError() {\n    return this._screenSpaceError;\n  }\n  /**\n   * Get bounding box in cartographic coordinates\n   * @returns [min, max] each in [longitude, latitude, altitude]\n   */\n\n\n  get boundingBox() {\n    return this._boundingBox || (this._boundingBox = uB(this.header.boundingVolume, this.boundingVolume)), this._boundingBox;\n  }\n  /** Get the tile's screen space error. */\n\n\n  getScreenSpaceError(t, n) {\n    switch (this.tileset.type) {\n      case At.I3S:\n        return Lc(this, t);\n\n      case At.TILES3D:\n        return AB(this, t, n);\n\n      default:\n        throw new Error(\"Unsupported tileset type\");\n    }\n  }\n  /**\n   * Make tile unselected than means it won't be shown\n   * but it can be still loaded in memory\n   */\n\n\n  unselect() {\n    this._selectedFrame = 0;\n  }\n  /**\n   * Memory usage of tile on GPU\n   */\n\n\n  _getGpuMemoryUsageInBytes() {\n    return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;\n  }\n  /*\n   * If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.\n   * Tiles are prioritized by screen space error.\n   */\n  // eslint-disable-next-line complexity\n\n\n  _getPriority() {\n    const t = this.tileset._traverser,\n          {\n      skipLevelOfDetail: n\n    } = t.options,\n          s = this.refine === Ht.ADD || n;\n    if (s && !this.isVisible && this._visible !== void 0 || this.tileset._frameNumber - this._touchedFrame >= 1 || this.contentState === lt.UNLOADED) return -1;\n    const r = this.parent,\n          o = r && (!s || this._screenSpaceError === 0 || r.hasTilesetContent) ? r._screenSpaceError : this._screenSpaceError,\n          a = t.root ? t.root._screenSpaceError : 0;\n    return Math.max(a - o, 0);\n  }\n  /**\n   *  Requests the tile's content.\n   * The request may not be made if the Request Scheduler can't prioritize it.\n   */\n  // eslint-disable-next-line max-statements, complexity\n\n\n  async loadContent() {\n    if (this.hasEmptyContent) return !1;\n    if (this.content) return !0;\n    this.contentExpired && (this._expireDate = null), this.contentState = lt.LOADING;\n    const n = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));\n    if (!n) return this.contentState = lt.UNLOADED, !1;\n\n    try {\n      const s = this.tileset.getTileUrl(this.contentUrl),\n            r = this.tileset.loader,\n            i = { ...this.tileset.loadOptions,\n        [r.id]: { // @ts-expect-error\n          ...this.tileset.loadOptions[r.id],\n          isTileset: this.type === \"json\",\n          ...this._getLoaderSpecificOptions(r.id)\n        }\n      };\n      return this.content = await Ae(s, r, i), this.tileset.options.contentLoader && (await this.tileset.options.contentLoader(this)), this._isTileset() && this.tileset._initializeTileHeaders(this.content, this), this.contentState = lt.READY, this._onContentLoaded(), !0;\n    } catch (s) {\n      throw this.contentState = lt.FAILED, s;\n    } finally {\n      n.done();\n    }\n  } // Unloads the tile's content.\n\n\n  unloadContent() {\n    return this.content && this.content.destroy && this.content.destroy(), this.content = null, this.header.content && this.header.content.destroy && this.header.content.destroy(), this.header.content = null, this.contentState = lt.UNLOADED, !0;\n  }\n  /**\n   * Update the tile's visibility\n   * @param {Object} frameState - frame state for tile culling\n   * @param {string[]} viewportIds - a list of viewport ids that show this tile\n   * @return {void}\n   */\n\n\n  updateVisibility(t, n) {\n    if (this._frameNumber === t.frameNumber) return;\n    const s = this.parent,\n          r = s ? s._visibilityPlaneMask : dt.MASK_INDETERMINATE;\n\n    if (this.tileset._traverser.options.updateTransforms) {\n      const i = s ? s.computedTransform : this.tileset.modelMatrix;\n\n      this._updateTransform(i);\n    }\n\n    this._distanceToCamera = this.distanceToTile(t), this._screenSpaceError = this.getScreenSpaceError(t, !1), this._visibilityPlaneMask = this.visibility(t, r), this._visible = this._visibilityPlaneMask !== dt.MASK_OUTSIDE, this._inRequestVolume = this.insideViewerRequestVolume(t), this._frameNumber = t.frameNumber, this.viewportIds = n;\n  } // Determines whether the tile's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.\n  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.\n\n\n  visibility(t, n) {\n    const {\n      cullingVolume: s\n    } = t,\n          {\n      boundingVolume: r\n    } = this;\n    return s.computeVisibilityWithPlaneMask(r, n);\n  } // Assuming the tile's bounding volume intersects the culling volume, determines\n  // whether the tile's content's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.\n\n\n  contentVisibility() {\n    return !0;\n  }\n  /**\n   * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.\n   * @param frameState The frame state.\n   * @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.\n   */\n\n\n  distanceToTile(t) {\n    const n = this.boundingVolume;\n    return Math.sqrt(Math.max(n.distanceSquaredTo(t.camera.position), 0));\n  }\n  /**\n   * Computes the tile's camera-space z-depth.\n   * @param frameState The frame state.\n   * @returns The distance, in meters.\n   */\n\n\n  cameraSpaceZDepth({\n    camera: t\n  }) {\n    const n = this.boundingVolume;\n    return vo.subVectors(n.center, t.position), t.direction.dot(vo);\n  }\n  /**\n   * Checks if the camera is inside the viewer request volume.\n   * @param {FrameState} frameState The frame state.\n   * @returns {Boolean} Whether the camera is inside the volume.\n   */\n\n\n  insideViewerRequestVolume(t) {\n    const n = this._viewerRequestVolume;\n    return !n || n.distanceSquaredTo(t.camera.position) <= 0;\n  } // TODO Cesium specific\n  // Update whether the tile has expired.\n\n\n  updateExpiration() {\n    if (EB(this._expireDate) && this.contentReady && !this.hasEmptyContent) {\n      const t = Date.now();\n      Date.lessThan(this._expireDate, t) && (this.contentState = lt.EXPIRED, this._expiredContent = this.content);\n    }\n  }\n\n  get extras() {\n    return this.header.extras;\n  } // INTERNAL METHODS\n\n\n  _initializeLodMetric(t) {\n    \"lodMetricType\" in t ? this.lodMetricType = t.lodMetricType : (this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType, console.warn(\"3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType\")), \"lodMetricValue\" in t ? this.lodMetricValue = t.lodMetricValue : (this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue, console.warn(\"3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue\"));\n  }\n\n  _initializeTransforms(t) {\n    this.transform = t.transform ? new V(t.transform) : new V();\n    const n = this.parent,\n          s = this.tileset,\n          r = n && n.computedTransform ? n.computedTransform.clone() : s.modelMatrix.clone();\n    this.computedTransform = new V(r).multiplyRight(this.transform);\n    const i = n && n._initialTransform ? n._initialTransform.clone() : new V();\n    this._initialTransform = new V(i).multiplyRight(this.transform);\n  }\n\n  _initializeBoundingVolumes(t) {\n    this._contentBoundingVolume = null, this._viewerRequestVolume = null, this._updateBoundingVolume(t);\n  }\n\n  _initializeContent(t) {\n    this.content = {\n      _tileset: this.tileset,\n      _tile: this\n    }, this.hasEmptyContent = !0, this.contentState = lt.UNLOADED, this.hasTilesetContent = !1, t.contentUrl && (this.content = null, this.hasEmptyContent = !1);\n  } // TODO - remove anything not related to basic visibility detection\n\n\n  _initializeRenderingState(t) {\n    this.depth = t.level || (this.parent ? this.parent.depth + 1 : 0), this._shouldRefine = !1, this._distanceToCamera = 0, this._centerZDepth = 0, this._screenSpaceError = 0, this._visibilityPlaneMask = dt.MASK_INDETERMINATE, this._visible = void 0, this._inRequestVolume = !1, this._stackLength = 0, this._selectionDepth = 0, this._frameNumber = 0, this._touchedFrame = 0, this._visitedFrame = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._priority = 0;\n  }\n\n  _getRefine(t) {\n    return t || this.parent && this.parent.refine || Ht.REPLACE;\n  }\n\n  _isTileset() {\n    return this.contentUrl.indexOf(\".json\") !== -1;\n  }\n\n  _onContentLoaded() {\n    switch (this.content && this.content.type) {\n      case \"vctr\":\n      case \"geom\":\n        this.tileset._traverser.disableSkipLevelOfDetail = !0;\n        break;\n    }\n\n    this._isTileset() ? this.hasTilesetContent = !0 : this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();\n  }\n\n  _updateBoundingVolume(t) {\n    this.boundingVolume = Os(t.boundingVolume, this.computedTransform, this.boundingVolume);\n    const n = t.content;\n    n && (n.boundingVolume && (this._contentBoundingVolume = Os(n.boundingVolume, this.computedTransform, this._contentBoundingVolume)), t.viewerRequestVolume && (this._viewerRequestVolume = Os(t.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume)));\n  } // Update the tile's transform. The transform is applied to the tile's bounding volumes.\n\n\n  _updateTransform(t = new V()) {\n    const n = t.clone().multiplyRight(this.transform);\n    n.equals(this.computedTransform) || (this.computedTransform = n, this._updateBoundingVolume(this.header));\n  } // Get options which are applicable only for the particular loader\n\n\n  _getLoaderSpecificOptions(t) {\n    switch (t) {\n      case \"i3s\":\n        return { ...this.tileset.options.i3s,\n          _tileOptions: {\n            attributeUrls: this.header.attributeUrls,\n            textureUrl: this.header.textureUrl,\n            textureFormat: this.header.textureFormat,\n            textureLoaderOptions: this.header.textureLoaderOptions,\n            materialDefinition: this.header.materialDefinition,\n            isDracoGeometry: this.header.isDracoGeometry,\n            mbs: this.header.mbs\n          },\n          _tilesetOptions: {\n            store: this.tileset.tileset.store,\n            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,\n            fields: this.tileset.tileset.fields\n          },\n          isTileHeader: !1\n        };\n\n      case \"3d-tiles\":\n      case \"cesium-ion\":\n      default:\n        return BB(this.tileset.tileset);\n    }\n  }\n\n}\n\nclass TB extends ts {\n  compareDistanceToCamera(t, n) {\n    return n._distanceToCamera === 0 && t._distanceToCamera === 0 ? n._centerZDepth - t._centerZDepth : n._distanceToCamera - t._distanceToCamera;\n  }\n\n  updateTileVisibility(t, n) {\n    if (super.updateTileVisibility(t, n), !t.isVisibleAndInRequestVolume) return;\n    const s = t.children.length > 0;\n\n    if (t.hasTilesetContent && s) {\n      const o = t.children[0];\n      this.updateTileVisibility(o, n), t._visible = o._visible;\n      return;\n    }\n\n    if (this.meetsScreenSpaceErrorEarly(t, n)) {\n      t._visible = !1;\n      return;\n    }\n\n    const r = t.refine === Ht.REPLACE,\n          i = t._optimChildrenWithinParent === oB.USE_OPTIMIZATION;\n\n    if (r && i && s && !this.anyChildrenVisible(t, n)) {\n      t._visible = !1;\n      return;\n    }\n  }\n\n  meetsScreenSpaceErrorEarly(t, n) {\n    const {\n      parent: s\n    } = t;\n    return !s || s.hasTilesetContent || s.refine !== Ht.ADD ? !1 : !this.shouldRefine(t, n, !0);\n  }\n\n}\n\nclass bB {\n  constructor() {\n    p(this, \"frameNumberMap\", /* @__PURE__ */new Map());\n  }\n  /**\n   * Register a new pending tile header for the particular frameNumber\n   * @param viewportId\n   * @param frameNumber\n   */\n\n\n  register(t, n) {\n    const s = this.frameNumberMap.get(t) || /* @__PURE__ */new Map(),\n          r = s.get(n) || 0;\n    s.set(n, r + 1), this.frameNumberMap.set(t, s);\n  }\n  /**\n   * Deregister a pending tile header for the particular frameNumber\n   * @param viewportId\n   * @param frameNumber\n   */\n\n\n  deregister(t, n) {\n    const s = this.frameNumberMap.get(t);\n    if (!s) return;\n    const r = s.get(n) || 1;\n    s.set(n, r - 1);\n  }\n  /**\n   * Check is there are no pending tile headers registered for the particular frameNumber\n   * @param viewportId\n   * @param frameNumber\n   * @returns\n   */\n\n\n  isZero(t, n) {\n    var r;\n    return (((r = this.frameNumberMap.get(t)) == null ? void 0 : r.get(n)) || 0) === 0;\n  }\n\n}\n\nconst Ls = {\n  REQUESTED: \"REQUESTED\",\n  COMPLETED: \"COMPLETED\",\n  ERROR: \"ERROR\"\n};\n\nclass _B {\n  constructor() {\n    p(this, \"_statusMap\");\n    p(this, \"pendingTilesRegister\", new bB());\n    this._statusMap = {};\n  }\n  /**\n   * Add request to map\n   * @param request - node metadata request\n   * @param key - unique key\n   * @param callback - callback after request completed\n   * @param frameState - frameState data\n   */\n\n\n  add(t, n, s, r) {\n    if (!this._statusMap[n]) {\n      const {\n        frameNumber: i,\n        viewport: {\n          id: o\n        }\n      } = r;\n      this._statusMap[n] = {\n        request: t,\n        callback: s,\n        key: n,\n        frameState: r,\n        status: Ls.REQUESTED\n      }, this.pendingTilesRegister.register(o, i), t().then(a => {\n        this._statusMap[n].status = Ls.COMPLETED;\n        const {\n          frameNumber: c,\n          viewport: {\n            id: u\n          }\n        } = this._statusMap[n].frameState;\n        this.pendingTilesRegister.deregister(u, c), this._statusMap[n].callback(a, r);\n      }).catch(a => {\n        this._statusMap[n].status = Ls.ERROR;\n        const {\n          frameNumber: c,\n          viewport: {\n            id: u\n          }\n        } = this._statusMap[n].frameState;\n        this.pendingTilesRegister.deregister(u, c), s(a);\n      });\n    }\n  }\n  /**\n   * Update request if it is still actual for the new frameState\n   * @param key - unique key\n   * @param frameState - frameState data\n   */\n\n\n  update(t, n) {\n    if (this._statusMap[t]) {\n      const {\n        frameNumber: s,\n        viewport: {\n          id: r\n        }\n      } = this._statusMap[t].frameState;\n      this.pendingTilesRegister.deregister(r, s);\n      const {\n        frameNumber: i,\n        viewport: {\n          id: o\n        }\n      } = n;\n      this.pendingTilesRegister.register(o, i), this._statusMap[t].frameState = n;\n    }\n  }\n  /**\n   * Find request in the map\n   * @param key - unique key\n   * @returns\n   */\n\n\n  find(t) {\n    return this._statusMap[t];\n  }\n  /**\n   * Check it there are pending tile headers for the particular frameNumber\n   * @param viewportId\n   * @param frameNumber\n   * @returns\n   */\n\n\n  hasPendingTiles(t, n) {\n    return !this.pendingTilesRegister.isZero(t, n);\n  }\n\n}\n\nclass wB extends ts {\n  constructor(n) {\n    super(n);\n    p(this, \"_tileManager\");\n    this._tileManager = new _B();\n  }\n  /**\n   * Check if there are no penging tile header requests,\n   * that means the traversal is finished and we can call\n   * following-up callbacks.\n   */\n\n\n  traversalFinished(n) {\n    return !this._tileManager.hasPendingTiles(n.viewport.id, this._frameNumber || 0);\n  }\n\n  shouldRefine(n, s) {\n    return n._lodJudge = yB(n, s), n._lodJudge === \"DIG\";\n  }\n\n  updateChildTiles(n, s) {\n    const r = n.header.children || [],\n          i = n.children,\n          o = n.tileset;\n\n    for (const a of r) {\n      const c = `${a.id}-${s.viewport.id}`,\n            u = i && i.find(l => l.id === c);\n      if (u) u && this.updateTile(u, s);else {\n        let l = () => this._loadTile(a.id, o);\n\n        this._tileManager.find(c) ? this._tileManager.update(c, s) : (o.tileset.nodePages && (l = () => o.tileset.nodePagesTile.formTileFromNodePages(a.id)), this._tileManager.add(l, c, f => this._onTileLoad(f, n, c), s));\n      }\n    }\n\n    return !1;\n  }\n\n  async _loadTile(n, s) {\n    const {\n      loader: r\n    } = s,\n          i = s.getTileUrl(`${s.url}/nodes/${n}`),\n          o = { ...s.loadOptions,\n      i3s: { ...s.loadOptions.i3s,\n        isTileHeader: !0\n      }\n    };\n    return await Ae(i, r, o);\n  }\n  /**\n   * The callback to init Tile3D instance after loading the tile JSON\n   * @param {Object} header - the tile JSON from a dataset\n   * @param {Tile3D} tile - the parent Tile3D instance\n   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.\n   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;\n   * @return {void}\n   */\n\n\n  _onTileLoad(n, s, r) {\n    const i = new ur(s.tileset, n, s, r);\n    s.children.push(i);\n\n    const o = this._tileManager.find(i.id).frameState;\n\n    this.updateTile(i, o), this._frameNumber === o.frameNumber && (this.traversalFinished(o) || /* @__PURE__ */new Date().getTime() - this.lastUpdate > this.updateDebounceTime) && this.executeTraversal(i, o);\n  }\n\n}\n\nconst RB = {\n  description: \"\",\n  ellipsoid: J.WGS84,\n  modelMatrix: new V(),\n  throttleRequests: !0,\n  maxRequests: 64,\n\n  /** Default memory values optimized for viewing mesh-based 3D Tiles on both mobile and desktop devices */\n  maximumMemoryUsage: 32,\n  memoryCacheOverflow: 1,\n  maximumTilesSelected: 0,\n  debounceTime: 0,\n  onTileLoad: () => {},\n  onTileUnload: () => {},\n  onTileError: () => {},\n  onTraversalComplete: e => e,\n  contentLoader: void 0,\n  viewDistanceScale: 1,\n  maximumScreenSpaceError: 8,\n  memoryAdjustedScreenSpaceError: !1,\n  loadTiles: !0,\n  updateTransforms: !0,\n  viewportTraversersMap: null,\n  loadOptions: {\n    fetch: {}\n  },\n  attributions: [],\n  basePath: \"\",\n  i3s: {}\n},\n      Cn = \"Tiles In Tileset(s)\",\n      Ps = \"Tiles In Memory\",\n      Oo = \"Tiles In View\",\n      Fo = \"Tiles To Render\",\n      Do = \"Tiles Loaded\",\n      Gs = \"Tiles Loading\",\n      Lo = \"Tiles Unloaded\",\n      Po = \"Failed Tile Loads\",\n      Go = \"Points/Vertices\",\n      Ns = \"Tile Memory Use\",\n      No = \"Maximum Screen Space Error\";\n\nclass MB {\n  /**\n   * Create a new Tileset3D\n   * @param json\n   * @param props\n   */\n  // eslint-disable-next-line max-statements\n  constructor(t, n) {\n    // props: Tileset3DProps;\n    p(this, \"options\");\n    p(this, \"loadOptions\");\n    p(this, \"type\");\n    p(this, \"tileset\");\n    p(this, \"loader\");\n    p(this, \"url\");\n    p(this, \"basePath\");\n    p(this, \"modelMatrix\");\n    p(this, \"ellipsoid\");\n    p(this, \"lodMetricType\");\n    p(this, \"lodMetricValue\");\n    p(this, \"refine\");\n    p(this, \"root\", null);\n    p(this, \"roots\", {});\n    /** @todo any->unknown */\n\n    p(this, \"asset\", {}); // Metadata for the entire tileset\n\n    p(this, \"description\", \"\");\n    p(this, \"properties\");\n    p(this, \"extras\", null);\n    p(this, \"attributions\", {});\n    p(this, \"credits\", {});\n    p(this, \"stats\");\n    /** flags that contain information about data types in nested tiles */\n\n    p(this, \"contentFormats\", {\n      draco: !1,\n      meshopt: !1,\n      dds: !1,\n      ktx2: !1\n    }); // view props\n\n    p(this, \"cartographicCenter\", null);\n    p(this, \"cartesianCenter\", null);\n    p(this, \"zoom\", 1);\n    p(this, \"boundingVolume\", null);\n    /** Updated based on the camera position and direction */\n\n    p(this, \"dynamicScreenSpaceErrorComputedDensity\", 0); // METRICS\n\n    /**\n     * The maximum amount of GPU memory (in MB) that may be used to cache tiles\n     * Tiles not in view are unloaded to enforce private\n     */\n\n    p(this, \"maximumMemoryUsage\", 32);\n    /** The total amount of GPU memory in bytes used by the tileset. */\n\n    p(this, \"gpuMemoryUsageInBytes\", 0);\n    /**\n     * If loading the level of detail required by maximumScreenSpaceError\n     * results in the memory usage exceeding maximumMemoryUsage (GPU), level of detail refinement\n     * will instead use this (larger) adjusted screen space error to achieve the\n     * best possible visual quality within the available memory.\n     */\n\n    p(this, \"memoryAdjustedScreenSpaceError\", 0);\n    p(this, \"_cacheBytes\", 0);\n    p(this, \"_cacheOverflowBytes\", 0);\n    /** Update tracker. increase in each update cycle. */\n\n    p(this, \"_frameNumber\", 0);\n    p(this, \"_queryParams\", {});\n    p(this, \"_extensionsUsed\", []);\n    p(this, \"_tiles\", {});\n    /** counter for tracking tiles requests */\n\n    p(this, \"_pendingCount\", 0);\n    /** Hold traversal results */\n\n    p(this, \"selectedTiles\", []); // TRAVERSAL\n\n    p(this, \"traverseCounter\", 0);\n    p(this, \"geometricError\", 0);\n    p(this, \"lastUpdatedVieports\", null);\n    p(this, \"_requestedTiles\", []);\n    p(this, \"_emptyTiles\", []);\n    p(this, \"frameStateData\", {});\n    p(this, \"_traverser\");\n    p(this, \"_cache\", new qy());\n    p(this, \"_requestScheduler\"); // Promise tracking\n\n    p(this, \"updatePromise\", null);\n    p(this, \"tilesetInitializationPromise\");\n    this.options = { ...RB,\n      ...n\n    }, this.tileset = t, this.loader = t.loader, this.type = t.type, this.url = t.url, this.basePath = t.basePath || Wy(this.url), this.modelMatrix = this.options.modelMatrix, this.ellipsoid = this.options.ellipsoid, this.lodMetricType = t.lodMetricType, this.lodMetricValue = t.lodMetricValue, this.refine = t.root.refine, this.loadOptions = this.options.loadOptions || {}, this._traverser = this._initializeTraverser(), this._requestScheduler = new zy({\n      throttleRequests: this.options.throttleRequests,\n      maxRequests: this.options.maxRequests\n    }), this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError, this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024, this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024, this.stats = new $o({\n      id: this.url\n    }), this._initializeStats(), this.tilesetInitializationPromise = this._initializeTileSet(t);\n  }\n  /** Release resources */\n\n\n  destroy() {\n    this._destroy();\n  }\n  /** Is the tileset loaded (update needs to have been called at least once) */\n\n\n  isLoaded() {\n    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;\n  }\n\n  get tiles() {\n    return Object.values(this._tiles);\n  }\n\n  get frameNumber() {\n    return this._frameNumber;\n  }\n\n  get queryParams() {\n    return new URLSearchParams(this._queryParams).toString();\n  }\n\n  setProps(t) {\n    this.options = { ...this.options,\n      ...t\n    };\n  }\n  /** @deprecated */\n  // setOptions(options: Tileset3DProps): void {\n  //   this.options = {...this.options, ...options};\n  // }\n\n  /**\n   * Return a loadable tile url for a specific tile subpath\n   * @param tilePath a tile subpath\n   */\n\n\n  getTileUrl(t) {\n    if (t.startsWith(\"data:\")) return t;\n    let s = t;\n    return this.queryParams.length && (s = `${t}${t.includes(\"?\") ? \"&\" : \"?\"}${this.queryParams}`), s;\n  } // TODO CESIUM specific\n\n\n  hasExtension(t) {\n    return this._extensionsUsed.indexOf(t) > -1;\n  }\n  /**\n   * Update visible tiles relying on a list of viewports\n   * @param viewports - list of viewports\n   * @deprecated\n   */\n\n\n  update(t = null) {\n    this.tilesetInitializationPromise.then(() => {\n      !t && this.lastUpdatedVieports ? t = this.lastUpdatedVieports : this.lastUpdatedVieports = t, t && this.doUpdate(t);\n    });\n  }\n  /**\n   * Update visible tiles relying on a list of viewports.\n   * Do it with debounce delay to prevent update spam\n   * @param viewports viewports\n   * @returns Promise of new frameNumber\n   */\n\n\n  async selectTiles(t = null) {\n    return await this.tilesetInitializationPromise, t && (this.lastUpdatedVieports = t), this.updatePromise || (this.updatePromise = new Promise(n => {\n      setTimeout(() => {\n        this.lastUpdatedVieports && this.doUpdate(this.lastUpdatedVieports), n(this._frameNumber), this.updatePromise = null;\n      }, this.options.debounceTime);\n    })), this.updatePromise;\n  }\n\n  adjustScreenSpaceError() {\n    this.gpuMemoryUsageInBytes < this._cacheBytes ? this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError) : this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes && (this.memoryAdjustedScreenSpaceError *= 1.02);\n  }\n  /**\n   * Update visible tiles relying on a list of viewports\n   * @param viewports viewports\n   */\n  // eslint-disable-next-line max-statements, complexity\n\n\n  doUpdate(t) {\n    if (\"loadTiles\" in this.options && !this.options.loadTiles || this.traverseCounter > 0) return;\n    const n = t instanceof Array ? t : [t];\n    this._cache.reset(), this._frameNumber++, this.traverseCounter = n.length;\n    const s = [];\n\n    for (const r of n) {\n      const i = r.id;\n      this._needTraverse(i) ? s.push(i) : this.traverseCounter--;\n    }\n\n    for (const r of n) {\n      const i = r.id;\n      if (this.roots[i] || (this.roots[i] = this._initializeTileHeaders(this.tileset, null)), !s.includes(i)) continue;\n      const o = $y(r, this._frameNumber);\n\n      this._traverser.traverse(this.roots[i], o, this.options);\n    }\n  }\n  /**\n   * Check if traversal is needed for particular viewport\n   * @param {string} viewportId - id of a viewport\n   * @return {boolean}\n   */\n\n\n  _needTraverse(t) {\n    let n = t;\n    return this.options.viewportTraversersMap && (n = this.options.viewportTraversersMap[t]), n === t;\n  }\n  /**\n   * The callback to post-process tiles after traversal procedure\n   * @param frameState - frame state for tile culling\n   */\n\n\n  _onTraversalEnd(t) {\n    const n = t.viewport.id;\n    this.frameStateData[n] || (this.frameStateData[n] = {\n      selectedTiles: [],\n      _requestedTiles: [],\n      _emptyTiles: []\n    });\n    const s = this.frameStateData[n],\n          r = Object.values(this._traverser.selectedTiles),\n          [i, o] = Zy(r, t, this.options.maximumTilesSelected);\n    s.selectedTiles = i;\n\n    for (const a of o) a.unselect();\n\n    s._requestedTiles = Object.values(this._traverser.requestedTiles), s._emptyTiles = Object.values(this._traverser.emptyTiles), this.traverseCounter--, !(this.traverseCounter > 0) && this._updateTiles();\n  }\n  /**\n   * Update tiles relying on data from all traversers\n   */\n\n\n  _updateTiles() {\n    this.selectedTiles = [], this._requestedTiles = [], this._emptyTiles = [];\n\n    for (const t in this.frameStateData) {\n      const n = this.frameStateData[t];\n      this.selectedTiles = this.selectedTiles.concat(n.selectedTiles), this._requestedTiles = this._requestedTiles.concat(n._requestedTiles), this._emptyTiles = this._emptyTiles.concat(n._emptyTiles);\n    }\n\n    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);\n\n    for (const t of this.selectedTiles) this._tiles[t.id] = t;\n\n    this._loadTiles(), this._unloadTiles(), this._updateStats();\n  }\n\n  _tilesChanged(t, n) {\n    if (t.length !== n.length) return !0;\n    const s = new Set(t.map(o => o.id)),\n          r = new Set(n.map(o => o.id));\n    let i = t.filter(o => !r.has(o.id)).length > 0;\n    return i = i || n.filter(o => !s.has(o.id)).length > 0, i;\n  }\n\n  _loadTiles() {\n    for (const t of this._requestedTiles) t.contentUnloaded && this._loadTile(t);\n  }\n\n  _unloadTiles() {\n    this._cache.unloadTiles(this, (t, n) => t._unloadTile(n));\n  }\n\n  _updateStats() {\n    let t = 0,\n        n = 0;\n\n    for (const s of this.selectedTiles) s.contentAvailable && s.content && (t++, s.content.pointCount ? n += s.content.pointCount : n += s.content.vertexCount);\n\n    this.stats.get(Oo).count = this.selectedTiles.length, this.stats.get(Fo).count = t, this.stats.get(Go).count = n, this.stats.get(No).count = this.memoryAdjustedScreenSpaceError;\n  }\n\n  async _initializeTileSet(t) {\n    this.type === At.I3S && (this.calculateViewPropsI3S(), t.root = await t.root), this.root = this._initializeTileHeaders(t, null), this.type === At.TILES3D && (this._initializeTiles3DTileset(t), this.calculateViewPropsTiles3D()), this.type === At.I3S && this._initializeI3STileset();\n  }\n  /**\n   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.\n   * These metrics help apps center view on tileset\n   * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props\n   * @returns\n   */\n\n\n  calculateViewPropsI3S() {\n    var s;\n    const t = this.tileset.fullExtent;\n\n    if (t) {\n      const {\n        xmin: r,\n        xmax: i,\n        ymin: o,\n        ymax: a,\n        zmin: c,\n        zmax: u\n      } = t;\n      this.cartographicCenter = new A(r + (i - r) / 2, o + (a - o) / 2, c + (u - c) / 2), this.cartesianCenter = new A(), J.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = xc(t, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n\n    const n = (s = this.tileset.store) == null ? void 0 : s.extent;\n\n    if (n) {\n      const [r, i, o, a] = n;\n      this.cartographicCenter = new A(r + (o - r) / 2, i + (a - i) / 2, 0), this.cartesianCenter = new A(), J.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = rB(n, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n\n    console.warn(\"Extent is not defined in the tileset header\"), this.cartographicCenter = new A(), this.zoom = 1;\n  }\n  /**\n   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.\n   * These metrics help apps center view on tileset.\n   * For 3DTiles the root tile data is used to calculate view props.\n   * @returns\n   */\n\n\n  calculateViewPropsTiles3D() {\n    const t = this.root,\n          {\n      center: n\n    } = t.boundingVolume;\n\n    if (!n) {\n      console.warn(\"center was not pre-calculated for the root tile\"), this.cartographicCenter = new A(), this.zoom = 1;\n      return;\n    }\n\n    n[0] !== 0 || n[1] !== 0 || n[2] !== 0 ? (this.cartographicCenter = new A(), J.WGS84.cartesianToCartographic(n, this.cartographicCenter)) : this.cartographicCenter = new A(0, 0, -J.WGS84.radii[0]), this.cartesianCenter = n, this.zoom = sB(t.boundingVolume, this.cartographicCenter);\n  }\n\n  _initializeStats() {\n    this.stats.get(Cn), this.stats.get(Gs), this.stats.get(Ps), this.stats.get(Oo), this.stats.get(Fo), this.stats.get(Do), this.stats.get(Lo), this.stats.get(Po), this.stats.get(Go), this.stats.get(Ns, \"memory\"), this.stats.get(No);\n  } // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.\n  // eslint-disable-next-line max-statements\n\n\n  _initializeTileHeaders(t, n) {\n    var r;\n    const s = new ur(this, t.root, n);\n\n    if (n && (n.children.push(s), s.depth = n.depth + 1), this.type === At.TILES3D) {\n      const i = [];\n\n      for (i.push(s); i.length > 0;) {\n        const o = i.pop();\n        this.stats.get(Cn).incrementCount();\n        const a = o.header.children || [];\n\n        for (const c of a) {\n          const u = new ur(this, c, o);\n\n          if ((r = u.contentUrl) != null && r.includes(\"?session=\")) {\n            const h = new URL(u.contentUrl).searchParams.get(\"session\");\n            h && (this._queryParams.session = h);\n          }\n\n          o.children.push(u), u.depth = o.depth + 1, i.push(u);\n        }\n      }\n    }\n\n    return s;\n  }\n\n  _initializeTraverser() {\n    let t;\n\n    switch (this.type) {\n      case At.TILES3D:\n        t = TB;\n        break;\n\n      case At.I3S:\n        t = wB;\n        break;\n\n      default:\n        t = ts;\n    }\n\n    return new t({\n      basePath: this.basePath,\n      onTraversalEnd: this._onTraversalEnd.bind(this)\n    });\n  }\n\n  _destroyTileHeaders(t) {\n    this._destroySubtree(t);\n  }\n\n  async _loadTile(t) {\n    let n;\n\n    try {\n      this._onStartTileLoading(), n = await t.loadContent();\n    } catch (s) {\n      this._onTileLoadError(t, s instanceof Error ? s : new Error(\"load failed\"));\n    } finally {\n      this._onEndTileLoading(), this._onTileLoad(t, n);\n    }\n  }\n\n  _onTileLoadError(t, n) {\n    this.stats.get(Po).incrementCount();\n    const s = n.message || n.toString(),\n          r = t.url;\n    console.error(`A 3D tile failed to load: ${t.url} ${s}`), this.options.onTileError(t, s, r);\n  }\n\n  _onTileLoad(t, n) {\n    var s, r;\n\n    if (n) {\n      if (this.type === At.I3S) {\n        const i = ((r = (s = this.tileset) == null ? void 0 : s.nodePagesTile) == null ? void 0 : r.nodesInNodePages) || 0;\n        this.stats.get(Cn).reset(), this.stats.get(Cn).addCount(i);\n      }\n\n      t && t.content && Yy(t, t.content), this.updateContentTypes(t), this._addTileToCache(t), this.options.onTileLoad(t);\n    }\n  }\n  /**\n   * Update information about data types in nested tiles\n   * @param tile instance of a nested Tile3D\n   */\n\n\n  updateContentTypes(t) {\n    var n;\n    if (this.type === At.I3S) switch (t.header.isDracoGeometry && (this.contentFormats.draco = !0), t.header.textureFormat) {\n      case \"dds\":\n        this.contentFormats.dds = !0;\n        break;\n\n      case \"ktx2\":\n        this.contentFormats.ktx2 = !0;\n        break;\n    } else if (this.type === At.TILES3D) {\n      const {\n        extensionsRemoved: s = []\n      } = ((n = t.content) == null ? void 0 : n.gltf) || {};\n      s.includes(\"KHR_draco_mesh_compression\") && (this.contentFormats.draco = !0), s.includes(\"EXT_meshopt_compression\") && (this.contentFormats.meshopt = !0), s.includes(\"KHR_texture_basisu\") && (this.contentFormats.ktx2 = !0);\n    }\n  }\n\n  _onStartTileLoading() {\n    this._pendingCount++, this.stats.get(Gs).incrementCount();\n  }\n\n  _onEndTileLoading() {\n    this._pendingCount--, this.stats.get(Gs).decrementCount();\n  }\n\n  _addTileToCache(t) {\n    this._cache.add(this, t, n => n._updateCacheStats(t));\n  }\n\n  _updateCacheStats(t) {\n    this.stats.get(Do).incrementCount(), this.stats.get(Ps).incrementCount(), this.gpuMemoryUsageInBytes += t.gpuMemoryUsageInBytes || 0, this.stats.get(Ns).count = this.gpuMemoryUsageInBytes, this.options.memoryAdjustedScreenSpaceError && this.adjustScreenSpaceError();\n  }\n\n  _unloadTile(t) {\n    this.gpuMemoryUsageInBytes -= t.gpuMemoryUsageInBytes || 0, this.stats.get(Ps).decrementCount(), this.stats.get(Lo).incrementCount(), this.stats.get(Ns).count = this.gpuMemoryUsageInBytes, this.options.onTileUnload(t), t.unloadContent();\n  } // Traverse the tree and destroy all tiles\n\n\n  _destroy() {\n    const t = [];\n\n    for (this.root && t.push(this.root); t.length > 0;) {\n      const n = t.pop();\n\n      for (const s of n.children) t.push(s);\n\n      this._destroyTile(n);\n    }\n\n    this.root = null;\n  } // Traverse the tree and destroy all sub tiles\n\n\n  _destroySubtree(t) {\n    const n = t,\n          s = [];\n\n    for (s.push(n); s.length > 0;) {\n      t = s.pop();\n\n      for (const r of t.children) s.push(r);\n\n      t !== n && this._destroyTile(t);\n    }\n\n    n.children = [];\n  }\n\n  _destroyTile(t) {\n    this._cache.unloadTile(this, t), this._unloadTile(t), t.destroy();\n  }\n\n  _initializeTiles3DTileset(t) {\n    if (t.queryString) {\n      const n = new URLSearchParams(t.queryString),\n            s = Object.fromEntries(n.entries());\n      this._queryParams = { ...this._queryParams,\n        ...s\n      };\n    }\n\n    if (this.asset = t.asset, !this.asset) throw new Error(\"Tileset must have an asset property.\");\n    if (this.asset.version !== \"0.0\" && this.asset.version !== \"1.0\" && this.asset.version !== \"1.1\") throw new Error(\"The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.\");\n    \"tilesetVersion\" in this.asset && (this._queryParams.v = this.asset.tilesetVersion), this.credits = {\n      attributions: this.options.attributions || []\n    }, this.description = this.options.description || \"\", this.properties = t.properties, this.geometricError = t.geometricError, this._extensionsUsed = t.extensionsUsed || [], this.extras = t.extras;\n  }\n\n  _initializeI3STileset() {\n    this.loadOptions.i3s && \"token\" in this.loadOptions.i3s && (this._queryParams.token = this.loadOptions.i3s.token);\n  }\n\n}\n\nfunction SB(e) {\n  let t = 0;\n\n  for (const s in e.attributes) {\n    const r = e.getAttribute(s);\n    t += r.count * r.itemSize * r.array.BYTES_PER_ELEMENT;\n  }\n\n  const n = e.getIndex();\n  return t += n ? n.count * n.itemSize * n.array.BYTES_PER_ELEMENT : 0, t;\n}\n\nfunction Pc(e) {\n  const n = document.createElement(\"canvas\");\n  n.width = 64, n.height = 64;\n  const s = n.getContext(\"2d\");\n  s.rect(0, 0, 64, 64);\n  const r = s.createLinearGradient(0, 0, 64, 64);\n\n  for (let o = 0; o < e.length; o++) {\n    const a = e[o];\n    r.addColorStop(a[0], \"#\" + a[1].getHexString());\n  }\n\n  s.fillStyle = r, s.fill();\n  const i = new three__WEBPACK_IMPORTED_MODULE_0__.CanvasTexture(n);\n  return i.needsUpdate = !0, i.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, i.wrapS = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping, i.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping, i.repeat.set(2, 2), i;\n}\n\nfunction Uo(e) {\n  e.updateMatrix(), e.updateMatrixWorld(), e.matrixWorldInverse.copy(e.matrixWorld).invert();\n  const t = new three__WEBPACK_IMPORTED_MODULE_0__.Frustum();\n  return t.setFromProjectionMatrix(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse)), t;\n}\n\nfunction IB(e) {\n  const t = new three__WEBPACK_IMPORTED_MODULE_0__.Group(),\n        n = new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(10, 5),\n        s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...e.projectPointOntoPlane([0, 0, 0])),\n        r = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(e.normal.x, e.normal.y, e.normal.z),\n        i = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(s).add(r);\n  n.lookAt(i), n.translate(s.x, s.y, s.z);\n  const o = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n    color: 65535,\n    side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide\n  }),\n        a = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(n, o),\n        c = new three__WEBPACK_IMPORTED_MODULE_0__.ArrowHelper(r, s, 5, 16776960);\n  return t.add(c), t.add(a), t;\n}\n\nfunction Ho(e) {\n  const {\n    boundingVolume: t\n  } = e;\n  let n = 0;\n  e.content && (n = Math.min(e.content.byteLength / 5e5, 1));\n  const s = new three__WEBPACK_IMPORTED_MODULE_0__.Color(n, 1, 0),\n        r = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(1, 1, 1),\n        i = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n  t.halfAxes ? i.copy(Gc(t.halfAxes)) : t.radius && r.scale(t.radius * 2, t.radius * 2, t.radius * 2), r.applyMatrix4(i);\n  const o = new three__WEBPACK_IMPORTED_MODULE_0__.EdgesGeometry(r),\n        a = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(o, new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({\n    color: s\n  }));\n  return a.position.copy(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...t.center)), a;\n}\n\nfunction Gc(e) {\n  const t = e;\n  return new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray([t[0] * 2, t[1] * 2, t[2] * 2, 0, t[3] * 2, t[4] * 2, t[5] * 2, 0, t[6] * 2, t[7] * 2, t[8] * 2, 0, 0, 0, 0, 1]);\n}\n\nfunction xB(e, t) {\n  const r = 2 * Math.PI * 6378137 / 2,\n        i = t * r / 180;\n  let o = Math.log(Math.tan((90 + e) * Math.PI / 360)) / (Math.PI / 180);\n  return o = o * r / 180, new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(i, o);\n}\n\nfunction vB(e) {\n  let t = 0;\n\n  if ((e == null ? void 0 : e.userData.mimeType) == \"image/ktx2\" && e.mipmaps) {\n    for (let n = 0; n < e.mipmaps.length; n++) t += e.mipmaps[n].data.byteLength;\n\n    return t;\n  } else if (e.image) {\n    const {\n      image: n\n    } = e,\n          s = 4;\n    let r = [n.width, n.height];\n\n    for (; r[0] > 1 || r[1] > 1;) t += r[0] * r[1] * s, r[0] = Math.max(Math.floor(r[0] / 2), 1), r[1] = Math.max(Math.floor(r[1] / 2), 1);\n\n    return t += 1 * 1 * s, t;\n  } else return;\n}\n\nfunction Nc(e) {\n  return SB(e);\n}\n\nlet ht = null,\n    Mt = null,\n    Jn = null,\n    Mn = null;\nconst Jo = {\n  minHeight: 0,\n  maxHeight: 300,\n  samples: 4,\n  sampleStep: 4,\n  opacity: 0.5,\n  blendingType: three__WEBPACK_IMPORTED_MODULE_0__.NormalBlending\n};\n\nfunction OB(e, t, n, s = Jo) {\n  ht && ht.dispose(), Mt || (Mt = n);\n  const r = { ...Jo,\n    ...s\n  };\n  ht = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(e.width * e.devicePixelRatio, e.height * e.devicePixelRatio), ht.texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter, ht.texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter, ht.stencilBuffer = !1, ht.texture.format = three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, ht.texture.type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType, Mt.setPixelRatio(devicePixelRatio), Mt.setSize(e.width, e.height), Mt.setRenderTarget(ht), Jn = new three__WEBPACK_IMPORTED_MODULE_0__.Scene(), Jn.overrideMaterial = LB, Mn = t, kt.uniforms.tPosition.value = ht.texture, kt.uniforms.minHeight.value = r.minHeight, kt.uniforms.maxHeight.value = r.maxHeight, kt.uniforms.samples.value = r.samples, kt.uniforms.sampleStep.value = r.sampleStep, kt.uniforms.opacity.value = r.opacity, kt.blending = r.blendingType;\n}\n\nfunction FB(e) {\n  ht.setSize(e.width * e.devicePixelRatio, e.height * e.devicePixelRatio), Mt.setPixelRatio(devicePixelRatio), Mt.setSize(e.width, e.height);\n}\n\nfunction DB(e) {\n  if (Mt) {\n    const t = Mn.parent;\n    Jn.add(Mn), Mt.setRenderTarget(ht), Mt.render(Jn, e), t && t.add(Mn), Mt.setRenderTarget(null);\n  }\n}\n\nconst Vn = e => e.toString(),\n      LB = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n  vertexShader: Vn`\n        varying vec3 vPosition;\n        void main() {\n            vPosition =  (modelMatrix * vec4(position, 1.0)).xyz;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n    `,\n  fragmentShader: Vn`\n        varying vec3 vPosition;\n        void main() {\n            gl_FragColor = vec4(vPosition, 1.0);\n        }\n    `,\n  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide\n}),\n      PB = Vn`\n    #include <packing>\n\n    varying vec2 vUv;\n    varying vec3 vColor;\n    uniform sampler2D tPosition;\n    uniform float minHeight;\n    uniform float maxHeight;\n    uniform int samples;\n    uniform float sampleStep;\n\n    mat4 MVP;\n\n    // Convert to normalized screen coordinates\n    vec4 toNSC(const in vec4 v) {\n        return vec4(0.5 * (v.xyz / v.w) + 0.5, v.w);\n    }\n    vec4 vertexDraping(\n        const in sampler2D positionTex, // Position G-Buffer\n        const in vec4 Vin // Vertex to drape\n    ) {\n        float texSize = float(textureSize(positionTex, 0).x);\n        float pixelSize = 1.0 / texSize;\n        vec2 stepSize = vec2(sampleStep/texSize);\n        vec4 VinWorld = modelMatrix * Vin;\n\n        vec4 lineStart = projectionMatrix * viewMatrix * vec4(VinWorld.x, minHeight, VinWorld.z, 1.0);\n        vec4 lineEnd = projectionMatrix * viewMatrix * vec4(VinWorld.x, maxHeight, VinWorld.z, 1.0);\n\n        vec4 Vout = VinWorld;\n\n        // Binary search for line-terrain intersection\n        float first = 0.0, last = 1.0;\n        while(first <= last) {\n            // Compute mid-point\n            float mid = first + (last-first) / 2.0;\n            // Compute texture coordinates along line\n            vec4 texCoords = toNSC(mix(lineStart, lineEnd, mid));\n            vec4 texSample = vec4(0.0); // Sample terrain\n            for(int s = -samples; s < samples; s++) {\n                for(int t = -samples; t < samples; t++) {\n                    texSample += texture(positionTex,\n                    texCoords.st + vec2(s,t) * stepSize);\n                }\n            }\n            // Smooth samples obtain from G-Buffer\n            texSample = texSample / (float(samples) * float(samples) * 4.0);\n            float terrainHeight = texSample.y;\n            Vout.y = terrainHeight;\n           \n            if((last-first) < pixelSize) { // Termination criteria\n                return Vout;\n            }\n            // Perform intersection test\n            float depthScene = toNSC(projectionMatrix * viewMatrix * Vout).y;\n            if(depthScene >= texCoords.y) {\n                first = mid;\n            }\n            else\n                last = mid;\n        }\n        return Vout;\n    }\n\n    void main() {\n        vColor = color;\n        vUv = uv;\n        MVP = projectionMatrix * modelViewMatrix;\n        vec4 inputVertex = vec4(position, 1.0);\n        vec4 outputVertex = vertexDraping(tPosition, inputVertex);\n        vec4 finalPosition = projectionMatrix * viewMatrix * outputVertex;\n        gl_Position = finalPosition;\n    }\n`,\n      GB = Vn`\n    varying vec3 vColor;\n    uniform float opacity;\n\n    void main() {\n        gl_FragColor = vec4(vColor, opacity);\n    }\n`,\n      kt = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n  vertexShader: PB,\n  fragmentShader: GB,\n  uniforms: {\n    tPosition: {\n      value: null\n    },\n    minHeight: {\n      value: 0\n    },\n    maxHeight: {\n      value: 300\n    },\n    opacity: {\n      value: 0.5\n    },\n    samples: {\n      value: 4\n    },\n    sampleStep: {\n      value: 4\n    }\n  },\n  vertexColors: !0,\n  transparent: !0,\n  depthTest: !1,\n  blending: three__WEBPACK_IMPORTED_MODULE_0__.NormalBlending\n}),\n      Uc = {\n  // From chroma spectral http://gka.github.io/chroma.js/\n  SPECTRAL: [[0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.3686, 0.3098, 0.6353)], [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.1961, 0.5333, 0.7412)], [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.4, 0.7608, 0.6471)], [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.6706, 0.8667, 0.6431)], [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.902, 0.9608, 0.5961)], [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 0.749)], [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9961, 0.8784, 0.5451)], [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9922, 0.6824, 0.3804)], [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9569, 0.4275, 0.2627)], [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.8353, 0.2431, 0.3098)], [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.6196, 39e-4, 0.2588)]],\n  PLASMA: [[0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.241, 0.015, 0.61)], [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.387, 1e-3, 0.654)], [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.524, 0.025, 0.653)], [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.651, 0.125, 0.596)], [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.752, 0.227, 0.513)], [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.837, 0.329, 0.431)], [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.907, 0.435, 0.353)], [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.963, 0.554, 0.272)], [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.992, 0.681, 0.195)], [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.987, 0.822, 0.144)], [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.94, 0.975, 0.131)]],\n  YELLOW_GREEN: [[0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.1647, 0.2824, 0.3451)], [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.1338, 0.3555, 0.4227)], [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.061, 0.4319, 0.4864)], [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0.5099, 0.5319)], [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0.5881, 0.5569)], [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.137, 0.665, 0.5614)], [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.2906, 0.7395, 0.5477)], [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.4453, 0.8099, 0.5201)], [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.6102, 0.8748, 0.485)], [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.7883, 0.9323, 0.4514)], [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9804, 0.9804, 0.4314)]],\n  VIRIDIS: [[0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.267, 5e-3, 0.329)], [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.283, 0.141, 0.458)], [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.254, 0.265, 0.53)], [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.207, 0.372, 0.553)], [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.164, 0.471, 0.558)], [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.128, 0.567, 0.551)], [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.135, 0.659, 0.518)], [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.267, 0.749, 0.441)], [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.478, 0.821, 0.318)], [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.741, 0.873, 0.15)], [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.993, 0.906, 0.144)]],\n  INFERNO: [[0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.077, 0.042, 0.206)], [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.225, 0.036, 0.388)], [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.373, 0.074, 0.432)], [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.522, 0.128, 0.42)], [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.665, 0.182, 0.37)], [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.797, 0.255, 0.287)], [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.902, 0.364, 0.184)], [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.969, 0.516, 0.063)], [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.988, 0.683, 0.072)], [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.961, 0.859, 0.298)], [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.988, 0.998, 0.645)]],\n  GRAYSCALE: [[0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0)], [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1)]],\n  // 16 samples of the TURBU color scheme\n  // values taken from: https://gist.github.com/mikhailov-work/ee72ba4191942acecc03fe6da94fc73f\n  // original file licensed under Apache-2.0\n  TURBO: [[0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.18995, 0.07176, 0.23217)], [0.07, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.25107, 0.25237, 0.63374)], [0.13, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.27628, 0.42118, 0.89123)], [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.25862, 0.57958, 0.99876)], [0.27, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.15844, 0.73551, 0.92305)], [0.33, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.09267, 0.86554, 0.7623)], [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.19659, 0.94901, 0.59466)], [0.47, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.42778, 0.99419, 0.38575)], [0.53, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.64362, 0.98999, 0.23356)], [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.80473, 0.92452, 0.20459)], [0.67, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.93301, 0.81236, 0.22667)], [0.73, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.99314, 0.67408, 0.20348)], [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9836, 0.49291, 0.12849)], [0.87, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.92105, 0.31489, 0.05475)], [0.93, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.81608, 0.18462, 0.01809)], [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.66449, 0.08436, 424e-5)]],\n  RAINBOW: [[0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.278, 0, 0.714)], [1 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 1)], [2 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 1, 1)], [3 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 1, 0)], [4 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 0)], [5 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 0.64, 0)], [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 0, 0)]],\n  CONTOUR: [[0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0)], [0.03, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0)], [0.04, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1)], [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1)]]\n},\n      NB = `\n  varying vec3 vColor;\n  uniform float alpha;\n\n  void main() {\n    if (vColor == vec3(0.0, 0.0, 0.0)) {\n      discard;\n    } else {\n      gl_FragColor = vec4( vColor, alpha);\n    }\n  }\n`,\n      UB = `\n  varying vec3 vColor;\n  uniform sampler2D gradient;\n  uniform sampler2D grayscale;\n  attribute float intensity;\n  attribute float classification;\n  uniform vec3 rootCenter;\n  uniform vec3 rootNormal;\n  uniform vec2 elevationRange;\n  uniform int coloring;\n  uniform bool hideGround;\n  uniform float maxIntensity;\n  uniform float intensityContrast;\n  uniform float pointSize;\n\n  #ifdef USE_COLOR\n  vec3 getRGB() {\n      vec3 rgb = color;\n      return rgb;\n  }\n  #endif\n\n  vec3 getElevation(){\n    vec4 world = modelMatrix * vec4( position, 1.0 );\n    float diff = abs(dot(rootNormal, (vec3(world) - rootCenter)));\n    float w = max(diff - elevationRange.x,0.0) / max(elevationRange.y - elevationRange.x,1.0);\n    vec3 cElevation = texture2D(gradient, vec2(w,1.0-w)).rgb;\n\n    return cElevation;\n  }\n\n  vec3 getIntensity(){\n    // TODO: real contrast enhancement. Check https://github.com/yuki-koyama/enhancer/blob/master/shaders/enhancer.fs\n    float intmod = pow(intensity, intensityContrast);\n    vec3 cIntensity = texture2D(grayscale, vec2(intmod / maxIntensity ,1.0-(intmod / maxIntensity))).rgb;\n    return cIntensity;\n  }\n\n  vec3 getClassification(){\n    float classNormalized = classification / 255.0;\n    vec3 cClassification = texture2D(gradient, vec2(classNormalized * 5.0,1.0-classNormalized * 5.0)).rgb;\n    return cClassification;\n  }\n\n  vec3 getColor(){\n      vec3 color;\n      if (hideGround && classification == 2.0) {\n         return vec3(0.0, 0.0, 0.0);               \n      }\n\n      if (coloring == 1) {\n        color = getIntensity();\n      }\n      else if (coloring == 2) {\n        color = getClassification();\n      } else if (coloring == 3) {\n        color = getElevation();\n      } \n      #ifdef USE_COLOR\n      else if (coloring == 4) {\n        color = getRGB();\n      }\n      #endif\n      else {\n        color = vec3(1.0, 1.0, 1.0);\n      }\n      return color;\n  }\n\n  void main() {\n      vColor = getColor();\n\n      gl_PointSize = pointSize;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  }\n`;\n\nvar Hc = /* @__PURE__ */(e => (e[e.Intensity = 1] = \"Intensity\", e[e.Classification = 2] = \"Classification\", e[e.Elevation = 3] = \"Elevation\", e[e.RGB = 4] = \"RGB\", e[e.White = 5] = \"White\", e))(Hc || {}),\n    jn = /* @__PURE__ */(e => (e[e.FlatTexture = 1] = \"FlatTexture\", e[e.ShadedTexture = 2] = \"ShadedTexture\", e[e.ShadedNoTexture = 3] = \"ShadedNoTexture\", e))(jn || {});\n\nconst HB = Uc.RAINBOW,\n      JB = typeof document < \"u\" ? Pc(HB) : null,\n      VB = Uc.GRAYSCALE,\n      jB = typeof document < \"u\" ? Pc(VB) : null,\n      kB = {\n  throttleRequests: !0,\n  maxRequests: 64,\n  updateInterval: 0.1,\n  maxConcurrency: 1,\n  maximumScreenSpaceError: 16,\n  memoryAdjustedScreenSpaceError: !0,\n  maximumMemoryUsage: 400,\n  memoryCacheOverflow: 128,\n  viewDistanceScale: 1,\n  skipLevelOfDetail: !1,\n  resetTransform: !1,\n  updateTransforms: !0,\n  shading: jn.FlatTexture,\n  transparent: !1,\n  pointCloudColoring: Hc.White,\n  pointSize: 1,\n  worker: !0,\n  wireframe: !1,\n  debug: !1,\n  gltfLoader: null,\n  basisTranscoderPath: null,\n  dracoDecoderPath: null,\n  material: null,\n  contentPostProcess: void 0,\n  preloadTilesCount: null,\n  collectAttributions: !1\n};\n\nclass t1 {\n  /**\n  * Loads a tileset of 3D Tiles according to the given {@link LoaderProps}\n  * @public\n  *\n  * @param props - Properties for this load call {@link LoaderProps}.\n  * @returns An object containing the 3D Model to be added to the scene\n  * and a runtime engine to be updated every frame.\n  */\n  static async load(t) {\n    const n = { ...kB,\n      ...t.options\n    },\n          {\n      url: s\n    } = t;\n    let {\n      viewport: r,\n      renderer: i\n    } = t;\n    const o = n.updateInterval,\n          a = 5,\n          c = {};\n\n    if (n.cesiumIONToken) {\n      c[\"cesium-ion\"] = {\n        accessToken: n.cesiumIONToken\n      };\n      const T = await bc.preload(s, c);\n      c.fetch = {\n        headers: T.headers\n      };\n    }\n\n    n.googleApiKey && (c.fetch = {\n      headers: {\n        \"X-GOOG-API-KEY\": n.googleApiKey\n      }\n    }, t.options.hasOwnProperty(\"collectAttributions\") || (n.collectAttributions = !0)), t.loadingManager && t.loadingManager.itemStart(s);\n    const u = await Ae(s, Le, { ...c\n    }),\n          l = {},\n          h = {},\n          f = [],\n          d = new three__WEBPACK_IMPORTED_MODULE_0__.Group(),\n          m = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n    n.debug || (m.visible = !1);\n    const g = {\n      pointSize: {\n        type: \"f\",\n        value: n.pointSize\n      },\n      gradient: {\n        type: \"t\",\n        value: JB\n      },\n      grayscale: {\n        type: \"t\",\n        value: jB\n      },\n      rootCenter: {\n        type: \"vec3\",\n        value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n      },\n      rootNormal: {\n        type: \"vec3\",\n        value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n      },\n      coloring: {\n        type: \"i\",\n        value: n.pointCloudColoring\n      },\n      hideGround: {\n        type: \"b\",\n        value: !0\n      },\n      elevationRange: {\n        type: \"vec2\",\n        value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 400)\n      },\n      maxIntensity: {\n        type: \"f\",\n        value: 1\n      },\n      intensityContrast: {\n        type: \"f\",\n        value: 1\n      },\n      alpha: {\n        type: \"f\",\n        value: 1\n      }\n    },\n          y = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n      uniforms: g,\n      vertexShader: UB,\n      fragmentShader: NB,\n      transparent: n.transparent,\n      vertexColors: !0\n    });\n    let E, R, B;\n    n.gltfLoader ? E = n.gltfLoader : (E = new three__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader(), n.basisTranscoderPath && (R = new three__WEBPACK_IMPORTED_MODULE_0__.KTX2Loader(), R.detectSupport(i ?? new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderer()), R.setTranscoderPath(n.basisTranscoderPath + \"/\"), R.setWorkerLimit(1), E.setKTX2Loader(R)), n.dracoDecoderPath && (B = new three__WEBPACK_IMPORTED_MODULE_0__.DRACOLoader(), B.setDecoderPath(n.dracoDecoderPath + \"/\"), B.setWorkerLimit(n.maxConcurrency), E.setDRACOLoader(B)));\n    const C = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n      transparent: n.transparent\n    }),\n          M = {\n      maximumMemoryUsage: n.maximumMemoryUsage,\n      maximumScreenSpaceError: n.maximumScreenSpaceError,\n      memoryAdjustedScreenSpaceError: n.memoryAdjustedScreenSpaceError,\n      memoryCacheOverflow: n.memoryCacheOverflow,\n      viewDistanceScale: n.viewDistanceScale,\n      skipLevelOfDetail: n.skipLevelOfDetail,\n      updateTransforms: n.updateTransforms,\n      throttleRequests: n.throttleRequests,\n      maxRequests: n.maxRequests,\n      contentLoader: async T => {\n        let D = null;\n\n        switch (T.type) {\n          case Pe.POINTCLOUD:\n            {\n              D = zB(T, y, n, Pt);\n              break;\n            }\n\n          case Pe.SCENEGRAPH:\n          case Pe.MESH:\n            {\n              D = await KB(E, T, C, n, Pt);\n              break;\n            }\n        }\n\n        if (D && (D.visible = !1, l[T.id] = D, d.add(l[T.id]), n.debug)) {\n          const Z = Ho(T);\n          m.add(Z), h[T.id] = Z;\n        }\n      },\n      onTileLoad: async T => {\n        b && (n.resetTransform && !L && (T == null ? void 0 : T.depth) <= a && Xt(T), Wt = !0);\n      },\n      onTileUnload: T => {\n        f.push(T);\n      },\n      onTileError: (T, D) => {\n        console.warn(\"Tile error\", T.id, D);\n      },\n\n      onTraversalComplete(T) {\n        return n.collectAttributions && (k = XB(T)), T;\n      }\n\n    },\n          b = new MB(u, { ...M,\n      loadOptions: { ...c,\n        maxConcurrency: n.maxConcurrency,\n        worker: n.worker,\n        gltf: {\n          loadImages: !1\n        },\n        \"3d-tiles\": {\n          loadGLTF: !1\n        }\n      }\n    }),\n          O = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(),\n          F = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(),\n          v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    let L = !1,\n        k = \"\";\n\n    if (b.root.boundingVolume ? (b.root.header.boundingVolume.region && console.warn(\"Cannot apply a model matrix to bounding volumes of type region. Tileset stays in original geo-coordinates.\"), F.setPosition(b.root.boundingVolume.center[0], b.root.boundingVolume.center[1], b.root.boundingVolume.center[2])) : console.warn(\"Bounding volume not found, no transformations applied\"), n.debug) {\n      const T = Ho(b.root);\n      m.add(T), h[b.root.id] = T;\n    }\n\n    let q = !1,\n        Y = !1;\n    g.rootCenter.value.copy(v), g.rootNormal.value.copy(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1).normalize()), b.stats.get(\"Loader concurrency\").count = n.maxConcurrency, b.stats.get(\"Maximum mem usage\").count = n.maximumMemoryUsage;\n    let P = 0,\n        ct = null,\n        Wt = !0,\n        oe = null;\n    const Be = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1 / 0, 1 / 0, 1 / 0);\n    let vt = null;\n    d.updateMatrixWorld(!0);\n    const st = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(d.matrixWorld),\n          Pt = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(st).invert();\n    n.resetTransform && Xt(b.root), n.debug && (h[b.root.id].applyMatrix4(O), m.matrixWorld.copy(d.matrixWorld));\n\n    function Xt(T) {\n      if (!T.boundingVolume.halfAxes) return;\n      const D = T.boundingVolume.halfAxes,\n            Z = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().extractRotation(Gc(D)).premultiply(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().extractRotation(Pt));\n\n      if (!new three__WEBPACK_IMPORTED_MODULE_0__.Euler().setFromRotationMatrix(Z).equals(new three__WEBPACK_IMPORTED_MODULE_0__.Euler())) {\n        L = !0;\n\n        const _t = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(F.elements[12], F.elements[13], F.elements[14]);\n\n        F.extractRotation(Z), F.setPosition(_t);\n      }\n\n      Ce();\n    }\n\n    function Ce() {\n      O.copy(st), n.resetTransform && O.multiply(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(F).invert()), b.modelMatrix = new V(O.toArray());\n    }\n\n    function $e(T, D, Z, Q) {\n      if (q || !Q) return;\n\n      if (!vt) {\n        if (Q instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) vt = new Dn({\n          fov: Q.fov / 180 * Math.PI,\n          aspectRatio: Q.aspect,\n          near: Q.near,\n          far: Q.far\n        }).sseDenominator;else if (Q instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera) {\n          const K = Q.right - Q.left,\n                jr = Q.top - Q.bottom,\n                Vc = K / jr;\n          vt = Math.max(jr / Z.height, K / (Z.height * Vc));\n        }\n        n.debug && console.log(\"Updated sse denonimator:\", vt);\n      }\n\n      const ns = Uo(Q).planes.map(K => new nt(K.normal.toArray(), K.constant)),\n            Jc = new dt(ns),\n            Jr = {\n        camera: {\n          position: Be.toArray()\n        },\n        height: Z.height * Z.devicePixelRatio,\n        frameNumber: T._frameNumber,\n        sseDenominator: vt,\n        cullingVolume: Jc,\n        viewport: {\n          id: 0\n        }\n      };\n      T._cache.reset(), T._traverser.traverse(T.root, Jr, T.options);\n\n      for (const K of T.tiles) K.selected ? D[K.id] ? D[K.id].visible = !0 : console.error(\"TILE SELECTED BUT NOT LOADED!!\", K.id) : D[K.id] && (D[K.id].visible = !1);\n\n      for (; f.length > 0;) {\n        const K = f.pop();\n        D[K.id] && K.contentState == lt.UNLOADED && (d.remove(D[K.id]), Us(D[K.id]), delete D[K.id]), h[K.id] && (Us(h[K.id]), m.remove(h[K.id]), delete h[K.id]);\n      }\n\n      const ss = T.stats.get(\"Tiles Loaded\").count,\n            Vr = T.stats.get(\"Tiles Loading\").count;\n      return t.onProgress && t.onProgress(ss, ss + Vr), t.loadingManager && !Y && Vr == 0 && (n.preloadTilesCount == null || ss >= n.preloadTilesCount) && (Y = !0, t.loadingManager.itemEnd(t.url)), Jr;\n    }\n\n    function es(T) {\n      const D = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n            Z = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion(),\n            Q = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      T.decompose(D, Z, Q), d.position.copy(D), d.quaternion.copy(Z), d.scale.copy(Q), d.updateMatrix(), d.updateMatrixWorld(!0), st.copy(d.matrixWorld), Pt.copy(st).invert(), Ce();\n    }\n\n    return {\n      model: d,\n      runtime: {\n        getTileset: () => b,\n        getStats: () => b.stats,\n        getDataAttributions: () => k,\n        showTiles: T => {\n          m.visible = T;\n        },\n        setWireframe: T => {\n          n.wireframe = T, d.traverse(D => {\n            D instanceof three__WEBPACK_IMPORTED_MODULE_0__.Mesh && (D.material.wireframe = T);\n          });\n        },\n        setDebug: T => {\n          n.debug = T, m.visible = T;\n        },\n        setShading: T => {\n          n.shading = T;\n        },\n        getTileBoxes: () => m,\n        setViewDistanceScale: T => {\n          b.options.viewDistanceScale = T, b._frameNumber++, $e(b, l, r, oe);\n        },\n        setMaximumScreenSpaceError: T => {\n          b.options.maximumScreenSpaceError = T, b._frameNumber++, $e(b, l, r, oe);\n        },\n        setHideGround: T => {\n          g.hideGround.value = T;\n        },\n        setPointCloudColoring: T => {\n          g.coloring.value = T;\n        },\n        setElevationRange: T => {\n          g.elevationRange.value.set(T[0], T[1]);\n        },\n        setMaxIntensity: T => {\n          g.maxIntensity.value = T;\n        },\n        setIntensityContrast: T => {\n          g.intensityContrast.value = T;\n        },\n        setPointAlpha: T => {\n          g.alpha.value = T;\n        },\n        getLatLongHeightFromPosition: T => {\n          const D = b.ellipsoid.cartesianToCartographic(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(T).applyMatrix4(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(O).invert()).toArray());\n          return {\n            lat: D[1],\n            long: D[0],\n            height: D[2]\n          };\n        },\n        getPositionFromLatLongHeight: T => {\n          const D = b.ellipsoid.cartographicToCartesian([T.long, T.lat, T.height]);\n          return new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...D).applyMatrix4(O);\n        },\n        orientToGeocoord: T => {\n          const D = [T.long, T.lat, T.height],\n                Z = b.ellipsoid.cartographicToCartesian(D),\n                Q = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray(b.ellipsoid.eastNorthUpToFixedFrame(Z)),\n                _t = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeRotationFromEuler(new three__WEBPACK_IMPORTED_MODULE_0__.Euler(Math.PI / 2, Math.PI / 2, 0)),\n                ns = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(Q).multiply(_t).invert();\n\n          es(ns);\n        },\n        getWebMercatorCoord: T => xB(T.lat, T.long),\n        getCameraFrustum: T => {\n          const Z = Uo(T).planes.map(_t => new nt(_t.normal.toArray(), _t.constant)).map(_t => IB(_t)),\n                Q = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\n          for (const _t of Z) Q.add(_t);\n\n          return Q;\n        },\n        overlayGeoJSON: (T, D) => {\n          if (T.applyMatrix4(O), T.updateMatrixWorld(), !i) throw new Error(\"GeoJSON draping requires a renderer reference via LoaderProps\");\n          return OB(r, d, i, D), T.material.dispose(), T.material = kt, T;\n        },\n        setViewport: T => {\n          r = T, vt = null, Wt = !0, ht && FB(r);\n        },\n        setRenderer: T => {\n          i = T;\n        },\n        update: function (T, D) {\n          if (oe = D, P += T, ht && DB(D), b && P >= o) {\n            if (!st.equals(d.matrixWorld)) {\n              P = 0, st.copy(d.matrixWorld), n.updateTransforms && Ce();\n              const Z = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().setFromMatrixPosition(st);\n              g.rootCenter.value.copy(Z), g.rootNormal.value.copy(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1).applyMatrix4(st).normalize()), Pt.copy(st).invert(), n.debug && (h[b.root.id].matrixWorld.copy(O), h[b.root.id].applyMatrix4(st));\n            }\n\n            ct == null ? ct = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(D.matrixWorld) : (Wt || WB(D, ct)) && (P = 0, Wt = !1, b._frameNumber++, D.getWorldPosition(Be), ct.copy(D.matrixWorld), $e(b, l, r, D));\n          }\n        },\n        dispose: function () {\n          for (q = !0, b._destroy(); d.children.length > 0;) {\n            const T = d.children[0];\n            Us(T), d.remove(T);\n          }\n\n          for (; m.children.length > 0;) {\n            const T = m.children[0];\n            m.remove(T), T.geometry.dispose(), T.material.dispose();\n          }\n\n          R && R.dispose(), B && B.dispose();\n        }\n      }\n    };\n  }\n  /**\n  * Loads a tileset of 3D Tiles according to the given {@link GeoJSONLoaderProps}\n  * Could be overlayed on geograpical 3D Tiles using {@link Runtime.overlayGeoJSON}\n  * @public\n  *\n  * @param props - Properties for this load call {@link GeoJSONLoaderProps}.\n  * @returns An object containing the 3D Model to be added to the scene\n  */\n\n\n  static async loadGeoJSON(t) {\n    const {\n      url: n,\n      height: s,\n      featureToColor: r\n    } = t;\n    return Ae(n, ke, {\n      worker: !1,\n      gis: {\n        format: \"binary\"\n      }\n    }).then(i => {\n      const o = i,\n            a = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(),\n            c = o.polygons.positions.value.reduce((h, f, d, m) => {\n        if (d % 2 == 0) {\n          const g = [f, m[d + 1], s ?? 0],\n                y = J.WGS84.cartographicToCartesian(g);\n          h.push(...y);\n        }\n\n        return h;\n      }, []);\n\n      if (a.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(c, 3)), r) {\n        const h = o.polygons.numericProps[r.feature].value.reduce((f, d, m, g) => {\n          const y = r.colorMap(d);\n          return f[m * 3] = y.r, f[m * 3 + 1] = y.g, f[m * 3 + 2] = y.b, f;\n        }, []);\n        a.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(h, 3));\n      }\n\n      a.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(o.polygons.triangles.value, 1));\n      const u = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n        transparent: !0,\n        vertexColors: !0,\n        opacity: 0.5,\n        blending: three__WEBPACK_IMPORTED_MODULE_0__.NormalBlending\n      });\n      return new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(a, u);\n    });\n  }\n\n}\n\nasync function KB(e, t, n, s, r) {\n  return new Promise((i, o) => {\n    const a = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeRotationAxis(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0), Math.PI / 2),\n          c = t.content.gltfUpAxis !== \"Z\",\n          u = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray(t.computedTransform).premultiply(r);\n    c && u.multiply(a), t.content.byteLength || (t.content.byteLength = t.content.gltfArrayBuffer.byteLength), e.parse(t.content.gltfArrayBuffer, t.contentUrl ? t.contentUrl.substr(0, t.contentUrl.lastIndexOf(\"/\") + 1) : null, l => {\n      t.userData.asset = l.asset;\n      const h = l.scenes[0];\n      h.applyMatrix4(u), t.content.texturesByteLength = 0, t.content.geometriesByteLength = 0, h.traverse(f => {\n        if (f.type == \"Mesh\") {\n          const d = f;\n          t.content.geometriesByteLength += Nc(d.geometry);\n          const m = d.material,\n                g = m.map;\n\n          if (g) {\n            const y = vB(g);\n            y && (t.content.texturesByteLength += y);\n          }\n\n          s.material ? (d.material = s.material.clone(), m.dispose()) : s.shading == jn.FlatTexture && d.material.type !== \"MeshBasicMaterial\" && (d.material = n.clone(), m.dispose()), s.shading != jn.ShadedNoTexture ? d.material.type == \"ShaderMaterial\" ? d.material.uniforms.map = {\n            value: g\n          } : d.material.map = g : (g && g.dispose(), d.material.map = null), d.material.wireframe = s.wireframe, s.contentPostProcess && s.contentPostProcess(d);\n        }\n      }), t.content.gpuMemoryUsageInBytes = t.content.texturesByteLength + t.content.geometriesByteLength, i(h);\n    }, l => {\n      o(new Error(`error parsing gltf in tile ${t.id}: ${l}`));\n    });\n  });\n}\n\nfunction zB(e, t, n, s) {\n  const r = {\n    rtc_center: e.content.rtcCenter,\n    // eslint-disable-line camelcase\n    points: e.content.attributes.positions,\n    intensities: e.content.attributes.intensity,\n    classifications: e.content.attributes.classification,\n    rgb: null,\n    rgba: null\n  },\n        {\n    colors: i\n  } = e.content.attributes;\n  i && i.size === 3 && (r.rgb = i.value), i && i.size === 4 && (r.rgba = i.value);\n  const o = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n  o.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(r.points, 3));\n  const a = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray(e.computedTransform).premultiply(s);\n  r.rgba ? o.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(r.rgba, 4)) : r.rgb && o.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Uint8BufferAttribute(r.rgb, 3, !0)), r.intensities && o.setAttribute(\"intensity\", // Handles both 16bit or 8bit intensity values\n  new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(r.intensities, 1, !0)), r.classifications && o.setAttribute(\"classification\", new three__WEBPACK_IMPORTED_MODULE_0__.Uint8BufferAttribute(r.classifications, 1, !1)), e.content.geometriesByteLength = Nc(o), e.content.gpuMemoryUsageInBytes = e.content.geometriesByteLength;\n  const c = new three__WEBPACK_IMPORTED_MODULE_0__.Points(o, n.material || t);\n\n  if (r.rtc_center) {\n    const u = r.rtc_center;\n    a.multiply(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeTranslation(u[0], u[1], u[2]));\n  }\n\n  return c.applyMatrix4(a), n.contentPostProcess && n.contentPostProcess(c), c;\n}\n\nfunction Vo(e) {\n  var t, n, s, r;\n  (t = e == null ? void 0 : e.uniforms) != null && t.map ? (s = (n = e == null ? void 0 : e.uniforms) == null ? void 0 : n.map.value) == null || s.dispose() : e.map && ((r = e.map) == null || r.dispose()), e.dispose();\n}\n\nfunction Us(e) {\n  e.traverse(t => {\n    if (t.isMesh) if (t.geometry.dispose(), t.material.isMaterial) Vo(t.material);else for (const n of t.material) Vo(n);\n  });\n\n  for (let t = e.children.length - 1; t >= 0; t--) {\n    const n = e.children[t];\n    e.remove(n);\n  }\n}\n\nfunction WB(e, t, n) {\n  const s = !e.matrixWorld.equals(t);\n  return e instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera ? s || e.aspect !== n : s;\n}\n\nfunction XB(e) {\n  const t = /* @__PURE__ */new Map();\n  return e.forEach(r => {\n    var o, a;\n    const i = (a = (o = r == null ? void 0 : r.userData) == null ? void 0 : o.asset) == null ? void 0 : a.copyright;\n    i && i.split(/;/g).map(u => u.trim()).forEach(u => {\n      u && t.set(u, (t.get(u) || 0) + 1);\n    });\n  }), Array.from(t).sort((r, i) => i[1] - r[1]).map(([r]) => r).join(\"; \");\n}\n\n\n\n//# sourceURL=webpack://aframe-loader-3dtiles-component/./lib/three-loader-3dtiles.js?");

/***/ }),

/***/ "./textarea.js":
/*!*********************!*\
  !*** ./textarea.js ***!
  \*********************/
/***/ (() => {

eval("if (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n/**\n * Textarea component for A-Frame.\n *\n * Ripped from: https://github.com/brianpeiris/aframe-textarea-component\n */\n\n\nAFRAME.registerComponent('textarea', {\n  schema: {\n    transparentBG: {\n      type: 'boolean',\n      default: false\n    },\n    cols: {\n      type: 'int',\n      default: 40\n    },\n    rows: {\n      type: 'int',\n      default: 20\n    },\n    color: {\n      type: 'color',\n      default: 'black'\n    },\n    backgroundColor: {\n      type: 'color',\n      default: 'white'\n    },\n    disabledBackgroundColor: {\n      type: 'color',\n      default: 'lightgrey'\n    },\n    disabled: {\n      type: 'boolean',\n      default: false\n    },\n    text: {\n      type: 'string',\n      default: ''\n    }\n  },\n  init: function () {\n    this.text = null;\n    this.lines = [];\n    this.lastBlink = 0;\n    this.blinkEnabled = !this.data.disabled;\n    this.charWidth = this.charHeight = null;\n    this.selectionStart = this.selectionEnd = 0;\n    this.endIndexInfo = this.startIndexInfo = null;\n    this.origin = {\n      x: 0,\n      y: 0\n    };\n    this.background = document.createElement('a-plane');\n    this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    this.el.appendChild(this.background);\n\n    if (this.data.transparentBG) {\n      this.background.setAttribute('material', {\n        opacity: 0,\n        transparent: true\n      });\n    }\n\n    this.textAnchor = document.createElement('a-entity');\n    this.el.appendChild(this.textAnchor);\n    this.textAnchor.setAttribute('text', {\n      mode: 'pre',\n      baseline: 'top',\n      anchor: 'center',\n      font: 'dejavu',\n      wrapCount: this.data.cols,\n      height: this.data.rows,\n      color: this.data.color\n    });\n\n    this._initTextarea();\n\n    this.el.addEventListener('textfontset', this._updateCharMetrics.bind(this));\n    this.el.addEventListener('char-metrics-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('text-changed', this._updateLines.bind(this));\n    this.el.addEventListener('text-changed', this._updateDisplayText.bind(this));\n    this.el.addEventListener('selection-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('selection-changed', this._updateHorizontalOrigin.bind(this));\n    this.el.addEventListener('lines-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('index-info-changed', this._updateOrigin.bind(this));\n    this.el.addEventListener('index-info-changed', this._updateHorizontalOrigin.bind(this));\n    this.el.addEventListener('origin-changed', this._updateDisplayText.bind(this));\n    this.el.addEventListener('click', this.focus.bind(this));\n  },\n  update: function (oldData) {\n    if (this.data.text !== oldData.text) {\n      this._updateTextarea();\n    }\n\n    if (this.data.backgroundColor !== oldData.backgroundColor || this.data.disabledBackgroundColor !== oldData.disabledBackgroundColor) {\n      this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    }\n\n    if (this.data.disabled !== oldData.disabled) {\n      this.blinkEnabled = !this.data.disabled;\n      this.textarea.disabled = this.data.disabled;\n      this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    }\n  },\n  focus: function () {\n    this.textarea.focus();\n  },\n  _initTextarea: function () {\n    this.textarea = document.createElement('textarea');\n    document.body.appendChild(this.textarea);\n\n    this._updateTextarea();\n  },\n  _updateTextarea: function () {\n    this.textarea.style.whiteSpace = 'pre';\n    this.textarea.style.overflow = 'hidden';\n    this.textarea.style.opacity = '0';\n    this.textarea.cols = this.data.cols;\n    this.textarea.rows = this.data.rows;\n    this.textarea.value = this.data.text;\n    this.textarea.selectionStart = 0;\n    this.textarea.selectionEnd = 0;\n\n    this._updateIndexInfo();\n  },\n  _emit: function (eventName, detail) {\n    this.el.emit(eventName, detail);\n  },\n  _updateCharMetrics: function (event) {\n    const layout = this.textAnchor.components.text.geometry.layout;\n    const fontWidthFactor = event.detail.fontObj.widthFactor;\n    this.charWidth = fontWidthFactor * this.textAnchor.object3DMap.text.scale.x;\n    this.charHeight = this.charWidth * layout.lineHeight / fontWidthFactor;\n    this.textAnchor.setAttribute('position', {\n      x: 0,\n      y: this.charHeight * this.data.rows / 2,\n      z: 0\n    });\n\n    if (!this.data.transparentBG) {\n      this.background.setAttribute('scale', {\n        x: 1.05,\n        y: this.charHeight * this.data.rows * 1.05,\n        z: 1\n      });\n      this.background.setAttribute('position', {\n        x: 0,\n        y: 0,\n        z: 0\n      });\n    }\n\n    this._emit('char-metrics-changed');\n  },\n  _checkAndUpdateSelection: function () {\n    if (this.selectionStart === this.textarea.selectionStart && this.selectionEnd === this.textarea.selectionEnd) {\n      return;\n    }\n\n    const lastStart = this.selectionStart;\n    const lastEnd = this.selectionEnd;\n    this.selectionStart = this.textarea.selectionStart;\n    this.selectionEnd = this.textarea.selectionEnd;\n\n    this._emit('selection-changed', {\n      start: {\n        old: lastStart,\n        new: this.selectionStart,\n        changed: this.selectionStart !== lastStart\n      },\n      end: {\n        old: lastEnd,\n        new: this.selectionEnd,\n        changed: this.selectionEnd !== lastEnd\n      }\n    });\n  },\n  tick: function (time) {\n    if (time - this.lastBlink > 500 && this.blinkEnabled) {\n      this.lastBlink = time;\n    }\n\n    this._checkAndUpdateSelection();\n\n    this._checkAndUpdateText();\n  },\n  _getIndexInfo: function (lineIndex, textIndex) {\n    const y = Math.max(0, lineIndex);\n    const line = this.lines[y];\n    const x = textIndex - line.start;\n    return {\n      line: line,\n      x: x * this.charWidth,\n      y: -this.charHeight * y + -this.charHeight / 2\n    };\n  },\n  _updateIndexInfo: function () {\n    if (!this.lines.length) {\n      return;\n    }\n\n    const lastStart = this.startIndexInfo && this.startIndexInfo.line.index;\n    const lastEnd = this.endIndexInfo && this.endIndexInfo.line.index;\n    this.startIndexInfo = null;\n    this.endIndexInfo = null;\n    let i;\n    let startChanged = false;\n    let endChanged = false;\n\n    for (i = 0; i <= this.lines.length; i++) {\n      const prevLine = this.lines[i - 1];\n      const lineStart = i === this.lines.length ? prevLine.start + prevLine.length + 1 : this.lines[i].start;\n\n      if (lineStart > this.selectionStart && !this.startIndexInfo) {\n        this.startIndexInfo = this._getIndexInfo(i - 1, this.selectionStart);\n\n        if (this.startIndexInfo.line.index !== lastStart) {\n          startChanged = true;\n        }\n      }\n\n      if (lineStart > this.selectionEnd) {\n        this.endIndexInfo = this._getIndexInfo(i - 1, this.selectionEnd);\n\n        if (this.endIndexInfo.line.index !== lastEnd) {\n          endChanged = true;\n        }\n\n        break;\n      }\n    }\n\n    if (startChanged || endChanged) {\n      this._emit('index-info-changed', {\n        start: {\n          changed: startChanged\n        },\n        end: {\n          changed: endChanged\n        }\n      });\n    }\n  },\n  _updateOrigin: function (event) {\n    let changed = false;\n\n    if (event.detail.end.changed) {\n      const end = this.origin.y + this.data.rows - 1;\n\n      if (this.endIndexInfo.line.index > end) {\n        this.origin.y = this.endIndexInfo.line.index + 1 - this.data.rows;\n        changed = true;\n      } else if (this.endIndexInfo.line.index < this.origin.y) {\n        this.origin.y = this.endIndexInfo.line.index;\n        changed = true;\n      }\n    }\n\n    if (event.detail.start.changed) {\n      if (this.startIndexInfo.line.index < this.origin.y) {\n        this.origin.y = this.startIndexInfo.line.index;\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      this._emit('origin-changed');\n    }\n  },\n  _updateHorizontalOrigin: function (event) {\n    if (!this.endIndexInfo) {\n      return;\n    }\n\n    let changed = true;\n\n    if (event.detail.end.changed) {\n      const endIndex = this.selectionEnd - this.endIndexInfo.line.start;\n\n      if (endIndex > this.origin.x + this.data.cols) {\n        this.origin.x = endIndex - this.data.cols;\n        changed = true;\n      } else if (endIndex < this.origin.x) {\n        this.origin.x = endIndex;\n        changed = true;\n      }\n    }\n\n    const startIndex = this.selectionStart - this.startIndexInfo.line.start;\n\n    if (event.detail.start.changed) {\n      if (startIndex > this.origin.x + this.data.cols) {\n        this.origin.x = startIndex - this.data.cols;\n        changed = true;\n      } else if (startIndex < this.origin.x) {\n        this.origin.x = startIndex;\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      this._emit('origin-changed');\n    }\n  },\n  _updateLines: function () {\n    this.lines = [];\n    const lines = this.text.split('\\n');\n    let counter = 0;\n\n    for (let i = 0; i < lines.length; i++) {\n      this.lines[i] = {\n        index: i,\n        length: lines[i].length,\n        start: counter\n      };\n      counter += lines[i].length + 1;\n    }\n\n    this._emit('lines-changed');\n  },\n  _getViewportText: function () {\n    return this.text.split('\\n').slice(this.origin.y, this.origin.y + this.data.rows).map(function (line) {\n      return line.substr(this.origin.x, this.data.cols) || ' ';\n    }.bind(this)).join('\\n');\n  },\n  _updateDisplayText: function () {\n    this.textAnchor.setAttribute('text', {\n      value: this._getViewportText()\n    });\n  },\n  _checkAndUpdateText: function () {\n    const text = this.textarea.value;\n\n    if (text === this.text) {\n      return;\n    }\n\n    this.text = text;\n\n    this._emit('text-changed');\n  }\n});\n\n//# sourceURL=webpack://aframe-loader-3dtiles-component/./textarea.js?");

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_three__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});